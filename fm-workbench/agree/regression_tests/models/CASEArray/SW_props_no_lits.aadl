package SW_props_no_lits
public
	with Data_Model;
	with Base_Types;
	with SW_Properties;
	
	data Longitude extends Base_Types::Integer
		properties
			Data_Model::Integer_Range => SW_Properties::MIN_LONGITUDE .. SW_Properties::MAX_LONGITUDE;
	end Longitude;
	
	data Lattitude extends Base_Types::Integer
		properties
			Data_Model::Integer_Range => SW_Properties::MIN_LATTITUDE .. SW_Properties::MAX_LATTITUDE;
	end Lattitude;
	
	data Altitude extends Base_Types::Integer
		properties
			Data_Model::Integer_Range => 0 .. SW_Properties::MAX_ALTITUDE;
	end Altitude;
	
	-- This is the structure to hold the lat/long/alt values of a coordinate
	data Coordinate
		properties
			Data_Model::Data_Representation => Struct;
	end Coordinate;

	data implementation Coordinate.Impl
		subcomponents
			lat: data Lattitude;
			long: data Longitude;
			alt: data Altitude; -- English feet
	end Coordinate.Impl;

	-- The Map is a structure that contains a list of coordinates that encircle a region.  
	-- In this implementation, we fix the size of the map to 4 waypoints
	data Map
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Coordinate.Impl));
			Data_Model::Dimension => (SW_Properties::MAP_DIMENSION);
	end Map;

	-- The Flight Pattern is an enumeration that defines how the UAV will fly through the
	-- sensing region for surveying.
	data FlightPattern
		properties
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("ZigZag", "StraightLine", "Perimeter");
	end FlightPattern;

	-- The Command structure contains data that the Ground Station passes to the UAV.
	-- It contains a Map, Flight Pattern and Authentication bit.
	data Command
		properties
			Data_Model::Data_Representation => Struct;
	end Command;

	data implementation Command.Impl
		subcomponents
			Map: data Map;
			Pattern: data FlightPattern;
			HMAC: data Base_Types::Boolean;
	end Command.Impl;

	-- The Mission is a list of waypoints that is generated by the Flight Planner based on a
	-- Map and Flight Pattern.
	-- For this implementation, we fix the size of the Mission to 10 waypoints.
	data Mission
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Coordinate.Impl));
			Data_Model::Dimension => (SW_Properties::MISSION_DIMENSION);
	end Mission;

	-- The Mission Window is a list of waypoints that the Waypoint Manager assembles from
	-- the Mission.
	-- For this implementation, we fix the size of the Mission Window to 4 waypoints.
	-- The crc value is an abstraction, which, if true, tells us that the data has not
	-- been corrupted.
	data MissionWindow
		properties
			Data_Model::Data_Representation => Struct;
	end MissionWindow;

	data implementation MissionWindow.Impl
		subcomponents
			wps: data Coordinate.Impl[SW_Properties::MISSION_WINDOW_DIMENSION];
			crc: data Base_Types::Boolean;
	end MissionWindow.Impl;
	
	annex agree {**
		

		fun good_longitude(long : Longitude) : bool =
				long >= SW_Properties::MIN_LONGITUDE
			and long <= SW_Properties::MAX_LONGITUDE;
		
		fun good_lattitude(lat : Lattitude) : bool =
				lat >= SW_Properties::MIN_LATTITUDE
			and lat <= SW_Properties::MAX_LATTITUDE;
		
		const MAX_ALTITUDE : int = SW_Properties::MAX_ALTITUDE;
			
		fun good_altitude(alt : Altitude) : bool =
				alt >= 0 
			and alt <= MAX_ALTITUDE;
			
		-- These functions check the well-formedness of message structures
				fun good_coordinate(coord : Coordinate.Impl) : int = coord.long;	
--		fun good_coordinate(coord : Coordinate.Impl) : bool =	
--				good_longitude(coord.long)
--			and good_lattitude(coord.lat)
--			and	good_altitude(coord.alt);
			
		fun good_map(map : Map) : bool =	
			forall coord in map, good_coordinate(coord);
													
		fun good_pattern(pattern : FlightPattern) : bool =	
				(pattern = enum(FlightPattern, ZigZag)) 
			or	(pattern = enum(FlightPattern, StraightLine)) 
			or 	(pattern = enum(FlightPattern, Perimeter));
																
		fun good_HMAC(hmac : bool) : bool = (hmac = True) or (hmac = False);
		
		fun good_gs_command(cmd : Command.Impl) : bool =	
				good_map(cmd.Map) 
			and good_pattern(cmd.Pattern)
			and good_HMAC(cmd.HMAC);
																
		fun good_mission(mission : Mission) : bool =	
			forall coord in mission, good_coordinate(coord);
																
--		fun good_mission_window(win : MissionWindow.Impl) : bool =	
--				forall coord in win.wps, good_coordinate(coord)
--			and	win.crc = true;
																									
	**};

	thread RadioDriver
		features
			recv_map_in: in event data port Command.Impl;
			send_status_out: out event data port Coordinate.Impl;
			send_status_in: in event data port Coordinate.Impl;
			recv_map_out: out event data port Command.Impl;
		annex agree {**
			assume "Authenticated command from the Ground Station" : recv_map_in.HMAC = True;
			guarantee "Authenticated command from the Ground Station" : recv_map_out.HMAC = True;
		**};
	end RadioDriver;

--	thread Filter
--		features
--			gs_command: in event data port Command.Impl;
--			filtered_command: out event data port Command.Impl;
--		properties
--			CASE::COMP_TYPE => FILTER;
--			CASE::COMP_IMPL => "CAKEML";
--			CASE::COMP_SPEC => "(\\i{-90,90}\\i{-180,180}\\i{0,15000}){4}(Z|S|P)(T|F)";
--			
--		annex agree {**
--
--			guarantee "The Flight Planner shall receive an authenticated command from the Ground Station" : filtered_command.HMAC = True;
--			guarantee "The Flight Planner shall receive a well-formed command from the Ground Station" : SW_props_no_lits.good_gs_command(filtered_command);
--
--		**};
--
--	end Filter;
	thread FlightPlanner
		features
			recv_map: in event data port Command.Impl;
			flight_plan: out data port Mission;
			position_status: in event data port Coordinate.Impl;
--		properties
--			CASE::AGREE_PROPERTIES_PASSED => ("good_gs_command");
		annex agree {**
			assume "The Flight Planner shall receive an authenticated command from the Ground Station" : recv_map.HMAC = True;
--			assume "The Flight Planner shall receive a well-formed command from the Ground Station" : SW_props_no_lits.good_gs_command(recv_map);
--			guarantee "The Flight Planner shall generate a valid mission" : SW_props_no_lits.good_mission(flight_plan);
		**};
--		annex Resolute {**
--			prove (well_formed(this, "good_gs_command"))
--		**};
	end FlightPlanner;

	thread WaypointManager
		features
			flight_plan: in data port Mission;
			waypoint: out event data port MissionWindow.Impl;
			position_status: in event data port Coordinate.Impl;
		annex agree {**
--			assume "The Waypoint Manager shall receive a well-formed mission" : SW_props_no_lits.good_mission(flight_plan);
--			guarantee "The Waypoint Manager shall output a well-formed mission window." : SW_props_no_lits.good_mission_window(waypoint);
		**};
	end WaypointManager;

	thread UARTDriver
		features
			position_status_in: in event data port Coordinate.Impl;
			waypoint_out: out event data port MissionWindow.Impl;
			position_status_out: out event data port Coordinate.Impl;
			waypoint_in: in event data port MissionWindow.Impl;
		annex agree {**
--			assume "Well-formed mission window" : SW_props_no_lits.good_mission_window(waypoint_in);
			guarantee "A CRC shall be appended to the message to determine message correctness" : waypoint_out.crc = True;
		**};
	end UARTDriver;

	process MC_SW
		features
			recv_map: in event data port Command.Impl;
			send_status: out event data port Coordinate.Impl;
			waypoint: out event data port MissionWindow.Impl;
			position_status: in event data port Coordinate.Impl;
		annex agree {**
			-- we abstract away the authentication and just assume the message has undergone authenticity verification
			assume "The Mission Computer shall only accept authenticated commands from the Ground Station" : recv_map.HMAC = True;
			guarantee "The Mission Computer shall output a valid mission window to the Flight Controller" : waypoint.crc = True;
		**};
	end MC_SW;

	process implementation MC_SW.Impl
		subcomponents
			RADIO: thread RadioDriver;
--			FLT: thread Filter;
			FPLN: thread FlightPlanner;
			WPM: thread WaypointManager;
			UART: thread UARTDriver;
		connections
			c1: port recv_map -> RADIO.recv_map_in;
			c2: port RADIO.send_status_out -> send_status;
			c3: port RADIO.recv_map_out -> FPLN.recv_map;
--			c3: port RADIO.recv_map_out -> FLT.gs_command;
--			c4: port FLT.filtered_command -> FPLN.recv_map;
			c5: port FPLN.flight_plan -> WPM.flight_plan;
			c6: port WPM.waypoint -> UART.waypoint_in;
			c7: port UART.position_status_out -> WPM.position_status;
			c8: port UART.position_status_out -> FPLN.position_status;
			c9: port UART.position_status_out -> RADIO.send_status_in;
			c10: port UART.waypoint_out -> waypoint;
			c11: port position_status -> UART.position_status_in;
	end MC_SW.Impl;
end SW_props_no_lits;