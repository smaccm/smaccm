package SW
public
	with UAV;

	with Data_Model;

	with Base_Types;

	with CASE_Properties;

	with CASE_Model_Transformations;
	renames CASE_Model_Transformations::all;

	data Coordinate
	end Coordinate;

	data implementation Coordinate.Impl
		-- This is the structure to hold the lat/long/alt values of a coordinate
		subcomponents
			latitude: data Base_Types::Integer;
			longitude: data Base_Types::Integer;
			altitude: data Base_Types::Integer;
	end Coordinate.Impl;

	data Map
	end Map;

	data implementation Map.Impl
		-- The Map is a structure that contains a list of coordinates that encircle a
		-- region.  
		-- In this implementation, we fix the size of the map to 4 waypoints
		-- Future versions will use an array
		subcomponents
			wp1: data Coordinate.Impl;
			wp2: data Coordinate.Impl;
			wp3: data Coordinate.Impl;
			wp4: data Coordinate.Impl;
	end Map.Impl;

	data MapArray
	end MapArray;

	data implementation MapArray.Impl
		-- The MapArray is a structure that hold multiple Maps
		-- In this implementation, we fix the size of the map array to 5 maps
		-- Future versions will use an array
		subcomponents
			map1: data Map.Impl;
			map2: data Map.Impl;
			map3: data Map.Impl;
			map4: data Map.Impl;
			map5: data Map.Impl;
	end MapArray.Impl;

	data FlightPattern
		-- The Flight Pattern is an enumeration that defines how the UAV will fly through the
		-- sensing region to conduct surveillance.
		properties
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("ZigZag", "StraightLine", "Perimeter");
	end FlightPattern;

	data implementation FlightPattern.Impl
	end FlightPattern.Impl;

	data Command
	end Command;

	data implementation Command.Impl
		-- The Command structure contains data that the Ground Station passes to the UAV.
		-- It contains a message header, Map and Flight Pattern.
		subcomponents
			header: data CASE_MsgHeader.Impl;
			map: data Map.Impl;
			pattern: data FlightPattern;
	end Command.Impl;

	data Mission
	end Mission;

	data implementation Mission.Impl
		-- The Mission is a list of waypoints that is generated by the Flight Planner based on a
		-- Map and Flight Pattern.
		-- For this implementation, we fix the size of the Mission to 10 waypoints.
		-- Future versions will use an array
		subcomponents
			wp1: data Coordinate.Impl;
			wp2: data Coordinate.Impl;
			wp3: data Coordinate.Impl;
			wp4: data Coordinate.Impl;
			wp5: data Coordinate.Impl;
			wp6: data Coordinate.Impl;
			wp7: data Coordinate.Impl;
			wp8: data Coordinate.Impl;
			wp9: data Coordinate.Impl;
			wp10: data Coordinate.Impl;
	end Mission.Impl;

	data MissionWindow
	end MissionWindow;

	data implementation MissionWindow.Impl
		-- The Mission Window is a list of waypoints that the Waypoint Manager assembles from the Mission.
		-- For this implementation, we fix the size of the Mission Window to 4 waypoints.
		subcomponents
			wp1: data Coordinate.Impl;
			wp2: data Coordinate.Impl;
			wp3: data Coordinate.Impl;
			wp4: data Coordinate.Impl;
	end MissionWindow.Impl;

	thread WifiDriver
		-- The WifiDriver is the software that enables other SW components to communicate to other systems over WiFi
		features
			gimbal_command: in event data port;
			send_data: out event data port UAV::WIFI_Msg.Impl;
			recv_data: in event data port UAV::WIFI_Msg.Impl;
	end WifiDriver;

	thread implementation WifiDriver.Impl
	end WifiDriver.Impl;

	thread RadioDriver
		-- The RadioDriver is the software that enables other SW components to communicate to other systems over RF
		features
			recv_data: in event data port CASE_RF_Msg.Impl;
			send_data: out event data port CASE_RF_Msg.Impl;
			mission_command: out event data port Command.Impl;
			status: in event data port Coordinate.Impl;
			am_metadata: out event data port CASE_MsgHeader.Impl;
			am_request: in event data port CASE_AttestationRequestMsg.Impl;
			am_response: out event data port CASE_AttestationResponseMsg.Impl;
		properties
			CASE_Properties::COMP_TYPE => COMM_DRIVER;
		annex agree {**
			assume Req001_RadioDriver "The message is intended for this UAV" : recv_data.header.dst = CASE_UAV_ID;
			guarantee Req002_RadioDriver "Only valid messages from the ground station" : VALID_MESSAGE(mission_command);
		**};
	end RadioDriver;

	thread implementation RadioDriver.Impl
		annex agree {**
			
			-- check if this is an incoming radio message
			eq radio_msg : bool = not CASE_Model_Transformations::NULL_MESSAGE(recv_data.header);
				
			-- if incoming transmitted message is authentic, radio driver will create Command message with proper header info
--			eq mission_command_header : CASE_MsgHeader.Impl = 
--				if radio_msg and recv_data.header.src > 0 and recv_data.header.dst = CASE_UAV_ID and recv_data.header.HMAC then
--					recv_data.header
--				else
--					CASE_Model_Transformations::NULL_HEADER;
			eq mission_command_event : bool =
				if event(recv_data) and recv_data.header.src > 0 and recv_data.header.dst = CASE_UAV_ID and recv_data.header.HMAC then
					true
				else
					false;
											
			-- assign header info to transmitted messages
--			assert(mission_command.header = mission_command_header);
			eq mission_command_metadata : CASE_MsgHeader.Impl =
				if mission_command_event then
					recv_data.header
				else
					CASE_Model_Transformations::NULL_HEADER;


			-- a request will trigger a response
			eq am_response_event : bool = event(am_request);
			eq am_response_header : CASE_MsgHeader.Impl = 
				if am_response_event then
					CASE_MsgHeader.Impl {src = am_response.header.dst; dst = CASE_UAV_ID; HMAC = true}
				else
					CASE_Model_Transformations::NULL_HEADER;

			-- assign header info for attestation manager messages
			assert(am_response.header = am_response_header);
			assert(am_metadata = mission_command_metadata);
			
			-- trigger the appropriate event
			assert(event(am_response) = am_response_event);
			assert(event(mission_command) = mission_command_event);
		**};
	end RadioDriver.Impl;

	thread CASE_AttestationManager
		features
			am_mission_command_in: in event data port Command.Impl;
			am_mission_command_out: out event data port Command.Impl;
			am_metadata: in event data port CASE_MsgHeader.Impl;
			am_request: out event data port CASE_AttestationRequestMsg.Impl;
			am_response: in event data port CASE_AttestationResponseMsg.Impl;
		properties
			CASE_Properties::COMP_TYPE => ATTESTATION;
			CASE_Properties::COMP_IMPL => "CakeML";
			CASE_Properties::COMP_SPEC => "Req001_AttestationManager";
			CASE_Properties::CACHE_TIMEOUT => 30;
			CASE_Properties::CACHE_SIZE => 4;
			CASE_Properties::LOG_SIZE => 100;
		annex agree {**
			guarantee Req002_RadioDriver_AttestationManager "Only valid messages from the ground station" : VALID_MESSAGE(am_mission_command_out);
			guarantee Req001_AttestationManager "The Attestation Manager shall only forward trusted messages" : TRUSTED_MESSAGE(am_mission_command_out) and (CASE_Model_Transformations::TRUSTED(am_mission_command_out.header.src) => (am_mission_command_out = am_mission_command_in));
		**};
	end CASE_AttestationManager;

	thread implementation CASE_AttestationManager.Impl
		annex agree {**

			-- Determine if it is a response message
			eq am_response_msg : bool = not CASE_Model_Transformations::NULL_MESSAGE(am_response.header);
			-- Attestation Manager will not process more than one regular message at a time
			fun MSG_CTR (null_msg : bool) : int = if null_msg then 0 else 1;
			property one_incoming_message = (MSG_CTR(CASE_Model_Transformations::NULL_MESSAGE(am_mission_command_in.header)) + MSG_CTR(CASE_Model_Transformations::NULL_MESSAGE(am_response.header))) <= 1;
			assert(one_incoming_message);

			-- source of the transmitted message, if one was sent
			eq msg_src : int = 
				if not CASE_Model_Transformations::NULL_MESSAGE(am_mission_command_in.header) then
					am_mission_command_in.header.src
				else
					CASE_Model_Transformations::NULL_ID;

			-- Helper function to get the header from the attestation manager inport with the specified ID
			fun GET_HEADER(src : int) : CASE_MsgHeader.Impl = 
				if am_mission_command_in.header.src = src then am_mission_command_in.header
				else CASE_Model_Transformations::NULL_HEADER;

			-- Set am_request message
			eq am_request_msg : CASE_Model_Transformations::CASE_AttestationRequestMsg.Impl = 
				if am_response_msg then
					-- it's a response message so no need to send a request
					CASE_Model_Transformations::NULL_AM_REQUEST_MESSAGE
				else if CASE_Model_Transformations::NULL_MESSAGE(GET_HEADER(msg_src)) then
					-- it's an empty message
					CASE_Model_Transformations::NULL_AM_REQUEST_MESSAGE
				else if not CASE_Model_Transformations::IN_CACHE(msg_src) or CASE_Model_Transformations::IS_STALE(msg_src) then
					-- it's a transmitted message from a source not in the cache, so send an am_request
					-- or it's a transmitted message from a source in the cache, but stale, so send a new am_request
					CASE_Model_Transformations::CASE_AttestationRequestMsg.Impl {header = CASE_Model_Transformations::CASE_MsgHeader.Impl {src = CASE_UAV_ID; dst = msg_src; HMAC = true}}
				else
					-- it's a tramsmitted message from a source in the cache
					-- regardless of the attestation status, we won't send a request
					CASE_Model_Transformations::NULL_AM_REQUEST_MESSAGE;

			-- set attestation manager out messages
			eq am_mission_command_out_msg : Command.Impl = 
				if am_response_msg then
					Command.Impl {header = CASE_Model_Transformations::NULL_HEADER; map = am_mission_command_out.map; pattern = am_mission_command_out.pattern}
				else if CASE_Model_Transformations::NULL_MESSAGE(am_mission_command_in.header) then
					am_mission_command_in
				else if not CASE_Model_Transformations::IN_CACHE(msg_src) or CASE_Model_Transformations::IS_STALE(msg_src) then
					Command.Impl {header = CASE_Model_Transformations::NULL_HEADER; map = am_mission_command_out.map; pattern = am_mission_command_out.pattern}
				else if CASE_Model_Transformations::PASS_ATTESTATION(msg_src) then
					am_mission_command_in
				else
					Command.Impl {header = CASE_Model_Transformations::NULL_HEADER; map = am_mission_command_out.map; pattern = am_mission_command_out.pattern};

			-- Update cache
			const AM_CACHE_SIZE : int = 4;
			eq was_response_requested : bool = am_response_msg and CASE_Model_Transformations::GET_STATUS(am_response.header.src) = CASE_Model_Transformations::AM_REQUESTING;
			eq am_status : int = if am_response_msg and am_response.status then CASE_Model_Transformations::AM_PASS else CASE_Model_Transformations::AM_FAIL;
			eq src_added : bool = 
				if was_response_requested then
					CASE_Model_Transformations::ADD_RECORD(am_response.header.src, am_status, 0, AM_CACHE_SIZE)
				else if not (am_request_msg = CASE_Model_Transformations::NULL_AM_REQUEST_MESSAGE) then
					CASE_Model_Transformations::ADD_RECORD(msg_src, CASE_Model_Transformations::AM_REQUESTING, 0, AM_CACHE_SIZE)
				else
					false;

			-- assert outputs
			assert(am_request = am_request_msg);
			assert(was_response_requested => src_added);
			assert(am_mission_command_out = am_mission_command_out_msg);
		**};
	end CASE_AttestationManager.Impl;

	thread FlightPlanner
		-- The FlightPlanner is an abstraction for UxAS.
		-- It accepts a command message containing a map and flight pattern, and generates a mission.
		-- The FlightPlanner also has access to a No-Fly zone database, which it uses to generate the mission 
		-- to avoid specified no-fly zones
		features
			flight_plan: out data port Mission.Impl;
			recv_map: in event data port Command.Impl;
			request_nofly_zones: out event data port Map.Impl;
			nofly_zones: in event data port MapArray.Impl;
			position_status: in event data port Coordinate.Impl;
		annex agree {**
			assume Req004_FP "The FlightPlanner shall receive a well-formed command from the GroundStation" : FALSE;
			assume Req003_FlightPlanner "The FlightPlanner shall only accept messages from a trusted GroundStation" : TRUSTED_MESSAGE(recv_map);
			assume Req001_FlightPlanner "The Flight Planner shall receive a valid message from the Ground Station" : VALID_MESSAGE(recv_map);
			guarantee Req002_FlightPlanner "The Flight Planner shall generate a valid mission" : good_mission(flight_plan);
		**};

	end FlightPlanner;

	thread implementation FlightPlanner.Impl
	end FlightPlanner.Impl;

	thread NoFlyZoneDatabase
		-- The NoFlyZoneDatabase is a collection of polygons that represent areas on a map which the UAV should avoid.
		-- The database is populated at build-time and stored in memory.
		-- When provided a map of a region, it will return all no-fly areas within that region.
		features
			map: in event data port Map.Impl;
			zones: out event data port MapArray.Impl;
	end NoFlyZoneDatabase;

	thread implementation NoFlyZoneDatabase.Impl
	end NoFlyZoneDatabase.Impl;

	thread WaypointManager
		-- The WaypointManager divides a mission into a small window of waypoints suitable for the FlightController.
		-- Because the FlightController can only process a small number of waypoints at a time, the WaypointManager
		-- creates these mission windows in response to the current position of the UAV, provided by the FlightController GPS.
		features
			flight_plan: in data port Mission.Impl;
			mission_window: out event data port MissionWindow.Impl;
			position_status: in event data port Coordinate.Impl;
		annex agree {**
			assume Req001_WaypointManager "The Waypoint Manager shall receive a well-formed mission" : good_mission(flight_plan);
			guarantee Req002_WaypointManager "The Waypoint Manager shall output a well-formed mission window" : good_mission_window(mission_window);**};
	end WaypointManager;

	thread implementation WaypointManager.Impl
	end WaypointManager.Impl;

	thread CameraManager
		-- The CameraManager determines the gimbal settings for the onboard camera based on the current position of the UAV and the mission.
		-- The CameraManager then sends out gimbal commands to the camera over the wifi connection
		features
			flight_plan: in data port Mission.Impl;
			position_status: in event data port Coordinate.Impl;
			gimbal_command: out event data port;
	end CameraManager;

	thread implementation CameraManager.Impl
	end CameraManager.Impl;

	thread UARTDriver
		-- The UARTDriver is the software that enables other SW components to communicate to other systems over the serial connection
		features
			status: out event data port Coordinate.Impl;
			mission_window: in event data port MissionWindow.Impl;
			recv_data: in event data port UAV::UART_Msg.Impl;
			send_data: out event data port UAV::UART_Msg.Impl;
		annex agree {**
			assume Req001_UARTDriver "Well-formed mission window" : good_mission_window(mission_window);
			guarantee Req002_UARTDriver "A CRC shall be appended to the message to determine message correctness" : send_data.crc = true;**};
	end UARTDriver;

	thread implementation UARTDriver.Impl
	end UARTDriver.Impl;

	process SW
		-- The Mission Computer Software process runs all threads
		features
			radio_recv: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			radio_send: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			uart_recv: in event data port UAV::UART_Msg.Impl;
			uart_send: out event data port UAV::UART_Msg.Impl;
			wifi_recv: in event data port UAV::WIFI_Msg.Impl;
			wifi_send: out event data port UAV::WIFI_Msg.Impl;
		annex agree {**
			assume Req001_SW "The Mission Computer shall only accept commands intended for this UAV" : radio_recv.header.dst = CASE_UAV_ID;
			guarantee Req002_SW "The Mission Computer shall output a valid mission window to the Flight Controller" : uart_send.crc = True;**};
	end SW;

	process implementation SW.Impl1
		subcomponents
			RADIO: thread RadioDriver.Impl;
			AM: thread CASE_AttestationManager.Impl;
			FPLN: thread FlightPlanner.Impl;
			WPM: thread WaypointManager.Impl;
			CM: thread CameraManager.Impl;
			UART: thread UARTDriver.Impl;
			WIFI: thread WifiDriver.Impl;
			NFDB: thread NoFlyZoneDatabase.Impl;
		connections
			c1: port radio_recv -> RADIO.recv_data;
			c2: port RADIO.send_data -> radio_send;
			c3: port RADIO.mission_command -> AM.am_mission_command_in;
			c4: port AM.am_mission_command_out -> FPLN.recv_map;
			c19: port AM.am_request -> RADIO.am_request;
			c20: port RADIO.am_response -> AM.am_response;
			c5: port FPLN.flight_plan -> WPM.flight_plan;
			c6: port FPLN.request_nofly_zones -> NFDB.map;
			c7: port NFDB.zones -> FPLN.nofly_zones;
			c8: port WPM.mission_window -> UART.mission_window;
			c9: port UART.status -> WPM.position_status;
			c10: port UART.status -> FPLN.position_status;
			c11: port UART.status -> RADIO.status;
			c12: port UART.send_data -> uart_send;
			c13: port uart_recv -> UART.recv_data;
			c14: port FPLN.flight_plan -> CM.flight_plan;
			c15: port UART.status -> CM.position_status;
			c16: port CM.gimbal_command -> WIFI.gimbal_command;
			c17: port WIFI.send_data -> wifi_send;
			c18: port wifi_recv -> WIFI.recv_data;
	end SW.Impl1;

	process implementation SW.Impl
		subcomponents
			RADIO: thread RadioDriver.Impl;
			FPLN: thread FlightPlanner.Impl;
			WPM: thread WaypointManager.Impl;
			CM: thread CameraManager.Impl;
			UART: thread UARTDriver.Impl;
			WIFI: thread WifiDriver.Impl;
			NFDB: thread NoFlyZoneDatabase.Impl;
		connections
			c1: port radio_recv -> RADIO.recv_data;
			c2: port RADIO.send_data -> radio_send;
			c3: port RADIO.mission_command -> FPLN.recv_map;
			c5: port FPLN.flight_plan -> WPM.flight_plan;
			c6: port FPLN.request_nofly_zones -> NFDB.map;
			c7: port NFDB.zones -> FPLN.nofly_zones;
			c8: port WPM.mission_window -> UART.mission_window;
			c9: port UART.status -> WPM.position_status;
			c10: port UART.status -> FPLN.position_status;
			c11: port UART.status -> RADIO.status;
			c12: port UART.send_data -> uart_send;
			c13: port uart_recv -> UART.recv_data;
			c14: port FPLN.flight_plan -> CM.flight_plan;
			c15: port UART.status -> CM.position_status;
			c16: port CM.gimbal_command -> WIFI.gimbal_command;
			c17: port WIFI.send_data -> wifi_send;
			c18: port wifi_recv -> WIFI.recv_data;
	end SW.Impl;

	annex agree {**
			
		-- ID of this UAV
		const CASE_UAV_ID : int = 42;
		
		const NULL_ID : int = 0;
		const NULL_HEADER : CASE_Model_Transformations::CASE_MsgHeader.Impl = CASE_Model_Transformations::CASE_MsgHeader.Impl {src = NULL_ID; dst = NULL_ID; HMAC = false};
		fun NULL_MESSAGE(header : CASE_Model_Transformations::CASE_MsgHeader.Impl) : bool = (header = NULL_HEADER);
		
		-- Returns whether the specified message is valid (eg, has valid source, destination, and is authenticated)
		fun VALID_MESSAGE(msg : Command.Impl) : bool = CASE_Model_Transformations::NULL_MESSAGE(msg.header) or (msg.header.src > 0 and msg.header.dst = CASE_UAV_ID and msg.header.HMAC = true);
		-- Returns whether the specified message is trusted (eg, has passed remote attestation)
		fun TRUSTED_MESSAGE(msg : Command.Impl) : bool = CASE_Model_Transformations::NULL_MESSAGE(msg.header) or CASE_Model_Transformations::TRUSTED(msg.header.src);
		-- Returns whether the message with the specifed header is well-formed
		fun WELL_FORMED_MESSAGE(msg : Command.Impl) : bool = CASE_Model_Transformations::NULL_MESSAGE(msg.header) or good_command(msg);
		
			
		-- These functions check the well-formedness of message structures
		fun good_coordinate(coord : Coordinate.Impl) : bool =	coord.latitude >= -90 and 
																	coord.latitude <= 90 and 
																	coord.longitude >= -180 and 
																	coord.longitude <= 180 and 
																	coord.altitude >= 0 and 
																	coord.altitude <= 15000;
																	
		fun good_map(map : Map.Impl) : bool =	good_coordinate(map.wp1) and 
													good_coordinate(map.wp2) and 
													good_coordinate(map.wp3) and 
													good_coordinate(map.wp4);
													
		fun good_pattern(pattern : FlightPattern.Impl) : bool =	(pattern = enum(FlightPattern, ZigZag)) or 
																(pattern = enum(FlightPattern, StraightLine)) or 
																(pattern = enum(FlightPattern, Perimeter));
		
		fun good_command(cmd : Command.Impl) : bool = good_map(cmd.map) and good_pattern(cmd.pattern);
																
		fun good_mission(mission : Mission.Impl) : bool =	good_coordinate(mission.wp1) and 
																good_coordinate(mission.wp2) and 
																good_coordinate(mission.wp3) and 
																good_coordinate(mission.wp4) and 
																good_coordinate(mission.wp5) and 
																good_coordinate(mission.wp6) and 
																good_coordinate(mission.wp7) and 
																good_coordinate(mission.wp8) and 
																good_coordinate(mission.wp9) and 
																good_coordinate(mission.wp10);
																
		fun good_mission_window(win : MissionWindow.Impl) : bool =	good_coordinate(win.wp1) and 
																		good_coordinate(win.wp2) and 
																		good_coordinate(win.wp3) and 
																		good_coordinate(win.wp4);**};
end SW;
