<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>AGREE User Guide</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">AGREE User Guide</h1>
</header>
<h2 id="sec:expressions">Expressions</h2>
<p>A simplified description of the set of expressions for AGREE is presented below.</p>
<pre><code>RelateOp::=
   &#39;&lt;&#39; | &#39;&lt;=&#39; | &#39;&gt;&#39; | &#39;&gt;=&#39; | &#39;=&#39; | &#39;&lt;&gt;&#39; | &#39;!=&#39;;

QID::= ID &#39;::&#39; ID ;

NestedDotID ::= ID (&#39;.&#39; NestedDotID)? ;

Literal :: = Boolean_literal | Integer_literal | Real_literal ;

Expr ::= Literal
    | ID
    | QID
    | NestedDotId
    | ID &#39;(&#39; Expr_List &#39;)&#39;
    | &#39;pre&#39; &#39;(&#39; Expr &#39;)&#39;
    | &#39;prev&#39; &#39;(&#39; Expr &#39;,&#39; Expr &#39;)&#39;
    | &#39;event&#39; &#39;(&#39; NestedDotID &#39;)&#39;
    | &#39;floor&#39; &#39;(&#39; Expr &#39;)&#39;
    | &#39;real&#39; &#39;(&#39; Expr &#39;)&#39;
    | &#39;Get_Property&#39; &#39;(&#39; Expr &#39;,&#39; AADL_Property &#39;)&#39;
    | &#39;this&#39; (&#39;.&#39; NestedDotId)?
    | &#39;(&#39; Expr &#39;)&#39;
    | RecordUpdateExpr
    | (&#39;-&#39; | &#39;not&#39;) Expr
    | Expr (&#39;+&#39; | &#39;-&#39; | &#39;\*&#39; | &#39;/&#39; | &#39;div&#39;| &#39;mod&#39;) Expr
    | Expr RelateOp Expr
    | Expr (&#39;and&#39; | &#39;or&#39; ) Expr
    | Expr (&#39;-&gt;&#39; | &#39;=&gt;&#39; | &#39;&lt;=&gt;&#39; ) Expr
    | &#39;if&#39; Expr &#39;then&#39; Expr &#39;else&#39; Expr ;

Expr_List ::= Expr &#39;,&#39; Expr_List | Expr ;</code></pre>
<p>The order of precedence (from lowest to highest) is as follows:</p>
<blockquote>
<p>-&gt;<br />
=&gt;<br />
&lt;=&gt;<br />
or<br />
and<br />
&lt; | &lt;= | &gt; | &gt;= | = | &lt;&gt; |!=<br />
+ | -<br />
* | / | div | mod<br />
unary minus | not<br />
if then else<br />
prev | next | Get_Property<br />
ID | QID | NestedDotID | Literal | pre | this | ()</p>
</blockquote>
<p>Therefore, <code>x + if y then a else b * prev(z.f - 1, 0)</code> would be parsed as follows:</p>
<pre><code>x + (if y then a else (b * (prev((z.f) – 1, 0))))</code></pre>
<p>The meaning of the arithmetic, relational, and Boolean operators is straightforward. If/then/else is an <em>expression,</em> not a <em>statement</em>; it behaves like the <code>?</code> operator in Java. So, users can write:</p>
<pre><code>x = if (b) then y else z ;</code></pre>
<p>Expressions reason about the current state or past states of variables and can reference variables defined in equation statements or other identifiers in the AADL model. In the rest of this section, we describe different types of expressions in the order they are listed as alternatives to the grammar rule for Expr.</p>
<h3 id="sec:id-expressions">ID Expressions</h3>
<p>ID expressions are used to reference different AADL objects as well as AGREE variables and constants. Constants or variables must be defined locally (in the AGREE annex block or the enclosing definition), and they can be referred to by a single identifier ID.</p>
<h3 id="sec:enumerator_expressions">Enumerator Expressions</h3>
<p>Enumerator expressions are ID expressions referencing an enumerator literal. However, the syntax differs between enumerations defined in AADL and enumerations defined in AGREE. For AGREE enumerations, enumerator expressions are merely ID expressions naming enumerator values. Using the types defined in <a href="03.04-Types.html#sec:enumeration_types">Enumeration Types</a> the use of <code>spade</code>, <code>heart</code>, <code>club</code>, and <code>diamond</code> as identifiers are all valid AGREE enumeration expressions.</p>
<p>For AADL enumerations a special syntax is required. The <code>enum</code> keyword followed by the enumeration type and enumerator name is used as follows:</p>
<pre><code>enum(Package::Color, Red)</code></pre>
<h3 id="sec:nesteddotid-field-expressions">NestedDotID (Field) Expressions</h3>
<p>A NestedDotID expression can have dots in between ID expressions, e.g., <code>food.bar.biz</code>. It can be used to refer to record types or variables of a subcomponent. For example, one could use the NestedDotID expression foo.bar to reference the input, output, or equation variable <code>bar</code> of subcomponent <code>foo</code> within the implementation of some AADL component. A NestedDotID expression can also be used for inputs and outputs that are of record type: if <code>x</code> is a record type containing field <code>y</code>, then the notation <code>x.y</code> is used.</p>
<h3 id="sec:node-call-expressions">Node Call Expressions</h3>
<p>A node call expression is an ID of a defined node followed by parenthesis. If the node is defined in an AADL Package, then the ID should be the AADL Package name followed by a dot (.) and then the node name.</p>
<h3 id="sec:linearization-call-expressions">Linearization Call Expressions</h3>
<p>A Linearization Call Expression is an ID of a defined linearization expression followed by parenthesis. If the linearization expression is defined in an AADL Package, then the ID should be the AADL Package name followed by a dot (.) and then the ID for the expression. For the example linearization expression provided in <a href="03.06-Statements.html#sec:linearization_definitions">Linearization Definitions</a>, its ID &quot;sq&quot; can be used in other expressions like a non-recursive, pure function call. The following lemma statement provides one such example.</p>
<pre><code>eq y : real;

lemma &quot;sq() range positive&quot; : sq(y) &lt;= -0.10;</code></pre>
<h3 id="sec:stream-previous-value-and-arrow-expressions">Stream (Previous Value and Arrow) Expressions</h3>
<p><strong>Arrow Expression</strong>. The arrow expression evaluates to the value of the expression of the left hand side of the arrow on the initial step. Otherwise it evaluates to the value of the expression on the right hand side of the arrow. The arrow expression is used with the pre expression to reason about past values of variables. For example, we can define a variable in an AGREE contract that starts at zero and increments by one each step in time using an equation statement:</p>
<pre><code>eq count: int = 0 -&gt; pre(count) + 1;</code></pre>
<p><strong>Previous Value Expression</strong>. A previous value expression evaluates to the value of its argument on the previous time frame. It should that it be guarded by an arrow expressions as its value is undefined on the initial step.</p>
<p>The previous value expression defines an initialized stream. So, if we write:</p>
<pre><code>eq x : int = prev(y + 1, 0);</code></pre>
<p>In the initial instant, <code>x</code> is equal to 0. In all subsequent instants, <code>x</code> is equal to the previous value of <code>y + 1</code>. If we examine the evolution of <code>x</code> and <code>y</code> over a time window of ten steps, it is relatively straightforward to see.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Time Instant </strong></td>
<td style="text-align: left;"><strong>1</strong></td>
<td style="text-align: left;"><strong>2</strong></td>
<td style="text-align: left;"><strong>3</strong></td>
<td style="text-align: left;"><strong>4</strong></td>
<td style="text-align: left;"><strong>5</strong></td>
<td style="text-align: left;"><strong>6</strong></td>
<td style="text-align: left;"><strong>7</strong></td>
<td style="text-align: left;"><strong>8</strong></td>
<td style="text-align: left;"><strong>9</strong></td>
<td style="text-align: left;"><strong>10</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>y</strong></td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">12</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">3</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>y+1</strong></td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">13</td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">4</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>x</strong></td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">13</td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">2</td>
</tr>
</tbody>
</table>
<p>The arrow (<code>-&gt;</code>) operator is the stream initialization operator. Given an expression <code>x -&gt; y</code>, in the initial instant in time, the value is equal to <code>x</code>. In all subsequent instants, it is equal to <code>y</code>. So, suppose we have:</p>
<pre><code>eq x : bool = (false -&gt; a);</code></pre>
<p>Then, in the first instant in time, <code>x</code> will be assigned &quot;false&quot; and in every other instant in time, it will be assigned &quot;a&quot;.</p>
<p><strong>Note: A common mistake is to mis-type <code>-&gt;</code> for <code>=&gt;</code> (and vice-versa). This will often cause your model to return incorrect results. Please check for this error.</strong></p>
<p>The <code>=&gt;</code> operator is the implication operator: if you write:</p>
<pre><code>a =&gt; b</code></pre>
<p>then <code>a</code> and <code>b</code> are expected to be Boolean expressions and the meaning of the operator is equivalent to <code>(not a) or b</code>. So, writing:</p>
<pre><code>x = (false =&gt; a)</code></pre>
<p>Will assign <code>x</code> to true in all time instants.</p>
<p>The pre expression is an <em>uninitialized</em> pre expression. Its value is <em>undefined</em> in the initial instant. This expression is expected to be used in combination with the arrow expression; this can yield expressions that are, on occasional, more terse than using the prev expression. However, the following equivalence always holds for arbitrary expressions <code>x</code> and <code>y</code>:</p>
<pre><code>prev(x, y) &lt;=&gt; (y -&gt; pre(x))</code></pre>
<p>For novice users, we recommend using the initialized prev expression as it is less error prone than the <code>-&gt;</code> pre combination.</p>
<h3 id="sec:event-expressions">Event Expressions</h3>
<p>An event expression is a special predicate that is used to reason about AADL event data ports. For an input event data port, its semantics are such that it evaluates to true if a value is <em>present</em> on the event port and false otherwise. For an output event data port, its semantics are such that it evaluates true if data is being sent on the port and false otherwise.</p>
<h3 id="sec:floor-and-real-expressions">Floor and Real Expressions</h3>
<p>A floor expression takes an expression of type <em>real</em> as an argument and returns an <em>int</em> equal to the floor of the number.</p>
<p>A real expression takes an expression of type <em>int</em> as argument and returns a <em>real</em> equal to its value.</p>
<h3 id="sec:get-property-expressions">Get Property Expressions</h3>
<p>A get property expression allows a user to reason about values of AADL properties in the model. The first argument is the relative path to an AADL component in the instance model or 'this' if the property exists in the component in which get property statement lives. The second argument is the name of the AADL property.</p>
<h3 id="sec:unary-minus-and-not-expressions">Unary Minus and Not Expressions</h3>
<p>An Unary Minus expression is used to negate integer or real valued expressions.</p>
<p>A Not Expression is used to negate boolean valued expressions.</p>
<h3 id="sec:record_expressions">Record Expressions</h3>
<p>In AGREE a record type is either an AADL Data Type Implementation containing Data subcomponents or may be defined directly in the AGREE annex as follows:</p>
<pre><code>type foo = struct {a : bool, b : int};

eq bar : foo;</code></pre>
<p>A record expression constructs a value that may be assigned to a variable of record type.</p>
<pre><code>eq bar2 : foo = foo { a = true; b = 6 };</code></pre>
<p>Record Update Expression are assignments to all or a specific field of a record type variable. For example, <code>bar2 {a := false}</code> is a valid Record Update Expression, given definition for type <code>foo</code> and variable <code>bar2</code> as above.</p>
<p>The record update expression expects an expression of record type on the left hand side of the curly braces. It returns the same record as the left hand side expression except with its member IDs set to the value of the expression on the right hand side of the <code>:=</code>;</p>
<h3 id="sec:arithmetic-operations">Arithmetic Operations</h3>
<p>Arithmetic operations must be performed on expressions of the same type. They follow the standard order of precedence. Note that AGREE will give a warning if you write an expression that is not linear. Some theorem provers do not reason about non-linear expressions. Non-linear integer arithmetic is undecidable and most theorem provers do not use a decidable decision procedure for non-linear real arithmetic. So it is recommended that you only use linear expressions.</p>
<h3 id="sec:relation-expressions">Relation Expressions</h3>
<p>Relation expressions can be performed on integers or reals, but not a combination of both. Equality can be used on Booleans as well.</p>
<h3 id="sec:boolean-expressions">Boolean Expressions</h3>
<p>Boolean expressions have the standard associative properties and order of precedence.</p>
</body>
</html>
