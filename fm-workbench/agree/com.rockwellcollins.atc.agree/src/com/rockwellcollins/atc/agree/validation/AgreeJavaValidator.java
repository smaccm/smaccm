/*
 * generated by Xtext
 */
package com.rockwellcollins.atc.agree.validation;

import static com.rockwellcollins.atc.agree.AgreeTypeSystem.typeToString;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.osate.aadl2.Aadl2Package;
import org.osate.aadl2.AadlPackage;
import org.osate.aadl2.AnnexLibrary;
import org.osate.aadl2.AnnexSubclause;
import org.osate.aadl2.Classifier;
import org.osate.aadl2.ComponentClassifier;
import org.osate.aadl2.ComponentImplementation;
import org.osate.aadl2.ComponentType;
import org.osate.aadl2.Connection;
import org.osate.aadl2.DataImplementation;
import org.osate.aadl2.DataPort;
import org.osate.aadl2.DataSubcomponent;
import org.osate.aadl2.DataType;
import org.osate.aadl2.DirectionType;
import org.osate.aadl2.EventDataPort;
import org.osate.aadl2.EventPort;
import org.osate.aadl2.Feature;
import org.osate.aadl2.FeatureGroup;
import org.osate.aadl2.FeatureGroupType;
import org.osate.aadl2.ModelUnit;
import org.osate.aadl2.NamedElement;
import org.osate.aadl2.Port;
import org.osate.aadl2.Property;
import org.osate.aadl2.PropertyConstant;
import org.osate.aadl2.Subcomponent;
import org.osate.aadl2.impl.SubcomponentImpl;
import org.osate.aadl2.modelsupport.util.AadlUtil;
import org.osate.annexsupport.AnnexUtil;

import com.google.common.collect.HashMultimap;
import com.rockwellcollins.atc.agree.AgreeAADLEnumerationUtils;
import com.rockwellcollins.atc.agree.AgreeTypeSystem;
import com.rockwellcollins.atc.agree.AgreeTypeSystem.ArrayDef;
import com.rockwellcollins.atc.agree.agree.Abstraction;
import com.rockwellcollins.atc.agree.agree.AgreeContract;
import com.rockwellcollins.atc.agree.agree.AgreeContractLibrary;
import com.rockwellcollins.atc.agree.agree.AgreeContractSubclause;
import com.rockwellcollins.atc.agree.agree.AgreePackage;
import com.rockwellcollins.atc.agree.agree.AgreeSubclause;
import com.rockwellcollins.atc.agree.agree.Arg;
import com.rockwellcollins.atc.agree.agree.ArrayLiteralExpr;
import com.rockwellcollins.atc.agree.agree.ArraySubExpr;
import com.rockwellcollins.atc.agree.agree.ArrayType;
import com.rockwellcollins.atc.agree.agree.ArrayUpdateExpr;
import com.rockwellcollins.atc.agree.agree.AssertStatement;
import com.rockwellcollins.atc.agree.agree.AssignStatement;
import com.rockwellcollins.atc.agree.agree.AssumeStatement;
import com.rockwellcollins.atc.agree.agree.AsynchStatement;
import com.rockwellcollins.atc.agree.agree.BinaryExpr;
import com.rockwellcollins.atc.agree.agree.BoolLitExpr;
import com.rockwellcollins.atc.agree.agree.CalenStatement;
import com.rockwellcollins.atc.agree.agree.CallExpr;
import com.rockwellcollins.atc.agree.agree.ComponentRef;
import com.rockwellcollins.atc.agree.agree.ConnectionStatement;
import com.rockwellcollins.atc.agree.agree.ConstStatement;
import com.rockwellcollins.atc.agree.agree.DoubleDotRef;
import com.rockwellcollins.atc.agree.agree.EnumLitExpr;
import com.rockwellcollins.atc.agree.agree.EnumStatement;
import com.rockwellcollins.atc.agree.agree.EqStatement;
import com.rockwellcollins.atc.agree.agree.EventExpr;
import com.rockwellcollins.atc.agree.agree.Expr;
import com.rockwellcollins.atc.agree.agree.FloorCast;
import com.rockwellcollins.atc.agree.agree.FnDef;
import com.rockwellcollins.atc.agree.agree.GetPropertyExpr;
import com.rockwellcollins.atc.agree.agree.GuaranteeStatement;
import com.rockwellcollins.atc.agree.agree.IfThenElseExpr;
import com.rockwellcollins.atc.agree.agree.InitialStatement;
import com.rockwellcollins.atc.agree.agree.InputStatement;
import com.rockwellcollins.atc.agree.agree.IntLitExpr;
import com.rockwellcollins.atc.agree.agree.LatchedExpr;
import com.rockwellcollins.atc.agree.agree.LatchedStatement;
import com.rockwellcollins.atc.agree.agree.LemmaStatement;
import com.rockwellcollins.atc.agree.agree.LibraryFnDef;
import com.rockwellcollins.atc.agree.agree.LiftStatement;
import com.rockwellcollins.atc.agree.agree.LinearizationDef;
import com.rockwellcollins.atc.agree.agree.LinearizationInterval;
import com.rockwellcollins.atc.agree.agree.MNSynchStatement;
import com.rockwellcollins.atc.agree.agree.NamedElmExpr;
import com.rockwellcollins.atc.agree.agree.NamedID;
import com.rockwellcollins.atc.agree.agree.NamedSpecStatement;
import com.rockwellcollins.atc.agree.agree.NodeBodyExpr;
import com.rockwellcollins.atc.agree.agree.NodeDef;
import com.rockwellcollins.atc.agree.agree.NodeEq;
import com.rockwellcollins.atc.agree.agree.NodeLemma;
import com.rockwellcollins.atc.agree.agree.NodeStmt;
import com.rockwellcollins.atc.agree.agree.OrderStatement;
import com.rockwellcollins.atc.agree.agree.PeriodicStatement;
import com.rockwellcollins.atc.agree.agree.PreExpr;
import com.rockwellcollins.atc.agree.agree.PrevExpr;
import com.rockwellcollins.atc.agree.agree.PrimType;
import com.rockwellcollins.atc.agree.agree.ProjectionExpr;
import com.rockwellcollins.atc.agree.agree.PropertyStatement;
import com.rockwellcollins.atc.agree.agree.RealCast;
import com.rockwellcollins.atc.agree.agree.RealLitExpr;
import com.rockwellcollins.atc.agree.agree.RecordDef;
import com.rockwellcollins.atc.agree.agree.RecordLitExpr;
import com.rockwellcollins.atc.agree.agree.RecordUpdateExpr;
import com.rockwellcollins.atc.agree.agree.SpecStatement;
import com.rockwellcollins.atc.agree.agree.SporadicStatement;
import com.rockwellcollins.atc.agree.agree.SynchStatement;
import com.rockwellcollins.atc.agree.agree.ThisRef;
import com.rockwellcollins.atc.agree.agree.TimeFallExpr;
import com.rockwellcollins.atc.agree.agree.TimeInterval;
import com.rockwellcollins.atc.agree.agree.TimeOfExpr;
import com.rockwellcollins.atc.agree.agree.TimeRiseExpr;
import com.rockwellcollins.atc.agree.agree.Type;
import com.rockwellcollins.atc.agree.agree.UnaryExpr;
import com.rockwellcollins.atc.agree.agree.WhenHoldsStatement;
import com.rockwellcollins.atc.agree.agree.WhenOccursStatment;
import com.rockwellcollins.atc.agree.agree.WheneverBecomesTrueStatement;
import com.rockwellcollins.atc.agree.agree.WheneverHoldsStatement;
import com.rockwellcollins.atc.agree.agree.WheneverImpliesStatement;
import com.rockwellcollins.atc.agree.agree.WheneverOccursStatement;
import com.rockwellcollins.atc.agree.visitors.ExprCycleVisitor;

/**
 * Custom validation rules.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class AgreeJavaValidator extends AbstractAgreeJavaValidator {
	private final Set<Abstraction> checkedRecCalls = new HashSet<>();
	private final Map<String, Map<String, NamedID>> enumSets = new HashMap<>();

	@Override
	protected boolean isResponsible(Map<Object, Object> context, EObject eObject) {
		return (eObject.eClass().getEPackage() == AgreePackage.eINSTANCE) || eObject instanceof AadlPackage;
	}

	@Check(CheckType.FAST)
	public void checkEnumStatement(EnumStatement statement) {
		String contextProject = statement.eResource().getURI().segment(1);
		Map<String, NamedID> enumMap;
		if (!enumSets.containsKey(contextProject)) {
			enumMap = new HashMap<>();
			enumSets.put(contextProject, enumMap);
		} else {
			enumMap = enumSets.get(contextProject);
		}

		for (NamedID id : statement.getEnums()) {
			NamedID otherEnum = enumMap.get(id.getName());
			if (otherEnum == null) {
				enumMap.put(id.getName(), id);
			} else if (otherEnum != id) {
				if (otherEnum.eResource() != null && otherEnum.eResource().equals(id.eResource())) {

					String message = "Multiple uses of the same enum value '" + id.getName() + "' in '"
							+ getEnumValueDefLocation(otherEnum) + "' and '" + getEnumValueDefLocation(id) + "'";
					error(otherEnum, message);
					error(id, message);
				} else {
					enumMap.put(id.getName(), id);
				}
			}
		}
		EObject container = statement.eContainer();
		while (!(container instanceof AadlPackage) && !(container instanceof ComponentClassifier)) {
			container = container.eContainer();
		}
		if (!(container instanceof AadlPackage)) {
			error(statement, "Enumerations can be defined only in AADL packages");
		}

	}

	private String getEnumValueDefLocation(NamedID id) {
		EObject container = id.eContainer();
		EnumStatement enumStatement = (EnumStatement) container;
		String enumName = enumStatement.getName();
		while (!(container instanceof AadlPackage) && !(container instanceof ComponentClassifier)) {
			container = container.eContainer();
		}
		return ((NamedElement) container).getQualifiedName() + "::" + enumName;
	}

	@Check(CheckType.FAST)
	public void checkConnectionStatement(ConnectionStatement conn) {
		Classifier container = conn.getContainingClassifier();
		if (container instanceof ComponentImplementation) {
			NamedElement aadlConn = conn.getConn();
			if (aadlConn == null) {
				return;
			}
			if (!(aadlConn instanceof Connection)) {
				error(conn, "The connection label in the connection statement is not a connection");
				return;
			}

		} else {
			error(conn, "Connection statements are allowed only in component implementations.");
		}
	}

	@Check(CheckType.FAST)
	public void checkOrderStatement(OrderStatement order) {
		Classifier container = order.getContainingClassifier();
		if (container instanceof ComponentImplementation) {
			ComponentImplementation compImpl = (ComponentImplementation) container;

			for (int index = 0; index < order.getComps().size(); ++index) {
				NamedElement comp = order.getComps().get(index);
				if (!(comp instanceof Subcomponent)
						|| !((Subcomponent) comp).getContainingComponentImpl().equals(container)) {
					error("Element '" + comp.getName() + "' is not a subcomponent of '" + container.getName() + "'",
							order, AgreePackage.Literals.ORDER_STATEMENT__COMPS, index);
				}
			}

			List<NamedElement> notPresent = new ArrayList<>();
			for (Subcomponent subcomp : compImpl.getAllSubcomponents()) {
				boolean found = false;
				for (NamedElement el : order.getComps()) {
					if (el.equals(subcomp)) {
						found = true;
						break;
					}
				}
				if (!found) {
					notPresent.add(subcomp);
				}
			}

			if (notPresent.size() != 0) {
				String delim = "";
				StringBuilder errorStr = new StringBuilder(
						"The following subcomponents are not present in the ordering: ");
				for (NamedElement subcomp : notPresent) {
					errorStr.append(delim);
					errorStr.append(subcomp.getName());
					delim = ", ";
				}
				error(order, errorStr.toString());
			}

		} else {
			error(order, "Ordering statements can appear only in component implementations");
		}

	}

	private static List<Feature> flattenFeatureGroups(List<? extends Feature> complexFeatures) {
		List<Feature> result = new ArrayList<>();
		for (Feature feature : complexFeatures) {
			if (feature instanceof FeatureGroup) {
				FeatureGroup featureGroup = (FeatureGroup) feature;
				FeatureGroupType featType = featureGroup.getFeatureGroupType();
				result.addAll(flattenFeatureGroups(featType.getOwnedFeatureGroups()));
				result.addAll(flattenFeatureGroups(featType.getOwnedDataPorts()));
				result.addAll(flattenFeatureGroups(featType.getOwnedEventDataPorts()));
				result.addAll(flattenFeatureGroups(featType.getOwnedEventPorts()));
			} else {
				result.add(feature);
			}
		}
		return result;
	}

	@Check(CheckType.FAST)
	public void checkAssign(AssignStatement assign) {

		if (!(assign.getId() instanceof NamedElement)) {
			error(assign.getId(),
					"The Id on the left hand side of an assignment statement " + "must not contain a \".\"");
			return;
		}
		NamedElement namedEl = assign.getId();
		Expr expr = assign.getExpr();

		if (namedEl == null || expr == null) {
			return;
		}

		ComponentImplementation compImpl = EcoreUtil2.getContainerOfType(assign, ComponentImplementation.class);

		if (compImpl == null) {
			error(assign, "Assignment statements are allowed only in component implementations");
			return;
		}



		if (namedEl.eContainer() instanceof InputStatement) {
			error(assign, "Assignment to agree_input variables is illegal.");
			return;
		}

		if (compImpl != null) {
			List<EObject> assignableElements = new ArrayList<>();
			List<AgreeContract> implContracts = EcoreUtil2.getAllContentsOfType(compImpl, AgreeContract.class);
			for (AgreeContract ac : implContracts) {
				assignableElements.addAll(EcoreUtil2.getAllContentsOfType(ac, EqStatement.class).stream()
						.map(eq -> eq.getLhs()).flatMap(List::stream).collect(Collectors.toList()));
			}

			ComponentType compType = compImpl.getType();
			if (compType != null) {
				List<AgreeContract> typeContracts = EcoreUtil2.getAllContentsOfType(compType, AgreeContract.class);
				for (AgreeContract ac : typeContracts) {
					assignableElements.addAll(EcoreUtil2.getAllContentsOfType(ac, EqStatement.class).stream()
							.map(eq -> eq.getLhs()).flatMap(List::stream).collect(Collectors.toList()));
				}
			}
			assignableElements.addAll(compImpl.getAllFeatures().stream()
					.map(cf -> flattenFeatureGroups(Collections.singletonList(cf))).flatMap(List::stream)
					.filter(feat -> feat instanceof EventDataPort || feat instanceof DataPort)
					.filter(feat -> DirectionType.OUT.equals(((Port) feat).getDirection()))
					.collect(Collectors.toList()));
			if (!assignableElements.contains(namedEl)) {
				error("LHS of assignment must be an AGREE 'eq' variable or an output port of this component", assign,
						AgreePackage.Literals.ASSIGN_STATEMENT__ID);
			}
		}

		Type lhsType = (AgreeTypeSystem.typeFromID(namedEl));
		Type rhsType = (AgreeTypeSystem.infer(expr));

		if (!AgreeTypeSystem.typesEqual(lhsType, rhsType)) {
			error(assign, "The left hand side of the assignment statement is of type '" + typeToString(lhsType)
			+ "' but the right hand side is of type '" + typeToString(rhsType) + "'");
		}

		AgreeContract contract = EcoreUtil2.getContainerOfType(assign, AgreeContract.class);
		if (contract != null) {
			for (SpecStatement spec : contract.getSpecs()) {
				if (spec instanceof AssignStatement && spec != assign) {
					NamedElement otherEl = ((AssignStatement) spec).getId();
					if (otherEl.equals(namedEl)) {
						error(spec, "Mulitiple assignments to variable '" + namedEl.getName() + "'");
						error(assign, "Mulitiple assignments to variable '" + namedEl.getName() + "'");
					}
				}
			}
		}

	}

	@Check(CheckType.FAST)
	public void checkArg(Arg arg) {
		Type type = arg.getType();
		if (type instanceof PrimType) {
			PrimType primType = (PrimType) type;
			String strType = primType.getName();
			String rangeLow = primType.getRangeLow();
			String rangeHigh = primType.getRangeHigh();

			if (rangeLow != null && rangeHigh != null) {

				// this is a ranged argument. It can show up only in an equation statement
				EObject container = arg.eContainer();
				if (!(container instanceof EqStatement || container instanceof InputStatement)) {
					error(arg, "Ranged arguments can appear only in equation statements or agree_input statements");
				}

				boolean rangeLowDot = rangeLow.contains(".");
				boolean rangeHighDot = rangeHigh.contains(".");

				if (rangeLowDot != rangeHighDot) {
					error(arg, "The range intervals are of differing types");
				}

				if (strType.equals("int") && (rangeLowDot || rangeHighDot)) {
					error(arg, "Ranged variable of type 'int' contains a 'real' value in its interval");
				}

				if (strType.equals("real") && (!rangeLowDot || !rangeHighDot)) {
					error(arg, "Ranged variable of type 'real' contains an 'int' value in its interval");
				}

				float low = Float.valueOf(rangeLow);
				float high = Float.valueOf(rangeHigh);

				low *= primType.getLowNeg() == null ? 1.0 : -1.0;
				high *= primType.getHighNeg() == null ? 1.0 : -1.0;

				if (low >= high) {
					error(arg, "The low value of the interval is greater than or equal to the high end");
				}
			}

		}
	}

	@Check(CheckType.FAST)
	public void checkCalenStatement(CalenStatement calen) {
		Classifier container = calen.getContainingClassifier();
		if (!(container instanceof ComponentImplementation)) {
			error(calen, "Calendar statements can appear only in component implementations");
			return;
		}

		for (int index = 0; index < calen.getEls().size(); ++index) {
			NamedElement el = calen.getEls().get(index);
			if (!(el instanceof Subcomponent) || !((Subcomponent) el).getContainingComponentImpl().equals(container)) {
				error("Element '" + el.getName() + "' is not a subcomponent of '" + container.getName() + "'",
						calen, AgreePackage.Literals.CALEN_STATEMENT__ELS, index);
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkFloorCast(FloorCast floor) {
		if (isInLinearizationBody(floor)) {
			error(floor, "'event' expressions not allowed in linearization body expressions");
			return;
		}
		checkTypeExists(floor.getExpr());
		Type exprType = AgreeTypeSystem.infer(floor.getExpr());

		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
			error(floor, "Argument of floor cast is of type '" + typeToString(exprType)
			+ "' but must be of type 'real'");
		}
	}

	@Check(CheckType.FAST)
	public void checkRealCast(RealCast real) {
		if (isInLinearizationBody(real)) {
			error(real, "'event' expressions not allowed in linearization body expressions");
			return;
		}

		checkTypeExists(real.getExpr());
		Type exprType = AgreeTypeSystem.infer(real.getExpr());

		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, exprType)) {
			error(real, "Argument of real cast is of type '" + typeToString(exprType)
			+ "' but must be of type 'int'");
		}
	}

	@Check(CheckType.FAST)
	public void checkEventExpr(EventExpr event) {
		if (isInLinearizationBody(event)) {
			error(event, "'event' expressions not allowed in linearization body expressions");
			return;
		}

		NamedElement namedEl = null;
		if (event.getId() instanceof NamedElmExpr) {
			namedEl = ((NamedElmExpr) event.getId()).getElm();
		} else if (event.getId() instanceof ProjectionExpr) {
			namedEl = ((ProjectionExpr) event.getId()).getField();

		}
		if (!(namedEl instanceof EventPort || namedEl instanceof EventDataPort)) {
			error(event, "Argument of event expression must be an event port or event data port");
		}
	}

	@Check(CheckType.FAST)
	public void checkLatchedExpr(LatchedExpr latched) {

		// get container
		EObject container = latched.eContainer();
		AgreeContract contract = null;
		while (!(container instanceof ComponentClassifier)) {
			if (container instanceof AgreeContract) {
				contract = (AgreeContract) container;
			}
			container = container.eContainer();
		}

		if (container instanceof ComponentImplementation) {
			boolean foundLatchedStatement = false;
			for (SpecStatement spec : contract.getSpecs()) {
				if (spec instanceof LatchedStatement) {
					foundLatchedStatement = true;
					break;
				}
			}
			if (!foundLatchedStatement) {
				error(latched, "Latched expressions can appear only in component implementations "
						+ "that contain a latched synchrony statement");
			}
		} else {
			error(latched, "Latched expressions can appear only in component implementations");
		}

		Expr expr = latched.getExpr();
		NamedElmExpr nestId = null;
		if (expr instanceof NamedElmExpr) {
			nestId = (NamedElmExpr) expr;
		} else if (expr instanceof EventExpr) {
			EventExpr eventExpr = (EventExpr) expr;
			nestId = (NamedElmExpr) eventExpr.getId();
		}

		if (nestId != null) {
			NamedElement namedEl = nestId.getElm();
			if ((namedEl instanceof DataPort) && ((DataPort) namedEl).isIn()) {
				return;
			} else if ((namedEl instanceof EventDataPort) && ((EventDataPort) namedEl).isIn()) {
				return;
			} else {
				// check to see if it is an "agree_input"
				EObject namedElContainer = namedEl.eContainer();
				if (namedElContainer instanceof InputStatement) {
					return;
				}
			}
		}

		error(latched,
				"Latched expressions are valid only for input data ports or event expressions over input event data ports");
	}

	@Check(CheckType.FAST)
	public void checkSynchStatement(SynchStatement sync) {

		Classifier container = sync.getContainingClassifier();
		if (!(container instanceof ComponentImplementation)) {
			error(sync, "Synchrony statements can appear only in component implementations");
		}

		if (sync instanceof CalenStatement || sync instanceof MNSynchStatement || sync instanceof AsynchStatement
				|| sync instanceof LatchedStatement) {
			return;
		}

		// TODO: I'm pretty sure INT_LITs are always positive anyway.
		// So this may be redundant
		if (Integer.valueOf(sync.getVal()) < 0) {
			error(sync, "The value of synchrony statments must be positive");
		}
		String val2 = sync.getVal2();
		if (val2 != null) {
			if (Integer.valueOf(val2) <= 0) {
				error(sync, "The second value of a synchrony statment must be greater than zero");
			}
			if (Integer.valueOf(sync.getVal()) <= Integer.valueOf(val2)) {
				error(sync, "The second value of a synchrony argument must be less than the first");
			}
		}

	}

	@Check(CheckType.FAST)
	public void checkMNSynchStatement(MNSynchStatement sync) {
		ComponentImplementation compImpl = sync.getContainingComponentImpl();
		if (compImpl == null) {
			// This should already be checked by checkSynchStatement
			return;
		}
		compImpl.getAllSubcomponents();

		// this should be enforced by the parser, but we check to avoid an
		// index out of bounds exception whilst the user is editing...
		int expectedSize = sync.getMax().size();
		if (expectedSize != sync.getMin().size() || expectedSize != sync.getComp1().size()
				|| expectedSize != sync.getComp2().size()) {
			error(sync,
					"Mismatched number of subcomponents and timing ranges: " + sync.getComp1().size()
					+ " left subcomponents, " + sync.getComp2().size() + " right subcomponents, "
					+ sync.getMin().size() + " time minima, and " + sync.getMax().size() + " time maxima.");
			return;
		}

		for (int i = 0; i < expectedSize; i++) {
			NamedElement comp1 = sync.getComp1().get(i);
			NamedElement comp2 = sync.getComp2().get(i);
			String maxStr = sync.getMax().get(i);
			String minStr = sync.getMin().get(i);

			if (!(comp1 instanceof Subcomponent)
					|| !((Subcomponent) comp1).getContainingComponentImpl().equals(compImpl)) {
				error("Element '" + comp1.getName() + "' is not a subcomponent of '" + compImpl.getName() + "'",
						sync, AgreePackage.Literals.MN_SYNCH_STATEMENT__COMP1, i);
			}

			if (!(comp2 instanceof Subcomponent)
					|| !((Subcomponent) comp2).getContainingComponentImpl().equals(compImpl)) {
				error("Element '" + comp2.getName() + "' is not a subcomponent of '" + compImpl.getName() + "'",
						sync, AgreePackage.Literals.MN_SYNCH_STATEMENT__COMP2, i);
			}

			int max = Integer.valueOf(maxStr);
			int min = Integer.valueOf(minStr);

			if (max < 1 || min < 1) {
				error(sync, "Quasi-synchronous values must be greater than zero");
			}

			if (min > max) {
				error("Left hand side quasi-synchronous values must be greater than the right hand side");
			}
		}
	}

	private void getPackageDependencies(AadlPackage pkg, Set<AadlPackage> pkgs) {

		// Add the parent package if it's not there, otherwise return
		if (pkgs.contains(pkg)) {
			return;
		}
		pkgs.add(pkg);

		// Look at direct dependencies in private section
		if (pkg.getPrivateSection() != null) {
			for (ModelUnit mu : pkg.getPrivateSection().getImportedUnits()) {
				if (mu instanceof AadlPackage) {
					getPackageDependencies((AadlPackage) mu, pkgs);
				}
			}
		}

		// Look at direct dependencies in public section
		if (pkg.getPublicSection() != null) {
			for (ModelUnit mu : pkg.getPublicSection().getImportedUnits()) {
				if (mu instanceof AadlPackage) {
					getPackageDependencies((AadlPackage) mu, pkgs);
				}
			}
		}

	}

	private List<NamedSpecStatement> getNamedSpecStatements(AadlPackage pkg) {
		List<NamedSpecStatement> specs = new ArrayList<NamedSpecStatement>();
		for (Classifier classifier : EcoreUtil2.getAllContentsOfType(pkg, Classifier.class)) {
			for (AnnexSubclause annex : AnnexUtil.getAllAnnexSubclauses(classifier,
					AgreePackage.eINSTANCE.getAgreeContractSubclause())) {
				AgreeContract contract = (AgreeContract) ((AgreeContractSubclause) annex).getContract();
				for (SpecStatement spec : contract.getSpecs()) {
					if (spec instanceof NamedSpecStatement) {
						specs.add((NamedSpecStatement) spec);
					}
				}
			}
		}

		for (AnnexLibrary annex : AnnexUtil.getAllActualAnnexLibraries(pkg,
				AgreePackage.eINSTANCE.getAgreeContractLibrary())) {
			AgreeContract contract = (AgreeContract) ((AgreeContractLibrary) annex).getContract();
			for (SpecStatement spec : contract.getSpecs()) {
				if (spec instanceof NamedSpecStatement) {
					specs.add((NamedSpecStatement) spec);
				}
			}

		}
		return specs;
	}

	@Check(CheckType.NORMAL)
	public void checkNoDuplicateIdInSpec(AadlPackage toppkg) {

		// namedSpecs associates an agree spec ID with all the agree specs that have that ID
		HashMultimap<String, NamedSpecStatement> namedSpecs = HashMultimap.create();

		// Get the set of packages referenced in model
		Set<AadlPackage> pkgs = new HashSet<>();
		getPackageDependencies(toppkg, pkgs);

		for (AadlPackage pkg : pkgs) {

			// Get the list of agree specs in each package
			List<NamedSpecStatement> specs = getNamedSpecStatements(pkg);

			for (NamedSpecStatement spec : specs) {
				String id = spec.getName();

				if (id != null) {
					namedSpecs.put(id, spec);
				}
			}
		}

		// Get the agree specs in the current package
		List<NamedSpecStatement> specs = getNamedSpecStatements(toppkg);
		Iterator<NamedSpecStatement> i = specs.iterator();
		while (i.hasNext()) {

			NamedSpecStatement spec = i.next();
			String id = spec.getName();
			// If the current spec name is associated with multiple agree specs, we've found a duplicate
			if (namedSpecs.get(id).size() > 1) {
				Iterator<NamedSpecStatement> ii = namedSpecs.get(id).iterator();
				while (ii.hasNext()) {
					String pkgName = AadlUtil.getContainingPackage(ii.next()).getName();
//					// If the specs are from the same package, the error will be generated from the
//					// NamedElement check.
//					if (!pkgName.contentEquals(AadlUtil.getContainingPackage(spec).getName())) {
					error("Duplicate AGREE property ID in package " + pkgName, spec,
							Aadl2Package.eINSTANCE.getNamedElement_Name());
//					}
				}
				namedSpecs.removeAll(id);
			}
		}

	}

	@Check(CheckType.FAST)
	public void checkAssume(AssumeStatement assume) {
		Classifier comp = assume.getContainingClassifier();
		if (!(comp instanceof ComponentType)) {
			error(assume, "Assume statements are allowed only in component types");
		}

		// the expression could be null if a pattern is used
		Expr expr = assume.getExpr();
		if (expr != null) {
			Type exprType = AgreeTypeSystem.infer(expr);
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
				error(assume, "Expression for assume statement is of type '" + typeToString(exprType)
				+ "' but must be of type 'bool'");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkInitialStatement(InitialStatement statement) {
		Classifier comp = statement.getContainingClassifier();
		if (!(comp instanceof ComponentType)) {
			error(statement, "Initial statements are allowed only in component types");
		}

		Type exprType = AgreeTypeSystem.infer(statement.getExpr());
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
			error(statement,
					"Expression for 'initially' statement is of type '" + typeToString(exprType)
					+ "' but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkLift(LiftStatement lift) {


		if (!(lift.getSubcomp() instanceof NamedElement)) {
			error(lift, "Lift statements can be applied only to direct subcomponents."
					+ "Place a lift statement in the subcomponents contract for heavy lifting");
		}

		NamedElement namedEl = lift.getSubcomp();

		if (namedEl != null) {
			if (!(namedEl instanceof SubcomponentImpl)) {
				error(lift, "Lift statements must apply to subcomponent implementations. '" + namedEl.getName()
				+ "' is not a subcomponent.");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkAssert(AssertStatement asser) {
		Classifier comp = asser.getContainingClassifier();
		if (!(comp instanceof ComponentImplementation)) {
			error(asser, "Assert statements are allowed only in component implementations.");
		}

		// the expression could be null if a pattern is used
		Expr expr = asser.getExpr();
		if (expr != null) {
			Type exprType = AgreeTypeSystem.infer(expr);
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
				error(asser, "Expression for assert statement is of type '" + typeToString(exprType)
				+ "' but must be of type 'bool'");
			}
		}

		warning(asser, "We highly discourage the use of assert statements. "
				+ "They can easily lead to inconsistent or unrealizable systems. "
				+ "Note that our realizability check does not verify that component "
				+ "assertions are realizable.  It is likely that you can specify the "
				+ "behavior you want by changing the subcomponent contracts or " + "by using assignment statements.");

	}


	@Check(CheckType.FAST)
	public void checkAADLEnumerator(EnumLitExpr aadlEnum) {
		DoubleDotRef enumType = aadlEnum.getEnumType();
		NamedElement enumTypeNamedElement = enumType.getElm();
//		=======
//				public void checkAADLEnumerator(AADLEnumerator aadlEnum) {
//			DoubleDotRef enumType = aadlEnum.getEnumType();
//			NamedElement enumTypeNamedElement = enumType.getElm();
//			>>>>>>> origin/develop
		if (!AgreeAADLEnumerationUtils.isAADLEnumeration(enumTypeNamedElement)) {
			error(enumType, "AADL Enumerations must refer to a Data Type with \"Enum\" data representation "
					+ "property and have an \"Enumerators\' property value list.");
		} else {
			String enumVal = aadlEnum.getValue();
			List<String> enumerators = AgreeAADLEnumerationUtils
					.getEnumerators((ComponentClassifier) enumTypeNamedElement).stream()
					.map(pe -> ((org.osate.aadl2.StringLiteral) pe).getValue()).collect(Collectors.toList());
			if (!enumerators.stream().anyMatch(ev -> ev.equalsIgnoreCase(enumVal))) {
				error(aadlEnum, "AADL Enumeration " + enumTypeNamedElement.getQualifiedName()
				+ " does not have an enumeration value " + enumVal);
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkGuarantee(GuaranteeStatement guar) {
		Classifier comp = guar.getContainingClassifier();
		if (!(comp instanceof ComponentType)) {
			error(guar, "Guarantee statements are allowed only in component types");
		}

		// the expression could be null if a pattern is used
		Expr expr = guar.getExpr();
		if (expr != null) {
			Type exprType = AgreeTypeSystem.infer(expr);
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
				error(guar, "Expression for guarantee statement is of type '" + typeToString(exprType)
				+ "' but must be of type 'bool'");
			}
		}
	}

	public void checkExprIsIdentifier(Expr expr) {
		if (!(expr instanceof NamedElmExpr)) {
			error(expr, "Patterns can contain only identifiers (not general expressions)");
		}
	}

	@Check(CheckType.FAST)
	public void checkPeriodicStatement(PeriodicStatement statement) {
		Expr event = statement.getEvent();
		Expr jitter = statement.getJitter();
		Expr period = statement.getPeriod();

		checkExprIsIdentifier(event);

		Type eventType = AgreeTypeSystem.infer(event);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, eventType)) {
			error(event, "Expression is of type '" + eventType + "' but must be of type 'bool'");
		}

		if (jitter != null) {
			if (!(jitter instanceof RealLitExpr || isConst(jitter))) {
				error(jitter, "The specified jitter must be a real literal");
			} else {
				Double val = getRealConstVal(jitter);
				if (val < 0) {
					error(jitter, "The specified jitter must be positive");
				}
			}
		}

		if (!(period instanceof RealLitExpr || isConst(period))) {
			error(period, "The specified period must be a real literal");
		} else {
			Double val = getRealConstVal(period);
			if (val < 0) {
				error(period, "The specified period must be positive");
			}
		}
	}

	private double getRealConstVal(Expr expr) {
		if (expr instanceof RealLitExpr) {
			RealLitExpr realLit = (RealLitExpr) expr;
			return Double.valueOf(realLit.getVal());
		} else if (expr instanceof ProjectionExpr) {
			ProjectionExpr id = (ProjectionExpr) expr;
			NamedElement finalId = id.getField();
			if (finalId instanceof ConstStatement) {
				ConstStatement constState = (ConstStatement) finalId;
				return getRealConstVal(constState.getExpr());
			}
		}
		throw new IllegalArgumentException("not constant or literal value evalued");
	}

	@Check(CheckType.FAST)
	public void checkSporadicStatement(SporadicStatement statement) {
		Expr event = statement.getEvent();
		Expr jitter = statement.getJitter();
		Expr iat = statement.getIat();

		checkExprIsIdentifier(event);

		Type eventType = AgreeTypeSystem.infer(event);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, eventType)) {
			error(event, "Expression is of type '" + eventType + "' but must be of type 'bool'");
		}

		if (jitter != null) {
			if (!(jitter instanceof RealLitExpr || isConst(jitter))) {
				error(jitter, "The specified jitter must be a real literal");
			} else {
				Double val = getRealConstVal(jitter);
				if (val < 0) {
					error(jitter, "The specified jitter must be positive");
				}
			}
		}

		if (!(iat instanceof RealLitExpr || isConst(iat))) {
			error(iat, "The specified interarrival time must be a real literal");
		} else {
			Double val = getRealConstVal(iat);
			if (val < 0) {
				error(iat, "The specified interarrival time must be positive");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkWhenHoldsStatement(WhenHoldsStatement when) {
		Expr condition = when.getCondition();
		Expr event = when.getEvent();
		TimeInterval condInterval = when.getConditionInterval();

		checkExprIsIdentifier(condition);
		checkExprIsIdentifier(event);

		if (condInterval != null) {
			Expr lowExpr = condInterval.getLow();
			if (lowExpr instanceof RealLitExpr) {
				RealLitExpr realExpr = (RealLitExpr) lowExpr;
				if (!realExpr.getVal().equals("0.0")) {
					error(lowExpr, "The lower bound of this interval must be zero");
				}
			}
		} else {
			error(when, "Statement most of a cause interval");
		}

		Type type = AgreeTypeSystem.infer(condition);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(condition,
					"The condition of a when statement is of type '" + type + "'" + " but must be of type 'bool'");
		}
		type = AgreeTypeSystem.infer(event);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(event, "The effect of a when statement is of type '" + type + "'" + " but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkWhenOccursStatment(WhenOccursStatment when) {
		Expr condition = when.getCondition();
		Expr event = when.getEvent();
		Expr times = when.getTimes();

		checkExprIsIdentifier(condition);
		checkExprIsIdentifier(event);

		Type type = AgreeTypeSystem.infer(condition);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(condition,
					"The condition of the 'when' statement is of type '" + type + "'" + " but must be of type 'bool'");
		}
		type = AgreeTypeSystem.infer(event);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(event,
					"The effect of the 'when' statement is of type '" + type + "'" + " but must be of type 'bool'");
		}
		type = AgreeTypeSystem.infer(times);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, type)) {
			error(event,
					"The 'times' of the 'when' statement is of type '" + type + "'" + " but must be of type 'int'");
		}

	}

	@Check(CheckType.FAST)
	public void checkWheneverOccursStatement(WheneverOccursStatement whenever) {
		Expr cause = whenever.getCause();
		Expr effect = whenever.getEffect();

		checkExprIsIdentifier(cause);
		checkExprIsIdentifier(effect);

		Type type = AgreeTypeSystem.infer(cause);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(cause,
					"The cause of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
		type = AgreeTypeSystem.infer(effect);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(effect,
					"The effect of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkWheneverBecomesTrueStatement(WheneverBecomesTrueStatement whenever) {
		Expr cause = whenever.getCause();
		Expr effect = whenever.getEffect();

		checkExprIsIdentifier(cause);
		checkExprIsIdentifier(effect);

		Type type = AgreeTypeSystem.infer(cause);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(cause,
					"The cause of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
		type = AgreeTypeSystem.infer(effect);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(effect,
					"The effect of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkWheneverHoldsStatement(WheneverHoldsStatement whenever) {
		Expr cause = whenever.getCause();
		Expr effect = whenever.getEffect();

		checkExprIsIdentifier(cause);
		checkExprIsIdentifier(effect);

		Type type = AgreeTypeSystem.infer(cause);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(cause,
					"The cause of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
		type = AgreeTypeSystem.infer(effect);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(effect,
					"The effect of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkWheneverImpliesStatement(WheneverImpliesStatement whenever) {
		Expr cause = whenever.getCause();
		Expr lhs = whenever.getLhs();
		Expr rhs = whenever.getRhs();

		checkExprIsIdentifier(cause);
		checkExprIsIdentifier(lhs);
		checkExprIsIdentifier(rhs);

		Type type = AgreeTypeSystem.infer(cause);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(cause,
					"The cause of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}

		type = AgreeTypeSystem.infer(lhs);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(lhs, "The left hand side of the 'implies' of the 'whenever' statement is of type '" + type + "' "
					+ "but must be of type 'bool'");
		}

		type = AgreeTypeSystem.infer(rhs);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(lhs, "The rhs hand side of the 'implies' of the 'whenever' statement is of type '" + type + "' "
					+ "but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkTimeInterval(TimeInterval interval) {
		Expr lower = interval.getLow();
		Expr higher = interval.getHigh();

		if (!(lower instanceof RealLitExpr || isConst(lower))) {
			error(lower, "Lower interval must be a real valued literal");
		}

		if (!(higher instanceof RealLitExpr || isConst(higher))) {
			error(higher, "higher interval must be a real valued literal");
		}

	}

	protected boolean isConst(Expr expr) {
		if (expr instanceof ProjectionExpr) {
			ProjectionExpr id = (ProjectionExpr) expr;
			NamedElement finalId = id.getField();
			return (finalId instanceof ConstStatement);
		} else if (expr instanceof EnumLitExpr) {
			return true;
		}
		return false;
	}

	@Check(CheckType.FAST)
	public void checkTimeRise(TimeRiseExpr timeRise) {
		checkTimeExpr(timeRise, timeRise.getId());
	}

	@Check(CheckType.FAST)
	public void checkTimeFall(TimeFallExpr timeFall) {
		checkTimeExpr(timeFall, timeFall.getId());
	}

	@Check(CheckType.FAST)
	public void checkTimeOf(TimeOfExpr timeOf) {
		checkTimeExpr(timeOf, timeOf.getId());
	}

	public void checkTimeExpr(EObject expr, NamedElement id) {
		Type type = AgreeTypeSystem.typeFromID(id);

		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(expr, "Time functions can be applied only to Boolean identifiers");
		}

	}

	@Check(CheckType.FAST)
	public void checkLemma(LemmaStatement lemma) {
		Classifier comp = lemma.getContainingClassifier();
		if (!(comp instanceof ComponentImplementation)) {
			error(lemma, "Lemma statements are allowed only in component implementations and nodes");
		}

		Expr expr = lemma.getExpr();
		if (expr != null) {
			Type exprType = AgreeTypeSystem.infer(expr);
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
				error(lemma, "Expression for lemma statement is of type '" + typeToString(exprType)
				+ "' but must be of type 'bool'");
			}
		}
	}

	public void checkTypeExists(Expr e) {
		NamedElement ne = null;
		if (e instanceof NamedElmExpr) {
			ne = ((NamedElmExpr) e).getElm();
		} else if (e instanceof ProjectionExpr) {
			ne = ((ProjectionExpr) e).getField();
		}

		if (ne != null && !AgreeTypeSystem.hasType(ne)) {
			error(e, "named thing must be an expression with a type");
		}
	}

	@Check(CheckType.FAST)
	public void checkUnaryExpr(UnaryExpr unaryExpr) {

		checkTypeExists(unaryExpr.getExpr());

		Type typeRight = AgreeTypeSystem.infer(unaryExpr.getExpr());
		String op = unaryExpr.getOp();

		switch (op) {
		case "-":
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeRight)
					&& !AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeRight)) {
				error(unaryExpr, "right side of unary expression '" + op + "' is of type '" + typeRight
						+ "' but must be of type 'int' or 'real'");
			}
			break;
		case "not":
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, typeRight)) {
				error(unaryExpr, "right side of unary expression '" + op + "' is of type '" + typeRight
						+ "' but must be of type 'bool'");
			}
			break;
		default:
			assert (false);
		}
	}

	@Check(CheckType.FAST)
	public void checkPropertyStatement(PropertyStatement propStat) {
		AnnexLibrary library = EcoreUtil2.getContainerOfType(propStat, AnnexLibrary.class);
		if (library != null) {
			error(propStat, "Property statments are allowed only in component annexes");
		}

		Type exprType = AgreeTypeSystem.infer(propStat.getExpr());
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
			error(propStat, "Property statement '" + propStat.getName() + "' is of type '" + exprType
					+ "' but must be of type 'bool'");
		}

	}

	@Check(CheckType.FAST)
	public void checkInputStatement(InputStatement input) {
		ComponentType comp = EcoreUtil2.getContainerOfType(input, ComponentType.class);
		if (comp == null) {
			error(input, "Input statements are allowed only in component types");
		}

	}

	@Check(CheckType.FAST)
	public void checkRecordUpdateExpr(RecordUpdateExpr upExpr) {

		if (isInLinearizationBody(upExpr)) {
			error(upExpr, "Record update expressions not allowed in linearization body expression");
			return;
		}

		checkTypeExists(upExpr.getRecord());
		Type recordType = AgreeTypeSystem.infer(upExpr.getRecord());


		if (recordType instanceof DoubleDotRef) {
			NamedElement ne = ((DoubleDotRef) recordType).getElm();
			if (ne instanceof RecordDef) {
				// scoping should ensure the key is a proper Arg
				Arg arg = (Arg) upExpr.getKey();
				Type keyType = arg.getType();
				checkTypeExists(upExpr.getExpr());
				Type expType = AgreeTypeSystem.infer(upExpr.getExpr());

				if (!AgreeTypeSystem.typesEqual(keyType, expType)) {
					error(upExpr, "the update field is of type '" + typeToString(keyType)
					+ "', but the expression is of type '" + typeToString(expType) + "'");
				}

			} else if (ne instanceof DataImplementation) {
				// scoping should ensure the key is a proper Subcomponent
				Subcomponent subcomp = (Subcomponent) upExpr.getKey();
				Type keyType = AgreeTypeSystem.mkDoubleDotRef(subcomp.getClassifier());
				checkTypeExists(upExpr.getExpr());
				Type expType = AgreeTypeSystem.infer(upExpr.getExpr());
				if (!AgreeTypeSystem.typesEqual(keyType, expType)) {
					error(upExpr, "the update field is of type '" + typeToString(keyType)
					+ "', but the expression is of type '" + typeToString(expType) + "'");
				}
			} else {
				error("Record to be updated must be a data implementation or AGREE record type.  " + "Found type '"
						+ typeToString(recordType) + "'.", upExpr,
						AgreePackage.Literals.RECORD_UPDATE_EXPR__RECORD, -1);
			}
		} else {
			error("Record to be updated must be a data implementation or AGREE record type.  " + "Found type '"
					+ typeToString(recordType) + "'.", upExpr,
					AgreePackage.Literals.RECORD_UPDATE_EXPR__RECORD, -1);
		}

	}

	@Check(CheckType.FAST)
	public void checkRecordType(DoubleDotRef recType) {
		NamedElement finalId = recType.getElm();

//		if (!(finalId instanceof DataImplementation) && !(finalId instanceof RecordDef)
//				&& !(finalId instanceof DataType) && !(finalId instanceof EnumStatement)) {
//			error(recType, "types must be record definition, array definition, data implementation, enumeration, or datatype");
//		}

//		if (finalId instanceof DataImplementation) {
//			if (AgreeTypeSystem.typesEqual(recType, AgreeTypeSystem.errorType)) {
//				error(recType, "Data Implementations with no subcomponents must extend"
//						+ " a Base_Type that AGREE can reason about.");
//				return;
//			}
//			if (((DataImplementation) finalId).getAllSubcomponents().size() != 0) {
//				if (AgreeTypeSystem.typesEqual(recType, AgreeTypeSystem.boolType)
//						|| AgreeTypeSystem.typesEqual(recType, AgreeTypeSystem.intType)
//						|| AgreeTypeSystem.typesEqual(recType, AgreeTypeSystem.realType)) {
//					error(finalId, "Data implementations with subcomponents cannot be"
//							+ " interpreted by AGREE if they extend Base_Types");
//				}
//			}
//
//			// dataImplCycleCheck(recId);
//			return;
//		}

//		if (finalId instanceof DataType) {
//			if (AgreeTypeSystem.typesEqual(recType, AgreeTypeSystem.errorType)) {
//				error(recType, "AADL Datatypes must extend" + " a Base_Type that AGREE can reason about.");
//				return;
//			}
//		}
	}

	@Check(CheckType.FAST)

	public void checkArrayLiteralExpr(ArrayLiteralExpr alit) {
//		=======
//				public void checkRecordType(RecordType recType) {
//			DoubleDotRef recId = recType.getRecord();
//			NamedElement finalId = recId.getElm();
//			>>>>>>> origin/develop

		List<Expr> exprs = alit.getElems();
		if (exprs.size() == 0) {
			error(alit, "Array literal must have at least one element");
		}

		Expr target = exprs.get(0);
		checkTypeExists(target);
		Type t1 = AgreeTypeSystem.infer(target);
		for (Expr e : exprs) {
			checkTypeExists(e);
			Type t2 = AgreeTypeSystem.infer(e);
			if (!AgreeTypeSystem.typesEqual(t1, t2)) {
				error(e, "type of element must be " + typeToString(t1) + ", but has type " + typeToString(t2));
			}

		}

	}

	@Check(CheckType.FAST)
	public void checkArrayUpdateExpr(ArrayUpdateExpr arrup) {

		List<Expr> indices = arrup.getIndices();
		List<Expr> exprs = arrup.getValueExprs();

		Expr arrExpr = arrup.getArray();
		checkTypeExists(arrExpr);
		Type arrType = AgreeTypeSystem.infer(arrExpr);

		if (arrType instanceof DoubleDotRef) {
			NamedElement typedef = ((DoubleDotRef) arrType).getElm();
			if (typedef instanceof DataType) {
				ArrayDef ad = AgreeTypeSystem.arrayDefFromAadl((DataType) typedef);

				if (!ad.isArray || ad.dimension <= 0 || ad.baseType == null) {
					error(arrExpr, "expression must evaluate to an array");
				}

			}
		} else if (arrType instanceof ArrayType) {
			Type elmType = ((ArrayType) arrType).getStem();
			for (Expr e : exprs) {
				checkTypeExists(e);
				Type t = AgreeTypeSystem.infer(e);
				if (!AgreeTypeSystem.typesEqual(elmType, t)) {
					error(e, "type of element must be " + typeToString(elmType) + ", but has type " + typeToString(t));
				}

			}
		} else {
			error(arrExpr, "expression must evaluate to an array");
		}




	}

	@Check(CheckType.FAST)
	public void checkArraySubExpr(ArraySubExpr asub) {

		Expr arrayExp = asub.getExpr();
		checkTypeExists(arrayExp);
		Type arrayType = AgreeTypeSystem.infer(arrayExp);

		if (arrayType instanceof DoubleDotRef) {

			NamedElement typedef = ((DoubleDotRef) arrayType).getElm();

			if (typedef instanceof DataType) {
				ArrayDef ad = AgreeTypeSystem.arrayDefFromAadl((DataType) typedef);

				if (!ad.isArray || ad.dimension <= 0 || ad.baseType == null) {

					error(arrayExp, "element must be an array");
				}

			}

		} else if (!(arrayType instanceof ArrayType)) {
			error(arrayExp, "element must be an array");
		}

		Expr index = asub.getIndex();
		checkTypeExists(index);
		Type indexType = AgreeTypeSystem.infer(index);
		if (!AgreeTypeSystem.typesEqual(indexType, AgreeTypeSystem.intType)) {
			error(index, "index must be an int");
		}

	}


	@Check(CheckType.FAST)
	public void checkRecordLitExpr(RecordLitExpr recExpr) {


		DoubleDotRef recType = recExpr.getRecordType();
//			=======
//					DoubleDotRef recType = recExpr.getRecord();
//			>>>>>>> origin/develop
		List<NamedElement> defArgs = getArgNames(recType);
		EList<NamedElement> exprArgs = recExpr.getArgs();
		EList<Expr> argExprs = recExpr.getArgExpr();


		NamedElement finalId = recExpr.getRecordType().getElm();
		if (!(finalId instanceof DataImplementation) && !(finalId instanceof RecordDef)) {
			error(recType, "types must be record definition or data implementation");
//				=======
//						DoubleDotRef recId = recExpr.getRecord();
//				NamedElement finalId = recId.getElm();
//
//				if (!(finalId instanceof DataImplementation) && !(finalId instanceof RecordDefExpr)) {
//					error(recId, "types must be record definition or data implementation");
//				}
//
//				if (finalId instanceof DataImplementation) {
//					dataImplCycleCheck(recId);
//					>>>>>>> origin/develop
		}

		if (exprArgs.size() != defArgs.size()) {
			error(recExpr, "Incorrect number of arguments");
			return;
		}

		for (NamedElement argDefName : defArgs) {
			boolean foundArg = false;
			for (NamedElement argExprEl : exprArgs) {
				if (argExprEl.getName().equals(argDefName.getName())) {
					foundArg = true;
					break;
				}
			}
			if (!foundArg) {
				error(recExpr, "No assignment to defined variable '" + argDefName + "' in record expression.");
			}
		}

		// check typing
		Map<String, Type> argNameMap = getFieldTypes(recType);
		for (int i = 0; i < recExpr.getArgs().size(); i++) {
			NamedElement actArg = recExpr.getArgs().get(i);
			String actArgName = actArg.getName();
			Type defType = argNameMap.get(actArgName);

			checkTypeExists(argExprs.get(i));
			Type exprType = AgreeTypeSystem.infer(argExprs.get(i));

			if (!AgreeTypeSystem.typesEqual(defType, exprType)) {
				error(recExpr, "The expression assigned to '" + actArgName + "' does not match its definition type of '"
						+ defType + "'");
			}
		}
	}

	private List<NamedElement> getArgNames(DoubleDotRef recType) {

		NamedElement rec = recType.getElm();
//				=======
//						private List<NamedElement> getArgNames(DoubleDotRef recId) {
//
//					NamedElement rec = recId.getElm();
//					>>>>>>> origin/develop
		List<NamedElement> names = new ArrayList<>();

		if (rec instanceof RecordDef) {
			RecordDef recDef = (RecordDef) rec;
			for (Arg arg : recDef.getArgs()) {
				names.add(arg);
			}
		} else if (rec instanceof DataImplementation) {
			DataImplementation dataImpl = (DataImplementation) rec;
			for (Subcomponent sub : dataImpl.getAllSubcomponents()) {
				names.add(sub);
			}
		} else {
			error(recType, "Record type '" + rec.getName() + "' must be a feature group or a record type definition");
		}

		return names;
	}


	private Map<String, Type> getFieldTypes(DoubleDotRef recType) {

		NamedElement rec = recType.getElm();
		Map<String, Type> typeMap = new HashMap<>();
//					=======
//							private Map<String, AgreeType> getArgNameMap(DoubleDotRef recId) {
//
//						NamedElement rec = recId.getElm();
//						Map<String, AgreeType> typeMap = new HashMap<>();
//						>>>>>>> origin/develop

		if (rec instanceof RecordDef) {
			RecordDef recDef = (RecordDef) rec;
			for (Arg arg : recDef.getArgs()) {
				typeMap.put(arg.getName(), arg.getType());
			}
		} else if (rec instanceof DataImplementation) {
			DataImplementation dataImpl = (DataImplementation) rec;
			for (Subcomponent sub : dataImpl.getAllSubcomponents()) {
				typeMap.put(sub.getName(), AgreeTypeSystem.mkDoubleDotRef(sub.getClassifier()));
			}
		} else {
			error(recType, "Record type '" + rec.getName() + "' must be a feature group or a record type definition");
		}

		return typeMap;
	}

//	=======
////    private List<AgreeType> getArgTypes(NestedDotID recId){
////
////    	NamedElement rec = getFinalNestId(recId);
////    	List<AgreeType> types = new ArrayList<AgreeType>();
////
////    	if(rec instanceof RecordDefExpr){
////    		RecordDefExpr recDef = (RecordDefExpr)rec;
////    		for(Arg arg : recDef.getArgs()){
////    			types.add(getAgreeType(arg.getType()));
////    		}
////    	}else if(rec instanceof FeatureGroupType){
////    		FeatureGroupType featGroup = (FeatureGroupType)rec;
////    		for(Feature feat : featGroup.getAllFeatures()){
////    			types.add(getAgreeType(feat));
////    		}
////    	}
////
////    	return types;
////    }
//
//	private void dataImplCycleCheck(NestedDotID dataID) {
//		NamedElement finalId = dataID.getBase();
//		DataImplementation dataImpl = (DataImplementation) finalId;
//		dataImplCycleCheck(dataImpl, dataID);
//	}
//
//	private void dataImplCycleCheck(DoubleDotRef dataID) {
//		NamedElement finalId = dataID.getElm();
//		DataImplementation dataImpl = (DataImplementation) finalId;
//		dataImplCycleCheck(dataImpl, dataID);
//	}
//
//
//	private void dataImplCycleCheck(DataImplementation dataImpl, EObject errorSource) {
//		Set<DataImplementation> dataClosure = new HashSet<>();
//		Set<DataImplementation> prevClosure = null;
//
//		for (Subcomponent sub : dataImpl.getAllSubcomponents()) {
//			ComponentImplementation subImpl = sub.getComponentImplementation();
//			if (subImpl != null) {
//				dataClosure.add((DataImplementation) subImpl);
//			}
//		}
//
//		do {
//			prevClosure = new HashSet<>(dataClosure);
//			for (DataImplementation subImpl : prevClosure) {
//				if (subImpl == dataImpl) {
//					error(errorSource, "The component implementation '" + dataImpl.getName()
//					+ "' has a cyclic definition.  This cannot be reasoned about by AGREE.");
//					break;
//				}
//				for (Subcomponent subSub : subImpl.getAllSubcomponents()) {
//					ComponentImplementation subSubImpl = subSub.getComponentImplementation();
//					if (subSubImpl != null) {
//						dataClosure.add((DataImplementation) subSubImpl);
//					}
//				}
//
//			}
//
//		} while (!prevClosure.equals(dataClosure));
//
//	}
//	>>>>>>> origin/develop

	@Check(CheckType.FAST)
	public void checkRecordDefExpr(RecordDef recordDef) {

		Set<RecordDef> recordClosure = new HashSet<>();
		Set<RecordDef> prevClosure = null;

		for (Arg arg : recordDef.getArgs()) {
			Type type = arg.getType();

			if (type instanceof DoubleDotRef) {
				NamedElement finalId = ((DoubleDotRef) type).getElm();
//				=======
//						if (type instanceof RecordType) {
//							DoubleDotRef subRec = ((RecordType) type).getRecord();
//							NamedElement finalId = subRec.getElm();
//							>>>>>>> origin/develop

				if (finalId instanceof RecordDef) {
					recordClosure.add((RecordDef) finalId);
				}
			}
		}
		do {
			prevClosure = new HashSet<>(recordClosure);

			for (RecordDef subRecDef : prevClosure) {

				if (subRecDef == recordDef) {
					error(recordDef,
							"The definition of type '" + recordDef.getName() + "' is involved in a cyclic definition");
					break;
				}
				for (Arg arg : subRecDef.getArgs()) {
					Type type = arg.getType();

					if (type instanceof DoubleDotRef) {
						NamedElement subFinalEl = ((DoubleDotRef) type).getElm();
						if (subFinalEl instanceof RecordDef) {
							recordClosure.add((RecordDef) subFinalEl);
//								=======
//										if (type instanceof RecordType) {
//											DoubleDotRef subRecId = ((RecordType) type).getRecord();
//											NamedElement subFinalEl = subRecId.getElm();
//											if (subFinalEl instanceof RecordDefExpr) {
//												recordClosure.add((RecordDefExpr) subFinalEl);
//												>>>>>>> origin/develop
						}
					}
				}
			}
		} while (!prevClosure.equals(recordClosure));
	}

	@Check(CheckType.FAST)
	public void checkConstStatement(ConstStatement constStat) {
		Type expected = constStat.getType();
		Type actual = AgreeTypeSystem.infer(constStat.getExpr());

		if (!AgreeTypeSystem.typesEqual(expected, actual)) {
			error(constStat, "The assumed type of constant statement '" + constStat.getName() + "' is '" + expected
					+ "' but the actual type is '" + actual + "'");
		}

		// check for constant cycles
		Set<ConstStatement> constClosure = new HashSet<>();
		Set<ConstStatement> prevClosure;
		constClosure.add(constStat);

		// quick and dirty cycle check
		do {
			prevClosure = new HashSet<>(constClosure);
			for (ConstStatement constFrontElem : prevClosure) {
				List<ProjectionExpr> nestIds = EcoreUtil2.getAllContentsOfType(constFrontElem, ProjectionExpr.class);
				for (Expr nestId : nestIds) {
					while (nestId instanceof ProjectionExpr) {
						NamedElement base = ((ProjectionExpr) nestId).getField();
						if (base instanceof ConstStatement) {
							ConstStatement closConst = (ConstStatement) base;
							if (closConst.equals(constStat)) {
								error(constStat, "The expression for constant statment '" + constStat.getName()
								+ "' is part of a cyclic definition");
								break;
							}
							constClosure.add(closConst);
						}
						nestId = ((ProjectionExpr) nestId).getExpr();
					}

					NamedElement base = ((NamedElmExpr) nestId).getElm();
					if (base instanceof ConstStatement) {
						ConstStatement closConst = (ConstStatement) base;
						if (closConst.equals(constStat)) {
							error(constStat, "The expression for constant statment '" + constStat.getName()
							+ "' is part of a cyclic definition");
							break;
						}
						constClosure.add(closConst);
					}

				}
			}
		} while (!prevClosure.equals(constClosure));

		for (Expr e : EcoreUtil2.getAllContentsOfType(constStat.getExpr(), Expr.class)) {
			if (!isPossibleConstant(e)) {
				error(e, "Non-constant expression in constant declaration");
				return;
			}
		}
	}

//	=======
//	protected AgreeType getAgreeType(Type type) {
//		String typeName = null;
//		if (type instanceof PrimType) {
//			typeName = ((PrimType) type).getString();
//			return new AgreeType(typeName);
//		} else {
//			RecordType recType = (RecordType) type;
//			DoubleDotRef recId = recType.getRecord();
//			return getNamedElmAsType(recId.getElm());
//		}
//	}
//
//	private AgreeType getNamedElmAsType(NamedElement recEl) {
//		String typeName = "";
//		EObject aadlPack = recEl.eContainer();
//
//		while (!(aadlPack instanceof AadlPackage)) {
//			aadlPack = aadlPack.eContainer();
//		}
//
//		String packName = ((AadlPackage) aadlPack).getName();
//
//		if (recEl instanceof RecordDefExpr) {
//			EObject component = recEl.eContainer();
//			while (!(component instanceof ComponentClassifier) && !(component instanceof AadlPackage)) {
//				component = component.eContainer();
//			}
//
//			if (component == aadlPack) {
//				typeName = recEl.getName();
//			} else {
//				typeName = ((ComponentClassifier) component).getName() + "." + recEl.getName();
//			}
//
//		} else if (recEl instanceof DataImplementation) {
//			AgreeType nativeType = getNativeType((DataImplementation) recEl);
//			if (nativeType != null) {
//				return nativeType;
//			}
//			typeName = recEl.getName();
//		} else if (recEl instanceof DataType) {
//			return getAgreeType((ComponentClassifier) recEl);
//		} else if (recEl instanceof EnumStatement) {
//			typeName = recEl.getFullName();
//		}
//		typeName = packName + "::" + typeName;
//
//		return new AgreeType(typeName);
//	}
//
//	>>>>>>> origin/develop
	public boolean isPossibleConstant(Expr e) {
		if (e instanceof PrevExpr || e instanceof PreExpr) {
			return false;
		}

		if (e instanceof BinaryExpr) {
			if (((BinaryExpr) e).getOp().equals("->")) {
				return false;
			}
		}

		if (e instanceof NamedElmExpr) {
			if (EcoreUtil2.getContainerOfType(e, GetPropertyExpr.class) != null) {
				return true;
			}

			NamedElement base = ((NamedElmExpr) e).getElm();

			if (base instanceof DataImplementation || base instanceof ConstStatement || base instanceof RecordLitExpr
					|| base instanceof DataSubcomponent) {
				return true;
			}

			if (base instanceof DataType && e.eContainer() instanceof EnumLitExpr) {
				return true;
			}

			return false;
		}

		return true;
	}

	@Check(CheckType.FAST)
	public void checkNamedElement(NamedElement namedEl) {

		// check for namespace collision in component types of component
		// implementations
		// and for collisions between subcomponent and feature names

		EObject container = namedEl.eContainer();
		if (container == null) {
			return;
		}

		if (container instanceof RecordDef || container instanceof NodeDef) {
			// don't care about arguments to recDefs and nodeDefs
			// TODO: perhaps we can ignore all arguments?
			return;
		}

		while (!(container instanceof AadlPackage || container instanceof ComponentImplementation
				|| container instanceof ComponentType)) {
			container = container.eContainer();
		}

		ComponentImplementation compImpl = null;
		ComponentType type = null;
		if (container instanceof ComponentImplementation) {
			compImpl = (ComponentImplementation) container;
			type = compImpl.getType();
			checkDupNames(namedEl, type, compImpl);
		} else if (container instanceof ComponentType) {
			type = (ComponentType) container;
		}

		if (type != null) {
			for (Feature feat : type.getAllFeatures()) {
				if (namedEl.getName().equals(feat.getName())) {
					error(feat, "Element of the same name ('" + namedEl.getName() + "') in AGREE Annex in '"
							+ (compImpl == null ? type.getName() : compImpl.getName()) + "'");
					error(namedEl, "Feature of the same name ('" + namedEl.getName() + "') in component type");
				}
			}
		}

		// check name space collision with enumerated types

	}

	private void checkDupNames(NamedElement namedEl, ComponentType type, ComponentImplementation compImpl) {
		NamedElement match = matchedInAgreeAnnex(type, namedEl.getName());

		if (match != null) {
			error(match, "Element of the same name ('" + namedEl.getName() + "') in component implementation '"
					+ compImpl.getName() + "'");
			error(namedEl, "Element of the same name ('" + namedEl.getName() + "') in component type");
		}

		for (Subcomponent sub : compImpl.getAllSubcomponents()) {
			if (namedEl.getName().equals(sub.getName())) {
				error(sub, "Element of the same name ('" + namedEl.getName() + "') in AGREE Annex in '"
						+ compImpl.getName() + "'");
				error(namedEl,
						"Subcomponent of the same name ('" + namedEl.getName() + "') in component implementation");
			}
		}
	}

	private NamedElement matchedInAgreeAnnex(ComponentClassifier compClass, String name) {

		for (AnnexSubclause subClause : AnnexUtil.getAllAnnexSubclauses(compClass,
				AgreePackage.eINSTANCE.getAgreeSubclause())) {
			if (subClause instanceof AgreeSubclause) {
				AgreeContract contr = (AgreeContract) subClause.getChildren().get(0);
				for (EObject obj : contr.getChildren()) {
					if (obj instanceof NamedElement) {
						if (name.equals(((NamedElement) obj).getName())) {
							return (NamedElement) obj;
						}
					}
				}
			}
		}
		return null;
	}

	private boolean argsContainRangeValue(List<Arg> args) {
		for (Arg arg : args) {
			Type type = arg.getType();
			if (type instanceof PrimType) {
				PrimType primType = (PrimType) type;
				if (primType.getRangeHigh() != null || primType.getRangeLow() != null) {
					return true;
				}
			}
		}
		return false;
	}

	private void checkMultiAssignEq(EObject src, List<Arg> lhsArgs, Expr rhsExpr) {

		if (rhsExpr == null) {
			return;
		}

		if (lhsArgs.size() == 1) {
			// we should only need to check for cycles for single equations
			String name = lhsArgs.get(0).getName();
			ExprCycleVisitor cycleVisitor = new ExprCycleVisitor(name);
			Set<EObject> cycleObjects = cycleVisitor.doSwitch(rhsExpr);
			if (cycleObjects == null) {
				throw new IllegalArgumentException("something went wrong with the cycle checker");
			}
			for (EObject obj : cycleObjects) {
				error(obj, "Cyclic reference to variable '" + name + "'");
			}
		}

		if (argsContainRangeValue(lhsArgs)) {
			error(src, "Equation statements cannot contain a ranged value and a right hand side expression");
		}

		List<Type> agreeLhsTypes = new ArrayList<>();
		for (Arg arg : lhsArgs) {
			agreeLhsTypes.add(arg.getType());
		}
		List<Type> agreeRhsTypes = new ArrayList<>();


		if (rhsExpr instanceof CallExpr) {
			NamedElement namedEl = ((CallExpr) rhsExpr).getRef().getElm();
			if (namedEl instanceof NodeDef) {
				NodeDef nodeDef = (NodeDef) namedEl;
//				=======
//						if (rhsExpr instanceof FnCallExpr) {
//
//							NamedElement namedEl = (((FnCallExpr) rhsExpr).getFn().getBase());
//							if (namedEl instanceof NodeDefExpr) {
//								NodeDefExpr nodeDef = (NodeDefExpr) namedEl;
//								>>>>>>> origin/develop
				for (Arg var : nodeDef.getRets()) {
					agreeRhsTypes.add(var.getType());
				}
			} else if (namedEl instanceof FnDef) {
				FnDef fnDef = (FnDef) namedEl;
				agreeRhsTypes.add(fnDef.getType());
			} else {
				return; // parse error
			}
		} else {
			checkTypeExists(rhsExpr);
			Type rhsType = AgreeTypeSystem.infer(rhsExpr);
			agreeRhsTypes.add(rhsType);

		}

		if (agreeLhsTypes.size() != agreeRhsTypes.size()) {
			error(src, "Equation assigns " + agreeLhsTypes.size() + " variables, but right side returns "
					+ agreeRhsTypes.size() + " values");
			return;
		}

		for (int i = 0; i < agreeLhsTypes.size(); i++) {
			Type lhsType = agreeLhsTypes.get(i);
			Type rhsType = agreeRhsTypes.get(i);

			if (!AgreeTypeSystem.typesEqual(rhsType, lhsType)) {
				error(src, "The variable '" + lhsArgs.get(i).getName() + "' on the left side of equation is of type '"
						+ typeToString(lhsType) + "' but must be of type '" + typeToString(rhsType) + "'");
			}
		}

	}

	@Check(CheckType.FAST)
	public void checkEqStatement(EqStatement eqStat) {
		AnnexLibrary library = EcoreUtil2.getContainerOfType(eqStat, AnnexLibrary.class);
		if (library != null) {
			error(eqStat, "Equation statments are allowed only in component annexes");
		}
		checkMultiAssignEq(eqStat, eqStat.getLhs(), eqStat.getExpr());
	}

	@Check(CheckType.FAST)
	public void checkNameOverlap(AgreeContract contract) {

		Set<SynchStatement> syncs = new HashSet<>();
		Set<InitialStatement> inits = new HashSet<>();
		List<ConnectionStatement> conns = new ArrayList<>();
		// check that there are zero or more synchrony statements
		for (SpecStatement spec : contract.getSpecs()) {
			if (spec instanceof SynchStatement) {
				syncs.add((SynchStatement) spec);
			} else if (spec instanceof CalenStatement) {
				syncs.add((CalenStatement) spec);
			} else if (spec instanceof InitialStatement) {
				inits.add((InitialStatement) spec);
			} else if (spec instanceof ConnectionStatement) {
				conns.add((ConnectionStatement) spec);
			}

		}

		if (syncs.size() > 1) {
			for (SynchStatement sync : syncs) {
				error(sync, "Multiple synchrony or calender statements in a single contract");
			}
		}

		if (inits.size() > 1) {
			for (InitialStatement init : inits) {
				error(init, "Multiple initially statements in a single contract");
			}
		}

		for (int i = 0; i < conns.size(); i++) {
			ConnectionStatement connStat0 = conns.get(i);
			NamedElement conn0 = connStat0.getConn();
			for (int j = i + 1; j < conns.size(); j++) {
				ConnectionStatement connStat1 = conns.get(j);
				NamedElement conn1 = connStat1.getConn();
				if (conn0 == null || conn1 == null) {
					break;
				}
				if (conn0.equals(conn1)) {
					error(connStat0, "Multiple connection overrides for connection: '" + conn0.getName() + "'");
					error(connStat1, "Multiple connection overrides for connection: '" + conn1.getName() + "'");
				}
			}
		}

		ComponentImplementation ci = EcoreUtil2.getContainerOfType(contract, ComponentImplementation.class);
		if (ci == null) {
			return;
		}

		Set<String> parentNames = getParentNames(ci);
		for (AgreeSubclause subclause : EcoreUtil2.getAllContentsOfType(ci, AgreeSubclause.class)) {
			List<NamedElement> es = EcoreUtil2.getAllContentsOfType(subclause, NamedElement.class);
			for (NamedElement e : es) {

				if (!(e.eContainer() instanceof NodeDef)) { // ignore elements in node defs
					if (parentNames.contains(e.getName())) {
//								=======
//										if (!(e.eContainer() instanceof NodeDefExpr)) { // ignore elements in node defs
//											if (e.getName() != null && parentNames.contains(e.getName())) {
//												>>>>>>> origin/develop
						error(e, e.getName() + " already defined in component type contract");
					}
				}
			}
		}
	}

	private Set<String> getParentNames(ComponentImplementation ci) {
		Set<String> result = new HashSet<>();
		ComponentType ct = ci.getType();
		for (AgreeSubclause subclause : EcoreUtil2.getAllContentsOfType(ct, AgreeSubclause.class)) {
			List<NamedElement> es = EcoreUtil2.getAllContentsOfType(subclause, NamedElement.class);
			for (NamedElement e : es) {
				if (!(e.eContainer() instanceof NodeDef || e.eContainer() instanceof LinearizationDef
						|| e.eContainer() instanceof RecordDef)) {
					result.add(e.getName());
				}
			}
		}
		return result;
	}

	@Check(CheckType.FAST)
	public void checkNodeEq(NodeEq nodeEq) {
		EObject container = nodeEq.eContainer();
		NodeBodyExpr containingNodeBodyExpr;
		NodeDef containingNodeDef;

		if (container instanceof NodeBodyExpr) {
			containingNodeBodyExpr = (NodeBodyExpr) container;
		} else {
			error(nodeEq, "Node equation must be contained in a node body.");
			return;
		}

		if (container != null) {
			container = container.eContainer();
		}
		if (container instanceof NodeDef) {
			containingNodeDef = (NodeDef) container;
		} else {
			error(nodeEq, "Node equation must be contained in a node definition.");
			return;
		}

		List<Arg> locals = containingNodeBodyExpr.getLocs();
		List<Arg> returns = containingNodeDef.getRets();
		int lhsIndex = 0;
		for (Arg lhs : nodeEq.getLhs()) {
			if (!locals.contains(lhs) && !returns.contains(lhs)) {
				error("LHS '" + lhs.getName() + "' of node equation must be a node return variable or local variable.",
						nodeEq, AgreePackage.Literals.NODE_EQ__LHS, lhsIndex);
			}
			++lhsIndex;
		}

		checkMultiAssignEq(nodeEq, nodeEq.getLhs(), nodeEq.getExpr());
	}

	@Check(CheckType.FAST)
	public void checkNodeLemma(NodeLemma nodeLemma) {
		Type exprType = AgreeTypeSystem.infer(nodeLemma.getExpr());
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
			error(nodeLemma, "Expression for lemma statement is of type '" + exprType + "' but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkNodeStmt(NodeStmt nodeStmt) {
		List<NamedElmExpr> dotIds = EcoreUtil2.getAllContentsOfType(nodeStmt, NamedElmExpr.class);
		for (NamedElmExpr dotId : dotIds) {
			NamedElement id = dotId.getElm();

			// restrict the elements that are single names or the last projection.
			boolean restrictedElm = true;
			if (dotId.eContainer() instanceof ProjectionExpr) {
				NamedElement ne = ((ProjectionExpr) dotId.eContainer()).getField();
				restrictedElm = ne == id && !(dotId.eContainer().eContainer() instanceof ProjectionExpr);
			}

			if (restrictedElm &&

					!(id instanceof Arg) && !(id instanceof ConstStatement) && !(id instanceof NodeDef)
					&& !(id instanceof FnDef) && !(id instanceof DataSubcomponent) && !(id instanceof DoubleDotRef)
					&& !(id instanceof DataImplementation) && !(id instanceof RecordDef)) {
				error(dotId, "Only arguments, constants, and node calls allowed within a node");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkNodeDef(NodeDef nodeDefExpr) {

		if (nodeDefExpr.getNodeBody() == null) {
			return; // this will throw a parse error anyway
		}

		Map<Arg, Integer> assignMap = new HashMap<>();
		for (Arg arg : nodeDefExpr.getRets()) {
			assignMap.put(arg, 0);
		}
		for (Arg arg : nodeDefExpr.getNodeBody().getLocs()) {
			assignMap.put(arg, 0);
		}

		for (NodeStmt stmt : nodeDefExpr.getNodeBody().getStmts()) {
			if (stmt instanceof NodeEq) {
				NodeEq eq = (NodeEq) stmt;
				for (Arg arg : eq.getLhs()) {
					Integer value = assignMap.get(arg);
					if (value == null) {
						error("Equation attempting to assign '" + arg.getName()
						+ "', which is not an assignable value within the node");
						return;
					} else {
						assignMap.put(arg, value + 1);
					}
				}
			}
		}
		for (Map.Entry<Arg, Integer> elem : assignMap.entrySet()) {
			if (elem.getValue() == 0) {
				error("Variable '" + elem.getKey().getName() + "' is never assigned by an equation in node '"
						+ nodeDefExpr.getName() + "'");
				return;
			} else if (elem.getValue() > 1) {
				error("Variable '" + elem.getKey().getName() + "' is assigned multiple times in node '"
						+ nodeDefExpr.getName() + "'");
			}
		}
	}

	public static boolean isInLinearizationBody(Expr expr) {
		boolean result = false;
		EObject current = expr;
		while (current != null && current instanceof Expr) {
			EObject container = current.eContainer();
			if (container instanceof LinearizationDef) {
				result = ((LinearizationDef) container).getExprBody().equals(current);
			}
			current = container;
		}
		return result;
	}

	@Check(CheckType.FAST)
	public void checkLinearizationDefExpr(LinearizationDef linDefExpr) {
		// Check that allowable number of formal args are defined
		if (linDefExpr.getArgs().size() != 1) {
			error(linDefExpr, "Linearization definitions are limited to functions of one variable.");
		}

		// Check that the formal args are all of real type
		for (Arg arg : linDefExpr.getArgs()) {
			Type argType = arg.getType();
			if (!AgreeTypeSystem.typesEqual(argType, AgreeTypeSystem.realType)) {
				error(arg, "Linearizations formal arguments must be of real type, but found type " + argType);
			}
		}

		// Check that the number of domain intervals matches the number of
		// formal arguments
		if (linDefExpr.getIntervals().size() != linDefExpr.getArgs().size()) {
			error(linDefExpr, "Number of formal variables and intervals does not match.");
		}

		// If a precision clause is present, it must be a constant expression
		// of real type
		Expr precisionExpr = linDefExpr.getPrecision();
		if (precisionExpr != null) {
			Type precisionExprType = AgreeTypeSystem.infer(precisionExpr);
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, precisionExprType)) {
				error(precisionExpr,
						"Linearization precision must be of real type, but found type " + precisionExprType);
			}
			if (!exprIsConst(precisionExpr)) {
				error(precisionExpr, "Linearization precision must be constant expression of real type"
						+ ", found non-constant expression.");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkLinearizationInterval(LinearizationInterval linInterval) {
		final String message = "Linearization interval endpoints must be constant expressions of real type";
		Expr startExpr = linInterval.getStart();
		Expr endExpr = linInterval.getEnd();
		Type startExprType = AgreeTypeSystem.infer(startExpr);
		Type endExprType = AgreeTypeSystem.infer(endExpr);

		// The type of the interval start and end must be of real type
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, startExprType)) {
			error(startExpr, message + ", found type " + startExprType + ".");
		}
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, endExprType)) {
			error(endExpr, message + ", found type " + endExprType + ".");
		}

		// The interval start and end expressions must be constant
		if (!exprIsConst(startExpr)) {
			error(endExpr, message + ", found non-constant expression.");
		}
		if (!exprIsConst(startExpr)) {
			error(endExpr, message + ", found non-constant expression.");
		}
	}

	private static NamedElement namedElementFromComponentRef(ComponentRef componentRef) {
		if (componentRef instanceof DoubleDotRef) {
			return ((DoubleDotRef) componentRef).getElm();
		} else if (componentRef instanceof ThisRef) {
			NamedElement component = EcoreUtil2.getContainerOfType(componentRef, ComponentClassifier.class);
			return component;
		}

		return null;

	}

	@Check(CheckType.FAST)
	public void checkGetPropertyExpr(GetPropertyExpr getPropExpr) {
		ComponentRef componentRef = getPropExpr.getComponentRef();
		NamedElement prop = getPropExpr.getProp();

		if (!(prop instanceof Property || prop instanceof PropertyConstant)) {
			error(getPropExpr.getProp(), "Expected AADL property or property constant");
		}

		if (prop instanceof Property) {
			NamedElement element = namedElementFromComponentRef(componentRef);
			final boolean applies = element.acceptsProperty((Property) prop);
			if (!applies) {
				error("Property " + ((Property) prop).getQualifiedName() + " does not apply to "
						+ element.getQualifiedName() + ".", getPropExpr,
						AgreePackage.Literals.GET_PROPERTY_EXPR__PROP);
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkPrevExpr(PrevExpr prevExpr) {

		checkTypeExists(prevExpr.getDelay());
		Type delayType = AgreeTypeSystem.infer(prevExpr.getDelay());
		checkTypeExists(prevExpr.getInit());
		Type initType = AgreeTypeSystem.infer(prevExpr.getInit());

		if (!AgreeTypeSystem.typesEqual(initType, delayType)) {
			error(prevExpr, "The first and second arguments of the 'prev' function are of non-matching types '"
					+ delayType + "' and '" + initType + "'");
		}

		if (isInLinearizationBody(prevExpr)) {
			error(prevExpr, "'prev' expressions are not allowed in linearization body expressions.");
		}
	}


	public List<Type> typesFromArgs(List<Arg> args) {
		List<Type> types = new ArrayList<Type>();
		for (Arg arg : args) {
			types.add(arg.getType());
		}
		return types;
	}

	public void checkInputsVsActuals(CallExpr call) {
		DoubleDotRef dotId = call.getRef();
		NamedElement namedEl = dotId.getElm();
//		=======
//				public void checkInputsVsActuals(FnCallExpr fnCall) {
//
//			// if the id has a 'tag' then it is using a resrved variable
//
//			NamedElement namedEl = fnCall.getFn().getBase();
//			>>>>>>> origin/develop

		if (!(namedEl instanceof Abstraction)) {
			// this error will be caught elsewhere
			return;
		}

		Abstraction callDef = (Abstraction) namedEl;

		List<Type> inDefTypes;
		String callName;

		// extract in/out arguments
		if (callDef instanceof FnDef) {
			FnDef fnDef = (FnDef) callDef;
			inDefTypes = typesFromArgs(fnDef.getArgs());
			callName = fnDef.getName();
		} else if (callDef instanceof NodeDef) {
			NodeDef nodeDef = (NodeDef) callDef;
			inDefTypes = typesFromArgs(nodeDef.getArgs());
			callName = nodeDef.getName();
		} else if (callDef instanceof LinearizationDef) {
			LinearizationDef linDef = (LinearizationDef) callDef;
			inDefTypes = typesFromArgs(linDef.getArgs());
			callName = linDef.getName();
		} else if (callDef instanceof LibraryFnDef) {
			LibraryFnDef nativeDef = (LibraryFnDef) callDef;
			inDefTypes = typesFromArgs(nativeDef.getArgs());
			callName = nativeDef.getName();
		} else {
			error(call, "Node, function or linearization definition name expected.");
			return;
		}

		// extract args

		List<Type> argCallTypes = new ArrayList<>();
		for (Expr expr : call.getArgs()) {
			checkTypeExists(expr);
			argCallTypes.add(AgreeTypeSystem.infer(expr));
		}

		if (inDefTypes.size() != argCallTypes.size()) {
			error(call, "Function definition '" + callName + "' requires " + inDefTypes.size()
			+ " arguments, but this function call provides " + argCallTypes.size() + " arguments");
			return;
		}

		for (int i = 0; i < inDefTypes.size(); i++) {
			Type callType = argCallTypes.get(i);
			Type defType = inDefTypes.get(i);

			if (!AgreeTypeSystem.typesEqual(defType, callType)) {
				error(call, "Argument " + i + " of function call '" + callName + "' is of type '" + callType
						+ "' but must be of type '" + defType + "'");
			}
		}
	}

	@Check(CheckType.FAST)

	public void checkCallExpr(CallExpr call) {
		NamedElement fn = call.getRef().getElm();
		if (isInLinearizationBody(call)) {
			if (fn instanceof NodeDef) {
				error(call, "Node definitions cannot be applied in a linearization definition");
//				=======
//						public void checkFnCallExpr(FnCallExpr fnCall) {
//					NamedElement fn = (fnCall.getFn().getBase());
//					if (isInLinearizationBody(fnCall)) {
//						if (fn instanceof NodeDefExpr) {
//							error(fnCall, "Node definitions cannot be applied in a linearization definition");
//							>>>>>>> origin/develop
			}
		} else {
			if (fn instanceof LibraryFnDef) {
				if (fn.getElementRoot().getName().equalsIgnoreCase("dreal")) {
					warning(call, "dReal library functions require the use of the dReal solver");
				} else {
					error(call, "Library functions cannot be called from the logic");
				}
			}
		}
		checkInputsVsActuals(call);
	}

	@Check(CheckType.FAST)
	public void checkFnDefExpr(FnDef fnDef) {

		// verify typing
		Type fnType = fnDef.getType();
		if (fnType == null) {
			return; // this error will be caught in parsing
		}

		Type exprType = AgreeTypeSystem.infer(fnDef.getExpr());
		if (!AgreeTypeSystem.typesEqual(exprType, fnType)) {
			error(fnDef, "Function '" + fnDef.getName() + "' is of type '" + typeToString(fnType)
			+ "' but its expression is of type '" + typeToString(exprType) + "'");
		}

	}

	@Check(CheckType.FAST)
	public void checkAbstraction(Abstraction callDef) {

		// don't check recursive calls of functions that have
		// already been walked over
		if (checkedRecCalls.contains(callDef)) {
			return;
		}

		CallRecursionHelper recHelp = new CallRecursionHelper();
		recHelp.doSwitch(callDef);

		for (LinkedList<Abstraction> loop : recHelp.loops) {
			StringBuilder loopStr = new StringBuilder();
			String sep = "";
			for (Abstraction tempAbstraction : loop) {
				checkedRecCalls.add(tempAbstraction);
				String callName = tempAbstraction.getName();
				loopStr.append(sep);
				loopStr.append(callName);
				sep = " -> ";
			}

			error(callDef, "There exists a recursive dependency between the " + "following node or function calls : "
					+ loopStr);

		}
	}

	@Check(CheckType.FAST)
	public void checkIfThenElseExpr(IfThenElseExpr expr) {
		if (isInLinearizationBody(expr)) {
			error(expr, "If-then-else expressions not allowed in linearization body expressions");
			return;
		}

		checkTypeExists(expr.getA());
		Type condType = AgreeTypeSystem.infer(expr.getA());

		checkTypeExists(expr.getB());
		Type thenType = AgreeTypeSystem.infer(expr.getB());

		checkTypeExists(expr.getC());
		Type elseType = AgreeTypeSystem.infer(expr.getC());

		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, condType)) {
			error(expr, "The condition of the if statement is of type '" + condType + "' but must be of type 'bool'");
		}

		if (!AgreeTypeSystem.typesEqual(elseType, thenType)) {
			error(expr, "The 'then' and 'else' expressions are of non-matching types '" + thenType + "' and '"
					+ elseType + "'");
		}
	}

	@Check(CheckType.FAST)
	public void checkPreExpr(PreExpr expr) {
		if (isInLinearizationBody(expr)) {
			error(expr, "'pre' expressions not allowed in linearization body expressions");
		}
	}


	@Check(CheckType.FAST)
	public void checkBinaryExpr(BinaryExpr binExpr) {

		checkTypeExists(binExpr.getLeft());
		checkTypeExists(binExpr.getRight());

		Type typeLeft = AgreeTypeSystem.infer(binExpr.getLeft());
		Type typeRight = AgreeTypeSystem.infer(binExpr.getRight());
		String op = binExpr.getOp();
		Expr rightSide = binExpr.getRight();
		Expr leftSide = binExpr.getLeft();
		boolean isInLinearizationBodyExpr = isInLinearizationBody(binExpr);

		boolean rightSideConst = exprIsConst(rightSide);
		boolean leftSideConst = exprIsConst(leftSide);

		switch (op) {
		case "->":
			if (isInLinearizationBodyExpr) {
				error(binExpr, "Arrow '->' expressions are not allowed in linearization body expressions.");
			} else {
				if (!AgreeTypeSystem.typesEqual(typeRight, typeLeft)) {
					error(binExpr,
							"left and right sides of binary expression '" + op + "' are of type '"
									+ typeToString(typeLeft) + "' and '" + typeToString(typeRight)
									+ "', but must be of the same type");
				}
			}
			return;

		case "=>":
		case "<=>":
		case "and":
		case "or":
			if (isInLinearizationBodyExpr) {
				error(binExpr,
						"Logical expressions (like '" + op + "') are not allowed in linearization body expressions.");
			} else {
				if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, typeLeft)) {
					error(binExpr, "left side of binary expression '" + op + "' is of type '"
							+ typeToString(typeLeft)
							+ "' but must be of " + "type 'bool'");
				}
				if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, typeRight)) {
					error(binExpr, "right side of binary expression '" + op + "' is of type '"
							+ typeToString(typeRight)
							+ "' but must be of" + " type 'bool'");
				}
			}
			return;

		case "=":
		case "<>":
		case "!=":
			if (isInLinearizationBodyExpr) {
				error(binExpr, "Logical comparison expressions (like '" + op
						+ "') are not allowed in linearization body expressions.");
			} else {
				if (!AgreeTypeSystem.typesEqual(typeRight, typeLeft)) {
					error(binExpr,
							"left and right sides of binary expression '" + op + "' are of type '"
									+ typeToString(typeLeft) + "' and '" + typeToString(typeRight)
									+ "', but must be of the same type");
				}
			}
			return;

		case "<":
		case "<=":
		case ">":
		case ">=":
			if (isInLinearizationBodyExpr) {
				error(binExpr, "Comparison expressions (like '" + op
						+ "') are not allowed in linearization body expressions.");
			} else {
				if (!AgreeTypeSystem.typesEqual(typeRight, typeLeft)) {
					error(binExpr,
							"left and right sides of binary expression '" + op + "' are of type '"
									+ typeToString(typeLeft)
									+ "' and '" + typeToString(typeRight) + "', but must be of the same type");
				}
				if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeLeft)
						&& !AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeLeft)) {
					error(binExpr, "left side of binary expression '" + op + "' is of type '" + typeToString(typeLeft)
					+ "' but must be of type" + "'int' or 'real'");
				}
				if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeRight)
						&& !AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeRight)) {
					error(binExpr, "right side of binary expression '" + op + "' is of type '" + typeToString(typeRight)
					+ "' but must be of type" + "'int' or 'real'");
				}
			}
			return;

		case "+":
		case "-":
		case "*":
			if (!AgreeTypeSystem.typesEqual(typeRight, typeLeft)) {
				error(binExpr,
						"left and right sides of binary expression '" + op + "' are of type '" + typeToString(typeLeft)
						+ "' and '" + typeRight + "', but must be of the same type");
			}
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeLeft)
					&& !AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeLeft)) {
				error(binExpr, "left side of binary expression '" + op + "' is of type '" + typeToString(typeLeft)
				+ "' but must be of type" + "'int' or 'real'");
			}
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeRight)
					&& !AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeRight)) {
				error(binExpr, "right side of binary expression '" + op + "' is of type '" + typeToString(typeRight)
				+ "' but must be of type" + "'int' or 'real'");
			}

			if (op.equals("*") && !isInLinearizationBodyExpr) {
				if (!rightSideConst && !leftSideConst) {
					warning(binExpr,
							"neither the right nor the left side of binary expression '" + op
							+ "' is constant'.  Non-linear expressions are allowed only with z3 and dReal."
							+ " With z3 they are not recomended.");
				}
			}
			return;

		case "mod":
		case "div":
			if (isInLinearizationBodyExpr) {
				error(binExpr, "Integer operation expressions (like '" + op
						+ "') are not allowed in linearization body expressions.");
			} else {
				if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeLeft)) {
					error(binExpr, "left side of binary expression '" + op + "' is of type '" + typeToString(typeLeft)
					+ "' but must be of type 'int'");
				}
				if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeRight)) {
					error(binExpr, "right side of binary expression '" + op + "' is of type '" + typeToString(typeRight)
					+ "' but must be of type 'int'");
				}
				if (!rightSideConst) {
					warning(binExpr,
							"right side of binary expression '" + op + "' is not constant."
									+ " Non-linear expressions are allowed only with z3."
									+ " Even with z3 they are not recomended...");
				}
			}
			return;

		case "/":
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeLeft)) {
				error(binExpr, "left side of binary expression '" + op + "' is of type '" + typeToString(typeLeft)
				+ "' but must be of type 'real'");
			}
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeRight)) {
				error(binExpr, "right side of binary expression '" + op + "' is of type '" + typeToString(typeRight)
				+ "' but must be of type 'real'");
			}

			if (!rightSideConst && !isInLinearizationBodyExpr) {
				warning(binExpr,
						"right side of binary expression '" + op + "' is not constant."
								+ " Non-linear expressions are allowed only with z3."
								+ " Even with z3 they are not recomended...");
			}

			return;

		default:
			assert (false);
		}
	}

	public static boolean exprIsConst(Expr expr) {
		if (expr instanceof NamedElmExpr) {
			NamedElement finalId = ((NamedElmExpr) expr).getElm();
			if (finalId instanceof ConstStatement) {
				return true;
			}
		} else if (expr instanceof RealLitExpr || expr instanceof IntLitExpr || expr instanceof BoolLitExpr) {
			return true;
		} else if (expr instanceof BinaryExpr) {
			BinaryExpr binExpr = (BinaryExpr) expr;
			return exprIsConst(binExpr.getLeft()) && exprIsConst(binExpr.getRight());
		} else if (expr instanceof UnaryExpr) {
			UnaryExpr unExpr = (UnaryExpr) expr;
			return exprIsConst(unExpr.getExpr());
		}
		return false;
	}

//																=======
////	// TODO: Don't we need more validation here? What if the Id of the IdExpr
////	private Boolean hasCallDefParent(Element e) {
////		while (e != null) {
////			if (e instanceof CallDef) {
////				return true;
////			}
////			e = e.getOwner();
////		}
////		return false;
////	}
////
////	private void checkScope(Expr expr, NamedElement id) {
////		if (hasCallDefParent(expr)) {
////			if (!hasCallDefParent(id) && !(id instanceof ConstStatement)) {
////				error("Unknown identifier Id: '" + id
////						+ "' (Note that nodes can refer only to inputs, outputs, and local variables and global constants).");
////			}
////		}
////	}
//
//																public static NamedElement getFinalNestId(NestedDotID dotId) {
//																	while (dotId.getSub() != null) {
//																		dotId = dotId.getSub();
//																	}
//
//																	return dotId.getBase();
//																}
//
//																public String getNestedDotIDTag(NestedDotID dotId) {
//																	while (dotId.getSub() != null) {
//																		dotId = dotId.getSub();
//																	}
//
//																	return dotId.getTag();
//																}
//
//																public AgreeType getAgreeType(Arg arg) {
//																	return getAgreeType(arg.getType());
//																}
//
//																private AgreeType getAgreeType(UnaryExpr unaryExpr) {
//																	return getAgreeType(unaryExpr.getExpr());
//																}
//
//
//																private AgreeType getAgreeType(NestedDotID nestDotIdExpr) {
//
//																	String tag = getNestedDotIDTag(nestDotIdExpr);
//
//																	if (tag != null) {
//																		switch (tag) {
//																		case "_CLK":
//																		case "_INSERT":
//																		case "_REMOVE":
//																			return BOOL;
//																		case "_COUNT":
//																			return INT;
//																		default:
//																			return ERROR;
//																		}
//																	}
//
//																	return getAgreeType(getFinalNestId(nestDotIdExpr));
//																}
//
//																protected AgreeType getAgreeType(NamedElement namedEl) {
//																	if (namedEl instanceof DataSubcomponent) {
//																		// this is for checking "Base_Types::Boolean" etc...
//																		ComponentClassifier compClass = ((DataSubcomponent) namedEl).getAllClassifier();
//																		if (compClass instanceof DataImplementation) {
//																			return getAgreeType((DataImplementation) compClass);
//																		}
//																		return getAgreeType(compClass);
//																	} else if (namedEl instanceof Arg) {
//																		return getAgreeType((Arg) namedEl);
//																	} else if (namedEl instanceof ClassifierType || namedEl instanceof Subcomponent) {
//																		return new AgreeType("component");
//																	} else if (namedEl instanceof PropertyStatement) {
//																		return getAgreeType((PropertyStatement) namedEl);
//																	} else if (namedEl instanceof ConstStatement) {
//																		return getAgreeType((ConstStatement) namedEl);
//																	} else if (namedEl instanceof EqStatement) {
//																		return getAgreeType(namedEl);
//																	} else if (namedEl instanceof DataPort) {
//																		return getAgreeType(((DataPort) namedEl).getDataFeatureClassifier());
//																	} else if (namedEl instanceof EventDataPort) {
//																		return getAgreeType(((EventDataPort) namedEl).getDataFeatureClassifier());
//																	} else if (namedEl instanceof DataAccess) {
//																		return getAgreeType((NamedElement) ((DataAccess) namedEl).getFeatureClassifier());
//																	} else if (namedEl instanceof DataType) {
//																		return getAgreeType((ComponentClassifier) namedEl);
//																	} else if (namedEl instanceof DataImplementation) {
//																		return getAgreeType((DataImplementation) namedEl);
//																	} else if (namedEl instanceof NamedID) {
//																		return getAgreeType((NamedID) namedEl);
//																	}
//
//																	return ERROR;
//																}
//
//																private AgreeType getAgreeType(NamedID id) {
//																	EObject container = id.eContainer();
//																	if (!(container instanceof EnumStatement)) {
//																		throw new IllegalArgumentException("NamedIDs allowed only in enum statements.");
//																	}
//																	return getAgreeType((EnumStatement) container);
//																}
//
//																private AgreeType getAgreeType(EnumStatement statement) {
//																	String name = statement.getName();
//																	EObject container = statement.eContainer();
//
//																	while (!(container instanceof AadlPackage)) {
//																		if (container instanceof ComponentClassifier) {
//																			name = ((ComponentClassifier) container).getName() + "::" + name;
//																		}
//																		container = container.eContainer();
//																	}
//																	name = ((AadlPackage) container).getName() + "::" + name;
//																	return new AgreeType(name);
//																}
//
//																private AgreeType getAgreeType(DataImplementation dataImpl) {
//
//																	AgreeType nativeType = getNativeType(dataImpl);
//																	if (nativeType != null) {
//																		return nativeType;
//																	}
//
//																	AadlPackage aadlPack = (AadlPackage) dataImpl.eContainer().eContainer();
//
//																	String typeStr = aadlPack.getName() + "::" + dataImpl.getName();
//
//																	return new AgreeType(typeStr);
//																}
//
//																private AgreeType getNativeType(DataImplementation dataImpl) {
//																	EList<Subcomponent> subComps = dataImpl.getAllSubcomponents();
//																	// if there are no subcomponents, use the component type
//																	if (subComps.size() == 0) {
//																		return getAgreeType((ComponentClassifier) dataImpl.getType());
//																	}
//																	return null;
//																}
//
//																private AgreeType getAgreeType(ComponentClassifier dataClass) {
//
//																	while (dataClass != null) {
//																		switch (dataClass.getQualifiedName()) {
//																		case "Base_Types::Boolean":
//																			return BOOL;
//																		case "Base_Types::Integer":
//																			return INT;
//																		case "Base_Types::Float":
//																			return REAL;
//																		}
//
//																		boolean is_aadl_enum = AgreeAADLEnumerationUtils.isAADLEnumeration(dataClass);
//																		if (is_aadl_enum) {
//																			String name = dataClass.getName();
//																			EObject container = dataClass.eContainer();
//
//																			while (!(container instanceof AadlPackage)) {
//																				if (container instanceof ComponentClassifier) {
//																					name = ((ComponentClassifier) container).getName() + "::" + name;
//																				}
//																				container = container.eContainer();
//																			}
//																			name = ((AadlPackage) container).getName() + "::" + name;
//																			return new AgreeType(name);
//																		}
//
//																		DataType dataType = (DataType) dataClass;
//																		dataClass = dataType.getExtended();
//																	}
//
//																	return ERROR;
//																}
//
//																private AgreeType getAgreeType(ComponentType compType) {
//
//																	while (compType.getExtended() != null) {
//																		compType = compType.getExtended();
//																	}
//
//																	String qualName = compType.getQualifiedName();
//																	switch (qualName) {
//																	case "Base_Types::Boolean":
//																		return BOOL;
//																	case "Base_Types::Integer":
//																		return INT;
//																	case "Base_Types::Float":
//																		return REAL;
//																	}
//
//																	return new AgreeType(qualName);
//
//																}
//
//																private AgreeType getAgreeType(DataSubcomponentType data) {
//																	if (data instanceof DataType) {
//																		ComponentType compType = ((DataType) data).getExtended();
//																		if (compType != null && !AgreeAADLEnumerationUtils.isAADLEnumeration(data)) {
//																			return getAgreeType(compType);
//																		}
//																	}
//																	String qualName = data.getQualifiedName();
//																	if (qualName == null) {
//																		return ERROR;
//																	}
//																	switch (qualName) {
//																	case "Base_Types::Boolean":
//																		return BOOL;
//																	case "Base_Types::Integer":
//																		return INT;
//																	case "Base_Types::Float":
//																		return REAL;
//																	}
//																	return new AgreeType(qualName);
//																}
//
//																private AgreeType getAgreeType(PropertyStatement propStat) {
//																	return getAgreeType(propStat.getExpr());
//																}
//
//																private AgreeType getAgreeType(ConstStatement constStat) {
//																	return getAgreeType(constStat.getType());
//																}
//
//																private AgreeType getAgreeType(GetPropertyExpr getPropExpr) {
//																	NamedElement namedEl = getPropExpr.getProp();
//																	if ((namedEl instanceof Property) || namedEl instanceof PropertyConstant) {
//																		PropertyType propType;
//																		if (namedEl instanceof Property) {
//																			propType = ((Property) namedEl).getPropertyType();
//																		} else {
//																			propType = ((PropertyConstant) namedEl).getPropertyType();
//																		}
//
//																		if (propType instanceof AadlBoolean) {
//																			return BOOL;
//																		} else if (propType instanceof AadlString || propType instanceof EnumerationType) {
//																			return new AgreeType("string");
//																		} else if (propType instanceof AadlInteger) {
//																			return INT;
//																		} else if (propType instanceof AadlReal) {
//																			return REAL;
//																		} else if (propType instanceof ClassifierType) {
//																			return new AgreeType("component");
//																		}
//																	}
//																	return ERROR;
//																}
//
//																private AgreeType getAgreeType(PrevExpr prevExpr) {
//																	return getAgreeType(prevExpr.getDelay());
//																}
//
//																private List<AgreeType> getAgreeTypes(List<? extends Expr> exprs) {
//																	ArrayList<AgreeType> list = new ArrayList<>();
//																	for (Expr expr : exprs) {
//																		list.add(getAgreeType(expr));
//																	}
//																	return list;
//																}
//
//																public List<AgreeType> typesFromArgs(List<Arg> args) {
//																	ArrayList<AgreeType> list = new ArrayList<>();
//																	for (Arg arg : args) {
//																		list.add(getAgreeType(arg));
//																	}
//																	return list;
//																}
//
//																private AgreeType getAgreeType(FnCallExpr fnCall) {
//																	// TODO: Examine type system in more detail
//																	// TODO: Fix to make support type lists.
//
//																	NamedElement namedEl = fnCall.getFn().getBase();
//
//																	if (isInLinearizationBody(fnCall)) {
//																		// extract in/out arguments
//																		if (namedEl instanceof FnDefExpr || namedEl instanceof NodeDefExpr) {
//																			error(fnCall, "Calls to AGREE nodes and functions not allowed in linearization bodies");
//																			return ERROR;
//																		} else if (namedEl instanceof LinearizationDefExpr) {
//																			return REAL;
//																		} else if (namedEl instanceof LibraryFnDefExpr) {
//																			LibraryFnDefExpr fnDef = (LibraryFnDefExpr) namedEl;
//																			return getAgreeType(fnDef.getType());
//																		} else {
//																			error(fnCall, "Node, function or linearization definition name expected.");
//																			return ERROR;
//																		}
//
//																	} else {
//																		// extract in/out arguments
//																		if (namedEl instanceof FnDefExpr) {
//																			FnDefExpr fnDef = (FnDefExpr) namedEl;
//																			return getAgreeType(fnDef.getType());
//																		} else if (namedEl instanceof NodeDefExpr) {
//																			NodeDefExpr nodeDef = (NodeDefExpr) namedEl;
//																			List<AgreeType> outDefTypes = typesFromArgs(nodeDef.getRets());
//																			if (outDefTypes.size() == 1) {
//																				return outDefTypes.get(0);
//																			} else {
//																				error(fnCall, "Nodes embedded in expressions must have exactly one return value." + "  Node "
//																						+ nodeDef.getName() + " contains " + outDefTypes.size() + " return values");
//																				return ERROR;
//																			}
//																		} else if (namedEl instanceof LinearizationDefExpr) {
//																			return REAL;
//																		} else if (namedEl instanceof LibraryFnDefExpr) {
//																			LibraryFnDefExpr fnDef = (LibraryFnDefExpr) namedEl;
//																			return getAgreeType(fnDef.getType());
//																		} else {
//																			error(fnCall, "Node, function or linearization definition name expected.");
//																			return ERROR;
//																		}
//																	}
//																}
//
//																private AgreeType getAgreeType(BinaryExpr binExpr) {
//																	AgreeType typeLeft = getAgreeType(binExpr.getLeft());
//																	String op = binExpr.getOp();
//
//																	switch (op) {
//																	case "->":
//																		return typeLeft;
//																	case "=>":
//																	case "<=>":
//																	case "and":
//																	case "or":
//																		return BOOL;
//																	case "<>":
//																	case "!=":
//																		return BOOL;
//																	case "<":
//																	case "<=":
//																	case ">":
//																	case ">=":
//																	case "=":
//																		return BOOL;
//																	case "+":
//																	case "-":
//																	case "*":
//																	case "/":
//																	case "mod":
//																	case "div":
//																	case "^":
//																		return typeLeft;
//																	}
//
//																	return ERROR;
//																}
//
//																protected AgreeType getAgreeType(Expr expr) {
//																	if (expr instanceof BinaryExpr) {
//																		return getAgreeType((BinaryExpr) expr);
//																	} else if (expr instanceof FnCallExpr) {
//																		return getAgreeType((FnCallExpr) expr);
//																	} else if (expr instanceof IfThenElseExpr) {
//																		return getAgreeType(expr);
//																	} else if (expr instanceof PrevExpr) {
//																		return getAgreeType((PrevExpr) expr);
//																	} else if (expr instanceof GetPropertyExpr) {
//																		return getAgreeType((GetPropertyExpr) expr);
//																	} else if (expr instanceof DoubleDotRef) {
//																		return getAgreeType((DoubleDotRef) expr);
//																	} else if (expr instanceof NestedDotID) {
//																		return getAgreeType((NestedDotID) expr);
//																	} else if (expr instanceof NestedDotID) {
//																		return getAgreeType((NestedDotID) expr);
//																	} else if (expr instanceof UnaryExpr) {
//																		return getAgreeType((UnaryExpr) expr);
//																	} else if (expr instanceof IntLitExpr) {
//																		return INT;
//																	} else if (expr instanceof RealLitExpr) {
//																		return REAL;
//																	} else if (expr instanceof BoolLitExpr) {
//																		return BOOL;
//																	} else if (expr instanceof ThisExpr) {
//																		return new AgreeType("component");
//																	} else if (expr instanceof PreExpr) {
//																		return getAgreeType(((PreExpr) expr).getExpr());
//																	} else if (expr instanceof RecordExpr) {
//																		return getAgreeType((RecordExpr) expr);
//																	} else if (expr instanceof RecordUpdateExpr) {
//																		return getAgreeType((RecordUpdateExpr) expr);
//																	} else if (expr instanceof FloorCast) {
//																		return INT;
//																	} else if (expr instanceof RealCast) {
//																		return REAL;
//																	} else if (expr instanceof EventExpr) {
//																		return BOOL;
//																	} else if (expr instanceof TimeExpr) {
//																		return REAL;
//																	} else if (expr instanceof AADLEnumerator) {
//																		return getAgreeType((AADLEnumerator) expr);
//																	} else if (expr instanceof LatchedExpr) {
//																		return getAgreeType(((LatchedExpr) expr).getExpr());
//																	} else if (expr instanceof TimeOfExpr || expr instanceof TimeRiseExpr || expr instanceof TimeFallExpr) {
//																		return REAL;
//																	} /*
//																	 * else if (expr instanceof UnaryNonLinearExpr ||
//																	 * expr instanceof BinaryNonLinearExpr) {
//																	 * return REAL;
//																	 * }
//																	 */
//
//																	return ERROR;
//																}
//
//																private AgreeType getAgreeType(AADLEnumerator enumExpr) {
//																	return getAgreeType(enumExpr.getEnumType());
//																}
//
//																private AgreeType getAgreeType(DoubleDotRef DoubleDotRef) {
//																	return getAgreeType(DoubleDotRef.getElm());
//																}
//
//																private AgreeType getAgreeType(RecordUpdateExpr upExpr) {
//																	return getAgreeType(upExpr.getRecord());
//																}
//
//																private AgreeType getAgreeType(RecordExpr recExpr) {
//																	return getNamedElmAsType(recExpr.getRecord().getElm());
//																}
//
//																public static boolean matches(AgreeType expected, AgreeType actual) {
//																	if (expected.equals(ERROR) || actual.equals(ERROR)) {
//																		return false;
//																	} else if (integerMatch(expected, actual)) {
//																		return true;
//																	} else if (floatingPointMatch(expected, actual)) {
//																		return true;
//																	}
//																	return expected.equals(actual);
//																}
//
//																private static boolean floatingPointMatch(AgreeType expected, AgreeType actual) {
//																	if (expected.toString().equals("real") && actual.toString().startsWith("Base_Types::Float")) {
//																		return true;
//																	}
//																	if (actual.toString().equals("real") && expected.toString().startsWith("Base_Types::Float")) {
//																		return true;
//																	}
//																	return false;
//																}
//
//																private static boolean integerMatch(AgreeType expected, AgreeType actual) {
//																	if (expected.toString().equals("int") && actual.toString().startsWith("Base_Types::Integer")) {
//																		return true;
//																	}
//																	if (actual.toString().equals("int") && expected.toString().startsWith("Base_Types::Integer")) {
//																		return true;
//																	}
//																	return false;
//																}
//																>>>>>>> origin/develop
}
