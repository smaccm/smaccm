/*
 * generated by Xtext
 */
package com.rockwellcollins.atc.agree.validation;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.osate.aadl2.AadlPackage;
import org.osate.aadl2.AnnexLibrary;
import org.osate.aadl2.AnnexSubclause;
import org.osate.aadl2.Classifier;
import org.osate.aadl2.ComponentClassifier;
import org.osate.aadl2.ComponentImplementation;
import org.osate.aadl2.ComponentType;
import org.osate.aadl2.Connection;
import org.osate.aadl2.DataImplementation;
import org.osate.aadl2.DataPort;
import org.osate.aadl2.DataSubcomponent;
import org.osate.aadl2.DataType;
import org.osate.aadl2.DirectionType;
import org.osate.aadl2.EventDataPort;
import org.osate.aadl2.EventPort;
import org.osate.aadl2.Feature;
import org.osate.aadl2.FeatureGroup;
import org.osate.aadl2.FeatureGroupType;
import org.osate.aadl2.NamedElement;
import org.osate.aadl2.Port;
import org.osate.aadl2.Property;
import org.osate.aadl2.PropertyConstant;
import org.osate.aadl2.Subcomponent;
import org.osate.aadl2.impl.SubcomponentImpl;
import org.osate.annexsupport.AnnexUtil;

import com.rockwellcollins.atc.agree.AgreeAADLEnumerationUtils;
import com.rockwellcollins.atc.agree.AgreeTypeSystem;
import com.rockwellcollins.atc.agree.AgreeTypeSystem.ArrayDef;
import com.rockwellcollins.atc.agree.agree.Abstraction;
import com.rockwellcollins.atc.agree.agree.AbstractionRef;
import com.rockwellcollins.atc.agree.agree.AgreeContract;
import com.rockwellcollins.atc.agree.agree.AgreePackage;
import com.rockwellcollins.atc.agree.agree.AgreeSubclause;
import com.rockwellcollins.atc.agree.agree.Arg;
import com.rockwellcollins.atc.agree.agree.ArrayLiteralExpr;
import com.rockwellcollins.atc.agree.agree.ArraySubExpr;
import com.rockwellcollins.atc.agree.agree.ArrayType;
import com.rockwellcollins.atc.agree.agree.ArrayUpdateExpr;
import com.rockwellcollins.atc.agree.agree.AssertStatement;
import com.rockwellcollins.atc.agree.agree.AssignStatement;
import com.rockwellcollins.atc.agree.agree.AssumeStatement;
import com.rockwellcollins.atc.agree.agree.AsynchStatement;
import com.rockwellcollins.atc.agree.agree.BinaryExpr;
import com.rockwellcollins.atc.agree.agree.BoolLitExpr;
import com.rockwellcollins.atc.agree.agree.CalenStatement;
import com.rockwellcollins.atc.agree.agree.CallExpr;
import com.rockwellcollins.atc.agree.agree.ComponentRef;
import com.rockwellcollins.atc.agree.agree.ConnectionStatement;
import com.rockwellcollins.atc.agree.agree.ConstStatement;
import com.rockwellcollins.atc.agree.agree.CustomType;
import com.rockwellcollins.atc.agree.agree.EnumID;
import com.rockwellcollins.atc.agree.agree.EnumLitExpr;
import com.rockwellcollins.atc.agree.agree.EnumStatement;
import com.rockwellcollins.atc.agree.agree.EqStatement;
import com.rockwellcollins.atc.agree.agree.EventExpr;
import com.rockwellcollins.atc.agree.agree.Expr;
import com.rockwellcollins.atc.agree.agree.FloorCast;
import com.rockwellcollins.atc.agree.agree.FnDef;
import com.rockwellcollins.atc.agree.agree.GetPropertyExpr;
import com.rockwellcollins.atc.agree.agree.GuaranteeStatement;
import com.rockwellcollins.atc.agree.agree.IfThenElseExpr;
import com.rockwellcollins.atc.agree.agree.InitialStatement;
import com.rockwellcollins.atc.agree.agree.InputStatement;
import com.rockwellcollins.atc.agree.agree.IntLitExpr;
import com.rockwellcollins.atc.agree.agree.LatchedExpr;
import com.rockwellcollins.atc.agree.agree.LatchedStatement;
import com.rockwellcollins.atc.agree.agree.LemmaStatement;
import com.rockwellcollins.atc.agree.agree.LibraryFnDef;
import com.rockwellcollins.atc.agree.agree.LiftStatement;
import com.rockwellcollins.atc.agree.agree.LinearizationDef;
import com.rockwellcollins.atc.agree.agree.LinearizationInterval;
import com.rockwellcollins.atc.agree.agree.MNSynchStatement;
import com.rockwellcollins.atc.agree.agree.NamedElmExpr;
import com.rockwellcollins.atc.agree.agree.NodeBodyExpr;
import com.rockwellcollins.atc.agree.agree.NodeDef;
import com.rockwellcollins.atc.agree.agree.NodeEq;
import com.rockwellcollins.atc.agree.agree.NodeLemma;
import com.rockwellcollins.atc.agree.agree.NodeStmt;
import com.rockwellcollins.atc.agree.agree.OrderStatement;
import com.rockwellcollins.atc.agree.agree.PeriodicStatement;
import com.rockwellcollins.atc.agree.agree.PreExpr;
import com.rockwellcollins.atc.agree.agree.PrevExpr;
import com.rockwellcollins.atc.agree.agree.PrimType;
import com.rockwellcollins.atc.agree.agree.ProjectionExpr;
import com.rockwellcollins.atc.agree.agree.PropertyStatement;
import com.rockwellcollins.atc.agree.agree.RealCast;
import com.rockwellcollins.atc.agree.agree.RealLitExpr;
import com.rockwellcollins.atc.agree.agree.RecordDef;
import com.rockwellcollins.atc.agree.agree.RecordLitExpr;
import com.rockwellcollins.atc.agree.agree.RecordUpdateExpr;
import com.rockwellcollins.atc.agree.agree.SpecStatement;
import com.rockwellcollins.atc.agree.agree.SporadicStatement;
import com.rockwellcollins.atc.agree.agree.SubcomponentRef;
import com.rockwellcollins.atc.agree.agree.SynchStatement;
import com.rockwellcollins.atc.agree.agree.TagExpr;
import com.rockwellcollins.atc.agree.agree.ThisRef;
import com.rockwellcollins.atc.agree.agree.TimeFallExpr;
import com.rockwellcollins.atc.agree.agree.TimeInterval;
import com.rockwellcollins.atc.agree.agree.TimeOfExpr;
import com.rockwellcollins.atc.agree.agree.TimeRiseExpr;
import com.rockwellcollins.atc.agree.agree.Type;
import com.rockwellcollins.atc.agree.agree.UnaryExpr;
import com.rockwellcollins.atc.agree.agree.WhenHoldsStatement;
import com.rockwellcollins.atc.agree.agree.WhenOccursStatment;
import com.rockwellcollins.atc.agree.agree.WheneverBecomesTrueStatement;
import com.rockwellcollins.atc.agree.agree.WheneverHoldsStatement;
import com.rockwellcollins.atc.agree.agree.WheneverImpliesStatement;
import com.rockwellcollins.atc.agree.agree.WheneverOccursStatement;
import com.rockwellcollins.atc.agree.visitors.ExprCycleVisitor;

/**
 * Custom validation rules.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
public class AgreeJavaValidator extends AbstractAgreeJavaValidator {
	private final Set<Abstraction> checkedRecCalls = new HashSet<>();
	private final Map<String, Map<String, EnumID>> enumSets = new HashMap<>();

	@Override
	protected boolean isResponsible(Map<Object, Object> context, EObject eObject) {
		return (eObject.eClass().getEPackage() == AgreePackage.eINSTANCE) || eObject instanceof AadlPackage;
	}

//	@Inject
//	IResourceDescriptions resourceDescriptions;
//
//	@Check(CheckType.FAST)
//	public void checkAADL2Package(AadlPackage pack){
//		Resource resource = pack.eResource();
//		ResourceSet resources = resource.getResourceSet();
//		for(Resource subRes : resources.getResources()){
//			TreeIterator<EObject> contents = subRes.getAllContents();
//			if(contents.hasNext()){
//				EObject obj = contents.next();
//				if(obj instanceof AadlPackage){
//					List<AnnexLibrary> agreeAnnex = AnnexUtil.getAllActualAnnexLibraries((AadlPackage) obj, AgreePackage.eINSTANCE.getAgreeContractLibrary());
//				}
//			}
//			while(contents.hasNext()){
//				EObject obj = contents.next();
//			}
//			System.out.println();
//		}
//
//		String contextProject = pack.eResource().getURI().segment(1);
//		for (IResourceDescription resourceDescription : resourceDescriptions.getAllResourceDescriptions()) {
//			for (IEObjectDescription eobjectDescription : resourceDescription.getExportedObjectsByType(Aadl2Package.eINSTANCE.getAadlPackage())) {
//				EObject description = eobjectDescription.getEObjectOrProxy();
//				System.out.println();
//			}
//		}
//	}
//
//	private Map<String, List<NamedElement>> getAllIdToElementMap(AgreeContract contract){
//
//		for(SpecStatement spec : contract.getSpecs()){
//			if (spec instanceof )
//		}
//
//		return null;
//	}

	@Check(CheckType.FAST)
	public void checkEnumStatement(EnumStatement statement) {
		String contextProject = statement.eResource().getURI().segment(1);
		Map<String, EnumID> enumMap;
		if (!enumSets.containsKey(contextProject)) {
			enumMap = new HashMap<>();
			enumSets.put(contextProject, enumMap);
		} else {
			enumMap = enumSets.get(contextProject);
		}

		for (EnumID id : statement.getEnums()) {
			EnumID otherEnum = enumMap.get(id.getName());
			if (otherEnum == null) {
				enumMap.put(id.getName(), id);
			} else if (otherEnum != id) {
				if (otherEnum.eResource() != null && otherEnum.eResource().equals(id.eResource())) {

					String message = "Multiple uses of the same enum value '" + id.getName() + "' in '"
							+ getEnumValueDefLocation(otherEnum) + "' and '" + getEnumValueDefLocation(id) + "'";
					error(otherEnum, message);
					error(id, message);
				} else {
					enumMap.put(id.getName(), id);
				}
			}
		}
		EObject container = statement.eContainer();
		while (!(container instanceof AadlPackage) && !(container instanceof ComponentClassifier)) {
			container = container.eContainer();
		}
		if (!(container instanceof AadlPackage)) {
			error(statement, "Enumerations can be defined only in AADL packages");
		}

	}

	private String getEnumValueDefLocation(EnumID id) {
		EObject container = id.eContainer();
		EnumStatement enumStatement = (EnumStatement) container;
		String enumName = enumStatement.getName();
		while (!(container instanceof AadlPackage) && !(container instanceof ComponentClassifier)) {
			container = container.eContainer();
		}
		return ((NamedElement) container).getQualifiedName() + "::" + enumName;
	}

	@Check(CheckType.FAST)
	public void checkConnectionStatement(ConnectionStatement conn) {
		Classifier container = conn.getContainingClassifier();
		if (container instanceof ComponentImplementation) {
			NamedElement aadlConn = conn.getConn();
			if (aadlConn == null) {
				return;
			}
			if (!(aadlConn instanceof Connection)) {
				error(conn, "The connection label in the connection statement is not a connection");
				return;
			}

		} else {
			error(conn, "Connection statements are allowed only in component implementations.");
		}
	}

	@Check(CheckType.FAST)
	public void checkOrderStatement(OrderStatement order) {
		Classifier container = order.getContainingClassifier();
		if (container instanceof ComponentImplementation) {
			ComponentImplementation compImpl = (ComponentImplementation) container;

			for (int index = 0; index < order.getComps().size(); ++index) {
				NamedElement comp = order.getComps().get(index);
				if (!(comp instanceof Subcomponent)
						|| !((Subcomponent) comp).getContainingComponentImpl().equals(container)) {
					error("Element '" + comp.getName() + "' is not a subcomponent of '" + container.getName() + "'",
							order, AgreePackage.Literals.ORDER_STATEMENT__COMPS, index);
				}
			}

			List<NamedElement> notPresent = new ArrayList<>();
			for (Subcomponent subcomp : compImpl.getAllSubcomponents()) {
				boolean found = false;
				for (NamedElement el : order.getComps()) {
					if (el.equals(subcomp)) {
						found = true;
						break;
					}
				}
				if (!found) {
					notPresent.add(subcomp);
				}
			}

			if (notPresent.size() != 0) {
				String delim = "";
				StringBuilder errorStr = new StringBuilder(
						"The following subcomponents are not present in the ordering: ");
				for (NamedElement subcomp : notPresent) {
					errorStr.append(delim);
					errorStr.append(subcomp.getName());
					delim = ", ";
				}
				error(order, errorStr.toString());
			}

		} else {
			error(order, "Ordering statements can appear only in component implementations");
		}

	}

	private static List<Feature> flattenFeatureGroups(List<? extends Feature> complexFeatures) {
		List<Feature> result = new ArrayList<>();
		for (Feature feature : complexFeatures) {
			if (feature instanceof FeatureGroup) {
				FeatureGroup featureGroup = (FeatureGroup) feature;
				FeatureGroupType featType = featureGroup.getFeatureGroupType();
				result.addAll(flattenFeatureGroups(featType.getOwnedFeatureGroups()));
				result.addAll(flattenFeatureGroups(featType.getOwnedDataPorts()));
				result.addAll(flattenFeatureGroups(featType.getOwnedEventDataPorts()));
				result.addAll(flattenFeatureGroups(featType.getOwnedEventPorts()));
			} else {
				result.add(feature);
			}
		}
		return result;
	}

	@Check(CheckType.FAST)
	public void checkAssign(AssignStatement assign) {

		if (!(assign.getId() instanceof NamedElement)) {
			error(assign.getId(),
					"The Id on the left hand side of an assignment statement " + "must not contain a \".\"");
			return;
		}
		NamedElement namedEl = assign.getId();
		Expr expr = assign.getExpr();

		if (namedEl == null || expr == null) {
			return;
		}

		ComponentImplementation compImpl = EcoreUtil2.getContainerOfType(assign, ComponentImplementation.class);

		if (compImpl == null) {
			error(assign, "Assignment statements are allowed only in component implementations");
			return;
		}



		if (namedEl.eContainer() instanceof InputStatement) {
			error(assign, "Assignment to agree_input variables is illegal.");
			return;
		}

		if (compImpl != null) {
			List<EObject> assignableElements = new ArrayList<>();
			List<AgreeContract> implContracts = EcoreUtil2.getAllContentsOfType(compImpl, AgreeContract.class);
			for (AgreeContract ac : implContracts) {
				assignableElements.addAll(EcoreUtil2.getAllContentsOfType(ac, EqStatement.class).stream()
						.map(eq -> eq.getLhs()).flatMap(List::stream).collect(Collectors.toList()));
			}
			ComponentType compType = compImpl.getType();
			if (compType != null) {
				List<AgreeContract> typeContracts = EcoreUtil2.getAllContentsOfType(compType, AgreeContract.class);
				for (AgreeContract ac : typeContracts) {
					assignableElements.addAll(EcoreUtil2.getAllContentsOfType(ac, EqStatement.class).stream()
							.map(eq -> eq.getLhs()).flatMap(List::stream).collect(Collectors.toList()));
				}
			}
			assignableElements.addAll(compImpl.getAllFeatures().stream()
					.map(cf -> flattenFeatureGroups(Collections.singletonList(cf))).flatMap(List::stream)
					.filter(feat -> feat instanceof EventDataPort || feat instanceof DataPort)
					.filter(feat -> DirectionType.OUT.equals(((Port) feat).getDirection()))
					.collect(Collectors.toList()));
			if (!assignableElements.contains(namedEl)) {
				error("LHS of assignment must be an AGREE 'eq' variable or an output port of this component", assign,
						AgreePackage.Literals.ASSIGN_STATEMENT__ID);
			}
		}

		String lhsType = namedEl.getName();
		String rhsType = AgreeTypeSystem.typeToString(AgreeTypeSystem.infer(expr));

		if (!lhsType.equals(rhsType)) {
			error(assign, "The left hand side of the assignment statement is of type '" + lhsType
					+ "' but the right hand side is of type '" + rhsType + "'");
		}

		AgreeContract contract = EcoreUtil2.getContainerOfType(assign, AgreeContract.class);
		if (contract != null) {
			for (SpecStatement spec : contract.getSpecs()) {
				if (spec instanceof AssignStatement && spec != assign) {
					NamedElement otherEl = ((NamedElmExpr) ((AssignStatement) spec).getId()).getNamedElm();
					if (otherEl.equals(namedEl)) {
						error(spec, "Mulitiple assignments to variable '" + namedEl.getName() + "'");
						error(assign, "Mulitiple assignments to variable '" + namedEl.getName() + "'");
					}
				}
			}
		}

	}

	@Check(CheckType.FAST)
	public void checkArg(Arg arg) {
		Type type = arg.getType();
		if (type instanceof PrimType) {
			PrimType primType = (PrimType) type;
			String strType = primType.getName();
			String rangeLow = primType.getRangeLow();
			String rangeHigh = primType.getRangeHigh();

			if (rangeLow != null && rangeHigh != null) {

				// this is a ranged argument. It can show up only in an equation statement
				EObject container = arg.eContainer();
				if (!(container instanceof EqStatement || container instanceof InputStatement)) {
					error(arg, "Ranged arguments can appear only in equation statements or agree_input statements");
				}

				boolean rangeLowDot = rangeLow.contains(".");
				boolean rangeHighDot = rangeHigh.contains(".");

				if (rangeLowDot != rangeHighDot) {
					error(arg, "The range intervals are of differing types");
				}

				if (strType.equals("int") && (rangeLowDot || rangeHighDot)) {
					error(arg, "Ranged variable of type 'int' contains a 'real' value in its interval");
				}

				if (strType.equals("real") && (!rangeLowDot || !rangeHighDot)) {
					error(arg, "Ranged variable of type 'real' contains an 'int' value in its interval");
				}

				float low = Float.valueOf(rangeLow);
				float high = Float.valueOf(rangeHigh);

				low *= primType.getLowNeg() == null ? 1.0 : -1.0;
				high *= primType.getHighNeg() == null ? 1.0 : -1.0;

				if (low >= high) {
					error(arg, "The low value of the interval is greater than or equal to the high end");
				}
			}

		}
	}

	@Check(CheckType.FAST)
	public void checkCalenStatement(CalenStatement calen) {
		Classifier container = calen.getContainingClassifier();
		if (!(container instanceof ComponentImplementation)) {
			error(calen, "Calendar statements can appear only in component implementations");
			return;
		}

		for (int index = 0; index < calen.getEls().size(); ++index) {
			NamedElement el = calen.getEls().get(index);
			if (!(el instanceof Subcomponent) || !((Subcomponent) el).getContainingComponentImpl().equals(container)) {
				error("Element '" + el.getName() + "' is not a subcomponent of '" + container.getName() + "'",
						calen, AgreePackage.Literals.CALEN_STATEMENT__ELS, index);
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkFloorCast(FloorCast floor) {
		if (isInLinearizationBody(floor)) {
			error(floor, "'event' expressions not allowed in linearization body expressions");
			return;
		}
		checkTypeExists(floor.getExpr());
		Type exprType = AgreeTypeSystem.infer(floor.getExpr());

		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
			error(floor, "Argument of floor cast is of type '" + AgreeTypeSystem.typeToString(exprType)
			+ "' but must be of type 'real'");
		}
	}

	@Check(CheckType.FAST)
	public void checkRealCast(RealCast real) {
		if (isInLinearizationBody(real)) {
			error(real, "'event' expressions not allowed in linearization body expressions");
			return;
		}

		checkTypeExists(real.getExpr());
		Type exprType = AgreeTypeSystem.infer(real.getExpr());

		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, exprType)) {
			error(real, "Argument of real cast is of type '" + AgreeTypeSystem.typeToString(exprType)
			+ "' but must be of type 'int'");
		}
	}

	@Check(CheckType.FAST)
	public void checkEventExpr(EventExpr event) {
		if (isInLinearizationBody(event)) {
			error(event, "'event' expressions not allowed in linearization body expressions");
			return;
		}

		NamedElement namedEl = null;
		if (event.getId() instanceof NamedElmExpr) {
			namedEl = ((NamedElmExpr) event.getId()).getNamedElm();
		} else if (event.getId() instanceof ProjectionExpr) {
			namedEl = ((ProjectionExpr) event.getId()).getField();

		}
		if (!(namedEl instanceof EventPort || namedEl instanceof EventDataPort)) {
			error(event, "Argument of event expression must be an event port or event data port");
		}
	}

	@Check(CheckType.FAST)
	public void checkLatchedExpr(LatchedExpr latched) {

		// get container
		EObject container = latched.eContainer();
		AgreeContract contract = null;
		while (!(container instanceof ComponentClassifier)) {
			if (container instanceof AgreeContract) {
				contract = (AgreeContract) container;
			}
			container = container.eContainer();
		}

		if (container instanceof ComponentImplementation) {
			boolean foundLatchedStatement = false;
			for (SpecStatement spec : contract.getSpecs()) {
				if (spec instanceof LatchedStatement) {
					foundLatchedStatement = true;
					break;
				}
			}
			if (!foundLatchedStatement) {
				error(latched, "Latched expressions can appear only in component implementations "
						+ "that contain a latched synchrony statement");
			}
		} else {
			error(latched, "Latched expressions can appear only in component implementations");
		}

		Expr expr = latched.getExpr();
		NamedElmExpr nestId = null;
		if (expr instanceof NamedElmExpr) {
			nestId = (NamedElmExpr) expr;
		} else if (expr instanceof EventExpr) {
			EventExpr eventExpr = (EventExpr) expr;
			nestId = (NamedElmExpr) eventExpr.getId();
		}

		if (nestId != null) {
			NamedElement namedEl = nestId.getNamedElm();
			if ((namedEl instanceof DataPort) && ((DataPort) namedEl).isIn()) {
				return;
			} else if ((namedEl instanceof EventDataPort) && ((EventDataPort) namedEl).isIn()) {
				return;
			} else {
				// check to see if it is an "agree_input"
				EObject namedElContainer = namedEl.eContainer();
				if (namedElContainer instanceof InputStatement) {
					return;
				}
			}
		}

		error(latched,
				"Latched expressions are valid only for input data ports or event expressions over input event data ports");
	}

	@Check(CheckType.FAST)
	public void checkSynchStatement(SynchStatement sync) {

		Classifier container = sync.getContainingClassifier();
		if (!(container instanceof ComponentImplementation)) {
			error(sync, "Synchrony statements can appear only in component implementations");
		}

		if (sync instanceof CalenStatement || sync instanceof MNSynchStatement || sync instanceof AsynchStatement
				|| sync instanceof LatchedStatement) {
			return;
		}

		// TODO: I'm pretty sure INT_LITs are always positive anyway.
		// So this may be redundant
		if (Integer.valueOf(sync.getVal()) < 0) {
			error(sync, "The value of synchrony statments must be positive");
		}
		String val2 = sync.getVal2();
		if (val2 != null) {
			if (Integer.valueOf(val2) <= 0) {
				error(sync, "The second value of a synchrony statment must be greater than zero");
			}
			if (Integer.valueOf(sync.getVal()) <= Integer.valueOf(val2)) {
				error(sync, "The second value of a synchrony argument must be less than the first");
			}
		}

	}

	@Check(CheckType.FAST)
	public void checkMNSynchStatement(MNSynchStatement sync) {
		ComponentImplementation compImpl = sync.getContainingComponentImpl();
		if (compImpl == null) {
			// This should already be checked by checkSynchStatement
			return;
		}
		compImpl.getAllSubcomponents();

		// this should be enforced by the parser, but we check to avoid an
		// index out of bounds exception whilst the user is editing...
		int expectedSize = sync.getMax().size();
		if (expectedSize != sync.getMin().size() || expectedSize != sync.getComp1().size()
				|| expectedSize != sync.getComp2().size()) {
			error(sync,
					"Mismatched number of subcomponents and timing ranges: " + sync.getComp1().size()
					+ " left subcomponents, " + sync.getComp2().size() + " right subcomponents, "
					+ sync.getMin().size() + " time minima, and " + sync.getMax().size() + " time maxima.");
			return;
		}

		for (int i = 0; i < expectedSize; i++) {
			NamedElement comp1 = sync.getComp1().get(i);
			NamedElement comp2 = sync.getComp2().get(i);
			String maxStr = sync.getMax().get(i);
			String minStr = sync.getMin().get(i);

			if (!(comp1 instanceof Subcomponent)
					|| !((Subcomponent) comp1).getContainingComponentImpl().equals(compImpl)) {
				error("Element '" + comp1.getName() + "' is not a subcomponent of '" + compImpl.getName() + "'",
						sync, AgreePackage.Literals.MN_SYNCH_STATEMENT__COMP1, i);
			}

			if (!(comp2 instanceof Subcomponent)
					|| !((Subcomponent) comp2).getContainingComponentImpl().equals(compImpl)) {
				error("Element '" + comp2.getName() + "' is not a subcomponent of '" + compImpl.getName() + "'",
						sync, AgreePackage.Literals.MN_SYNCH_STATEMENT__COMP2, i);
			}

			int max = Integer.valueOf(maxStr);
			int min = Integer.valueOf(minStr);

			if (max < 1 || min < 1) {
				error(sync, "Quasi-synchronous values must be greater than zero");
			}

			if (min > max) {
				error("Left hand side quasi-synchronous values must be greater than the right hand side");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkAssume(AssumeStatement assume) {
		Classifier comp = assume.getContainingClassifier();
		if (!(comp instanceof ComponentType)) {
			error(assume, "Assume statements are allowed only in component types");
		}

		// the expression could be null if a pattern is used
		Expr expr = assume.getExpr();
		if (expr != null) {
			Type exprType = AgreeTypeSystem.infer(expr);
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
				error(assume, "Expression for assume statement is of type '" + AgreeTypeSystem.typeToString(exprType)
				+ "' but must be of type 'bool'");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkInitialStatement(InitialStatement statement) {
		Classifier comp = statement.getContainingClassifier();
		if (!(comp instanceof ComponentType)) {
			error(statement, "Initial statements are allowed only in component types");
		}

		Type exprType = AgreeTypeSystem.infer(statement.getExpr());
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
			error(statement,
					"Expression for 'initially' statement is of type '" + AgreeTypeSystem.typeToString(exprType)
					+ "' but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkLift(LiftStatement lift) {


		if (!(lift.getSubcomp() instanceof NamedElement)) {
			error(lift, "Lift statements can be applied only to direct subcomponents."
					+ "Place a lift statement in the subcomponents contract for heavy lifting");
		}

		NamedElement namedEl = lift.getSubcomp();

		if (namedEl != null) {
			if (!(namedEl instanceof SubcomponentImpl)) {
				error(lift, "Lift statements must apply to subcomponent implementations. '" + namedEl.getName()
				+ "' is not a subcomponent.");
			}
//            } else {
//                SubcomponentImpl subImpl = (SubcomponentImpl) namedEl;
//                if (subImpl.getComponentImplementation() == null) {
//                    error(lift, "Lift statements must apply to subcomponent implementations. '"
//                            + namedEl.getName()
//                            + "' is a subcomponent type, not a subcomponent implementation.");
//                }
//            }
		}
	}

	@Check(CheckType.FAST)
	public void checkAssert(AssertStatement asser) {
		Classifier comp = asser.getContainingClassifier();
		if (!(comp instanceof ComponentImplementation)) {
			error(asser, "Assert statements are allowed only in component implementations.");
		}

		// the expression could be null if a pattern is used
		Expr expr = asser.getExpr();
		if (expr != null) {
			Type exprType = AgreeTypeSystem.infer(expr);
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
				error(asser, "Expression for assert statement is of type '" + AgreeTypeSystem.typeToString(exprType)
				+ "' but must be of type 'bool'");
			}
		}

		warning(asser, "We highly discourage the use of assert statements. "
				+ "They can easily lead to inconsistent or unrealizable systems. "
				+ "Note that our realizability check does not verify that component "
				+ "assertions are realizable.  It is likely that you can specify the "
				+ "behavior you want by changing the subcomponent contracts or " + "by using assignment statements.");

	}


	@Check(CheckType.FAST)
	public void checkAADLEnumerator(EnumLitExpr aadlEnum) {
		CustomType enumType = aadlEnum.getEnumType();
		NamedElement enumTypeNamedElement = enumType.getLeaf();
		if (!AgreeAADLEnumerationUtils.isAADLEnumeration(enumTypeNamedElement)) {
			error(enumType, "AADL Enumerations must refer to a Data Type with \"Enum\" data representation "
					+ "property and have an \"Enumerators\' property value list.");
		} else {
			String enumVal = aadlEnum.getValue();
			List<String> enumerators = AgreeAADLEnumerationUtils
					.getEnumerators((ComponentClassifier) enumTypeNamedElement).stream()
					.map(pe -> ((org.osate.aadl2.StringLiteral) pe).getValue()).collect(Collectors.toList());
			if (!enumerators.stream().anyMatch(ev -> ev.equalsIgnoreCase(enumVal))) {
				error(aadlEnum, "AADL Enumeration " + enumTypeNamedElement.getQualifiedName()
				+ " does not have an enumeration value " + enumVal);
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkGuarantee(GuaranteeStatement guar) {
		Classifier comp = guar.getContainingClassifier();
		if (!(comp instanceof ComponentType)) {
			error(guar, "Guarantee statements are allowed only in component types");
		}

		// the expression could be null if a pattern is used
		Expr expr = guar.getExpr();
		if (expr != null) {
			Type exprType = AgreeTypeSystem.infer(expr);
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
				error(guar, "Expression for guarantee statement is of type '" + AgreeTypeSystem.typeToString(exprType)
				+ "' but must be of type 'bool'");
			}
		}
	}

	public void checkExprIsIdentifier(Expr expr) {
		if (!(expr instanceof NamedElmExpr)) {
			error(expr, "Patterns can contain only identifiers (not general expressions)");
		}
	}

	@Check(CheckType.FAST)
	public void checkPeriodicStatement(PeriodicStatement statement) {
		Expr event = statement.getEvent();
		Expr jitter = statement.getJitter();
		Expr period = statement.getPeriod();

		checkExprIsIdentifier(event);

		Type eventType = AgreeTypeSystem.infer(event);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, eventType)) {
			error(event, "Expression is of type '" + eventType + "' but must be of type 'bool'");
		}

		if (jitter != null) {
			if (!(jitter instanceof RealLitExpr || isConst(jitter))) {
				error(jitter, "The specified jitter must be a real literal");
			} else {
				Double val = getRealConstVal(jitter);
				if (val < 0) {
					error(jitter, "The specified jitter must be positive");
				}
			}
		}

		if (!(period instanceof RealLitExpr || isConst(period))) {
			error(period, "The specified period must be a real literal");
		} else {
			Double val = getRealConstVal(period);
			if (val < 0) {
				error(period, "The specified period must be positive");
			}
		}
	}

	private double getRealConstVal(Expr expr) {
		if (expr instanceof RealLitExpr) {
			RealLitExpr realLit = (RealLitExpr) expr;
			return Double.valueOf(realLit.getVal());
		} else if (expr instanceof ProjectionExpr) {
			ProjectionExpr id = (ProjectionExpr) expr;
			NamedElement finalId = id.getField();
			if (finalId instanceof ConstStatement) {
				ConstStatement constState = (ConstStatement) finalId;
				return getRealConstVal(constState.getExpr());
			}
		}
		throw new IllegalArgumentException("not constant or literal value evalued");
	}

	@Check(CheckType.FAST)
	public void checkSporadicStatement(SporadicStatement statement) {
		Expr event = statement.getEvent();
		Expr jitter = statement.getJitter();
		Expr iat = statement.getIat();

		checkExprIsIdentifier(event);

		Type eventType = AgreeTypeSystem.infer(event);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, eventType)) {
			error(event, "Expression is of type '" + eventType + "' but must be of type 'bool'");
		}

		if (jitter != null) {
			if (!(jitter instanceof RealLitExpr || isConst(jitter))) {
				error(jitter, "The specified jitter must be a real literal");
			} else {
				Double val = getRealConstVal(jitter);
				if (val < 0) {
					error(jitter, "The specified jitter must be positive");
				}
			}
		}

		if (!(iat instanceof RealLitExpr || isConst(iat))) {
			error(iat, "The specified interarrival time must be a real literal");
		} else {
			Double val = getRealConstVal(iat);
			if (val < 0) {
				error(iat, "The specified interarrival time must be positive");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkWhenHoldsStatement(WhenHoldsStatement when) {
		Expr condition = when.getCondition();
		Expr event = when.getEvent();
		TimeInterval condInterval = when.getConditionInterval();

		checkExprIsIdentifier(condition);
		checkExprIsIdentifier(event);

		if (condInterval != null) {
			Expr lowExpr = condInterval.getLow();
			if (lowExpr instanceof RealLitExpr) {
				RealLitExpr realExpr = (RealLitExpr) lowExpr;
				if (!realExpr.getVal().equals("0.0")) {
					error(lowExpr, "The lower bound of this interval must be zero");
				}
			}
		} else {
			error(when, "Statement most of a cause interval");
		}

		Type type = AgreeTypeSystem.infer(condition);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(condition,
					"The condition of a when statement is of type '" + type + "'" + " but must be of type 'bool'");
		}
		type = AgreeTypeSystem.infer(event);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(event, "The effect of a when statement is of type '" + type + "'" + " but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkWhenOccursStatment(WhenOccursStatment when) {
		Expr condition = when.getCondition();
		Expr event = when.getEvent();
		Expr times = when.getTimes();

		checkExprIsIdentifier(condition);
		checkExprIsIdentifier(event);

		Type type = AgreeTypeSystem.infer(condition);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(condition,
					"The condition of the 'when' statement is of type '" + type + "'" + " but must be of type 'bool'");
		}
		type = AgreeTypeSystem.infer(event);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(event,
					"The effect of the 'when' statement is of type '" + type + "'" + " but must be of type 'bool'");
		}
		type = AgreeTypeSystem.infer(times);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, type)) {
			error(event,
					"The 'times' of the 'when' statement is of type '" + type + "'" + " but must be of type 'int'");
		}

	}

	@Check(CheckType.FAST)
	public void checkWheneverOccursStatement(WheneverOccursStatement whenever) {
		Expr cause = whenever.getCause();
		Expr effect = whenever.getEffect();

		checkExprIsIdentifier(cause);
		checkExprIsIdentifier(effect);

		Type type = AgreeTypeSystem.infer(cause);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(cause,
					"The cause of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
		type = AgreeTypeSystem.infer(effect);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(effect,
					"The effect of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkWheneverBecomesTrueStatement(WheneverBecomesTrueStatement whenever) {
		Expr cause = whenever.getCause();
		Expr effect = whenever.getEffect();

		checkExprIsIdentifier(cause);
		checkExprIsIdentifier(effect);

		Type type = AgreeTypeSystem.infer(cause);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(cause,
					"The cause of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
		type = AgreeTypeSystem.infer(effect);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(effect,
					"The effect of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkWheneverHoldsStatement(WheneverHoldsStatement whenever) {
		Expr cause = whenever.getCause();
		Expr effect = whenever.getEffect();

		checkExprIsIdentifier(cause);
		checkExprIsIdentifier(effect);

		Type type = AgreeTypeSystem.infer(cause);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(cause,
					"The cause of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
		type = AgreeTypeSystem.infer(effect);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(effect,
					"The effect of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkWheneverImpliesStatement(WheneverImpliesStatement whenever) {
		Expr cause = whenever.getCause();
		Expr lhs = whenever.getLhs();
		Expr rhs = whenever.getRhs();

		checkExprIsIdentifier(cause);
		checkExprIsIdentifier(lhs);
		checkExprIsIdentifier(rhs);

		Type type = AgreeTypeSystem.infer(cause);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(cause,
					"The cause of the 'whenever' statement is of type '" + type + "' " + "but must be of type 'bool'");
		}

		type = AgreeTypeSystem.infer(lhs);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(lhs, "The left hand side of the 'implies' of the 'whenever' statement is of type '" + type + "' "
					+ "but must be of type 'bool'");
		}

		type = AgreeTypeSystem.infer(rhs);
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(lhs, "The rhs hand side of the 'implies' of the 'whenever' statement is of type '" + type + "' "
					+ "but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkTimeInterval(TimeInterval interval) {
		Expr lower = interval.getLow();
		Expr higher = interval.getHigh();

//	    Type lowerType = AgreeTypeSystem.infer(lower);
//	    Type higherType = AgreeTypeSystem.infer(higher);

		if (!(lower instanceof RealLitExpr || isConst(lower))) {
			error(lower, "Lower interval must be a real valued literal");
		}

		if (!(higher instanceof RealLitExpr || isConst(higher))) {
			error(higher, "higher interval must be a real valued literal");
		}

	}

	protected boolean isConst(Expr expr) {
		if (expr instanceof ProjectionExpr) {
			ProjectionExpr id = (ProjectionExpr) expr;
			NamedElement finalId = id.getField();
			return (finalId instanceof ConstStatement);
		} else if (expr instanceof EnumLitExpr) {
			return true;
		}
		return false;
	}

	@Check(CheckType.FAST)
	public void checkTagExpr(TagExpr e) {
		Expr stem = e.getStem();
		NamedElement ne = null;
		if (stem instanceof ProjectionExpr) {
			ne = ((ProjectionExpr) stem).getField();
		} else if (stem instanceof NamedElmExpr) {
			ne = ((NamedElmExpr) stem).getNamedElm();
		}

		if (ne instanceof Subcomponent) {
			ComponentImplementation ci = e.getContainingComponentImpl();
			List<Subcomponent> subs = ci.getAllSubcomponents();
			boolean found = false;
			for (Subcomponent sub : subs) {
				if (ne.getName().equals(sub.getName())) {
					found = true;
				}
			}

			if (!found) {
				error(stem, ne + "//" + stem + ": 1 tag must be applied to a subcomponent");
			}

		} else {
			error(stem, ne + "//" + stem + ": 2 tag must be applied to a subcomponent");
		}
	}

	@Check(CheckType.FAST)
	public void checkTimeRise(TimeRiseExpr timeRise) {
		checkTimeExpr(timeRise, timeRise.getId());
	}

	@Check(CheckType.FAST)
	public void checkTimeFall(TimeFallExpr timeFall) {
		checkTimeExpr(timeFall, timeFall.getId());
	}

	@Check(CheckType.FAST)
	public void checkTimeOf(TimeOfExpr timeOf) {
		checkTimeExpr(timeOf, timeOf.getId());
	}

	public void checkTimeExpr(EObject expr, NamedElement id) {
		Type type = AgreeTypeSystem.typeFromID(id);

		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, type)) {
			error(expr, "Time functions can be applied only to Boolean identifiers");
		}

	}

	@Check(CheckType.FAST)
	public void checkLemma(LemmaStatement lemma) {
		Classifier comp = lemma.getContainingClassifier();
		if (!(comp instanceof ComponentImplementation)) {
			error(lemma, "Lemma statements are allowed only in component implementations and nodes");
		}

		Expr expr = lemma.getExpr();
		if (expr != null) {
			Type exprType = AgreeTypeSystem.infer(expr);
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
				error(lemma, "Expression for lemma statement is of type '" + AgreeTypeSystem.typeToString(exprType)
				+ "' but must be of type 'bool'");
			}
		}
	}

	public void checkTypeExists(Expr e) {
		NamedElement ne = null;
		if (e instanceof NamedElmExpr) {
			ne = ((NamedElmExpr) e).getNamedElm();
		} else if (e instanceof ProjectionExpr) {
			ne = ((ProjectionExpr) e).getField();
		}

		if (ne != null && !AgreeTypeSystem.hasType(ne)) {
			error(e, "named thing must be an expression with a type");
		}
	}

	@Check(CheckType.FAST)
	public void checkUnaryExpr(UnaryExpr unaryExpr) {

		checkTypeExists(unaryExpr.getExpr());

		Type typeRight = AgreeTypeSystem.infer(unaryExpr.getExpr());
		String op = unaryExpr.getOp();

		switch (op) {
		case "-":
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeRight)
					&& !AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeRight)) {
				error(unaryExpr, "right side of unary expression '" + op + "' is of type '" + typeRight
						+ "' but must be of type 'int' or 'real'");
			}
			break;
		case "not":
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, typeRight)) {
				error(unaryExpr, "right side of unary expression '" + op + "' is of type '" + typeRight
						+ "' but must be of type 'bool'");
			}
			break;
		default:
			assert (false);
		}
	}

	@Check(CheckType.FAST)
	public void checkPropertyStatement(PropertyStatement propStat) {
		AnnexLibrary library = EcoreUtil2.getContainerOfType(propStat, AnnexLibrary.class);
		if (library != null) {
			error(propStat, "Property statments are allowed only in component annexes");
		}

		Type exprType = AgreeTypeSystem.infer(propStat.getExpr());
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
			error(propStat, "Property statement '" + propStat.getName() + "' is of type '" + exprType
					+ "' but must be of type 'bool'");
		}

	}

	@Check(CheckType.FAST)
	public void checkInputStatement(InputStatement input) {
		ComponentType comp = EcoreUtil2.getContainerOfType(input, ComponentType.class);
		if (comp == null) {
			error(input, "Input statements are allowed only in component types");
		}

	}

	@Check(CheckType.FAST)
	public void checkRecordUpdateExpr(RecordUpdateExpr upExpr) {

		if (isInLinearizationBody(upExpr)) {
			error(upExpr, "Record update expressions not allowed in linearization body expression");
			return;
		}

		checkTypeExists(upExpr.getRecord());
		Type recordType = AgreeTypeSystem.infer(upExpr.getRecord());


		if (recordType instanceof CustomType) {
			NamedElement ne = ((CustomType) recordType).getLeaf();
			if (ne instanceof RecordDef) {
				// scoping should ensure the key is a proper Arg
				Arg arg = (Arg) upExpr.getKey();
				Type keyType = arg.getType();
				checkTypeExists(upExpr.getExpr());
				Type expType = AgreeTypeSystem.infer(upExpr.getExpr());

				if (!AgreeTypeSystem.typesEqual(keyType, expType)) {
					error(upExpr, "the update field is of type '" + AgreeTypeSystem.typeToString(keyType)
					+ "', but the expression is of type '" + AgreeTypeSystem.typeToString(expType) + "'");
				}

			} else if (ne instanceof DataImplementation) {
				// scoping should ensure the key is a proper Subcomponent
				Subcomponent subcomp = (Subcomponent) upExpr.getKey();
				Type keyType = AgreeTypeSystem.mkCustomType(subcomp.getClassifier());
				checkTypeExists(upExpr.getExpr());
				Type expType = AgreeTypeSystem.infer(upExpr.getExpr());
				if (!AgreeTypeSystem.typesEqual(keyType, expType)) {
					error(upExpr, "the update field is of type '" + AgreeTypeSystem.typeToString(keyType)
					+ "', but the expression is of type '" + AgreeTypeSystem.typeToString(expType) + "'");
				}
			} else {
				error("Record to be updated must be a data implementation or AGREE record type.  " + "Found type '"
						+ AgreeTypeSystem.typeToString(recordType) + "'.", upExpr,
						AgreePackage.Literals.RECORD_UPDATE_EXPR__RECORD, -1);
			}
		} else {
			error("Record to be updated must be a data implementation or AGREE record type.  " + "Found type '"
					+ AgreeTypeSystem.typeToString(recordType) + "'.", upExpr,
					AgreePackage.Literals.RECORD_UPDATE_EXPR__RECORD, -1);
		}

	}

	@Check(CheckType.FAST)
	public void checkRecordType(CustomType recType) {
		NamedElement finalId = recType.getLeaf();

//		if (!(finalId instanceof DataImplementation) && !(finalId instanceof RecordDef)
//				&& !(finalId instanceof DataType) && !(finalId instanceof EnumStatement)) {
//			error(recType, "types must be record definition, array definition, data implementation, enumeration, or datatype");
//		}

//		if (finalId instanceof DataImplementation) {
//			if (AgreeTypeSystem.typesEqual(recType, AgreeTypeSystem.errorType)) {
//				error(recType, "Data Implementations with no subcomponents must extend"
//						+ " a Base_Type that AGREE can reason about.");
//				return;
//			}
//			if (((DataImplementation) finalId).getAllSubcomponents().size() != 0) {
//				if (AgreeTypeSystem.typesEqual(recType, AgreeTypeSystem.boolType)
//						|| AgreeTypeSystem.typesEqual(recType, AgreeTypeSystem.intType)
//						|| AgreeTypeSystem.typesEqual(recType, AgreeTypeSystem.realType)) {
//					error(finalId, "Data implementations with subcomponents cannot be"
//							+ " interpreted by AGREE if they extend Base_Types");
//				}
//			}
//
//			// dataImplCycleCheck(recId);
//			return;
//		}

//		if (finalId instanceof DataType) {
//			if (AgreeTypeSystem.typesEqual(recType, AgreeTypeSystem.errorType)) {
//				error(recType, "AADL Datatypes must extend" + " a Base_Type that AGREE can reason about.");
//				return;
//			}
//		}
	}

	@Check(CheckType.FAST)
	public void checkArrayLiteralExpr(ArrayLiteralExpr alit) {

		List<Expr> exprs = alit.getElems();
		if (exprs.size() == 0) {
			error(alit, "Array literal must have at least one element");
		}

		Expr target = exprs.get(0);
		checkTypeExists(target);
		Type t1 = AgreeTypeSystem.infer(target);
		for (Expr e : exprs) {
			checkTypeExists(e);
			Type t2 = AgreeTypeSystem.infer(e);
			if (!AgreeTypeSystem.typesEqual(t1, t2)) {
				error(e, "type of element must be " + AgreeTypeSystem.typeToString(t1) + ", but has type "
						+ AgreeTypeSystem.typeToString(t2));
			}

		}

	}

	@Check(CheckType.FAST)
	public void checkArrayUpdateExpr(ArrayUpdateExpr arrup) {

		List<Expr> indices = arrup.getIndices();
		List<Expr> exprs = arrup.getValueExprs();

		Expr arrExpr = arrup.getArray();
		checkTypeExists(arrExpr);
		Type arrType = AgreeTypeSystem.infer(arrExpr);

		if (arrType instanceof CustomType) {
			NamedElement typedef = ((CustomType) arrType).getLeaf();
			if (typedef instanceof DataType) {
				ArrayDef ad = AgreeTypeSystem.arrayDefFromAadl((DataType) typedef);

				if (!ad.isArray || ad.dimension <= 0 || ad.baseType == null) {
					error(arrExpr, "expression must evaluate to an array");
				}

			}
		} else if (arrType instanceof ArrayType) {
			Type elmType = ((ArrayType) arrType).getStem();
			for (Expr e : exprs) {
				checkTypeExists(e);
				Type t = AgreeTypeSystem.infer(e);
				if (!AgreeTypeSystem.typesEqual(elmType, t)) {
					error(e, "type of element must be " + AgreeTypeSystem.typeToString(elmType) + ", but has type "
							+ AgreeTypeSystem.typeToString(t));
				}

			}
		} else {
			error(arrExpr, "expression must evaluate to an array");
		}




	}

	@Check(CheckType.FAST)
	public void checkArraySubExpr(ArraySubExpr asub) {

		Expr arrayExp = asub.getExpr();
		checkTypeExists(arrayExp);
		Type arrayType = AgreeTypeSystem.infer(arrayExp);

		if (arrayType instanceof CustomType) {

			NamedElement typedef = ((CustomType) arrayType).getLeaf();

			if (typedef instanceof DataType) {
				ArrayDef ad = AgreeTypeSystem.arrayDefFromAadl((DataType) typedef);

				if (!ad.isArray || ad.dimension <= 0 || ad.baseType == null) {

					error(arrayExp, "element must be an array");
				}

			}

		} else if (!(arrayType instanceof ArrayType)) {
			error(arrayExp, "element must be an array");
		}

		Expr index = asub.getIndex();
		checkTypeExists(index);
		Type indexType = AgreeTypeSystem.infer(index);
		if (!AgreeTypeSystem.typesEqual(indexType, AgreeTypeSystem.intType)) {
			error(index, "index must be an int");
		}

	}


	@Check(CheckType.FAST)
	public void checkRecordLitExpr(RecordLitExpr recExpr) {

		CustomType recType = recExpr.getRecordType();
		List<NamedElement> defArgs = getArgNames(recType);
		EList<NamedElement> exprArgs = recExpr.getArgs();
		EList<Expr> argExprs = recExpr.getArgExpr();

		NamedElement finalId = recExpr.getRecordType().getLeaf();
		if (!(finalId instanceof DataImplementation) && !(finalId instanceof RecordDef)) {
			error(recType, "types must be record definition or data implementation");
		}

		if (exprArgs.size() != defArgs.size()) {
			error(recExpr, "Incorrect number of arguments");
			return;
		}

		for (NamedElement argDefName : defArgs) {
			boolean foundArg = false;
			for (NamedElement argExprEl : exprArgs) {
				if (argExprEl.getName().equals(argDefName.getName())) {
					foundArg = true;
					break;
				}
			}
			if (!foundArg) {
				error(recExpr, "No assignment to defined variable '" + argDefName + "' in record expression.");
			}
		}

		// check typing
		Map<String, Type> argNameMap = getFieldTypes(recType);
		for (int i = 0; i < recExpr.getArgs().size(); i++) {
			NamedElement actArg = recExpr.getArgs().get(i);
			String actArgName = actArg.getName();
			Type defType = argNameMap.get(actArgName);

			checkTypeExists(argExprs.get(i));
			Type exprType = AgreeTypeSystem.infer(argExprs.get(i));

			if (!AgreeTypeSystem.typesEqual(defType, exprType)) {
				error(recExpr, "The expression assigned to '" + actArgName + "' does not match its definition type of '"
						+ defType + "'");
			}
		}
	}


	private List<NamedElement> getArgNames(CustomType recType) {

		NamedElement rec = recType.getLeaf();
		List<NamedElement> names = new ArrayList<>();

		if (rec instanceof RecordDef) {
			RecordDef recDef = (RecordDef) rec;
			for (Arg arg : recDef.getArgs()) {
				names.add(arg);
			}
		} else if (rec instanceof DataImplementation) {
			DataImplementation dataImpl = (DataImplementation) rec;
			for (Subcomponent sub : dataImpl.getAllSubcomponents()) {
				names.add(sub);
			}
		} else {
			error(recType, "Record type '" + rec.getName() + "' must be a feature group or a record type definition");
		}

		return names;
	}

	private Map<String, Type> getFieldTypes(CustomType recType) {

		NamedElement rec = recType.getLeaf();
		Map<String, Type> typeMap = new HashMap<>();

		if (rec instanceof RecordDef) {
			RecordDef recDef = (RecordDef) rec;
			for (Arg arg : recDef.getArgs()) {
				typeMap.put(arg.getName(), arg.getType());
			}
		} else if (rec instanceof DataImplementation) {
			DataImplementation dataImpl = (DataImplementation) rec;
			for (Subcomponent sub : dataImpl.getAllSubcomponents()) {
				typeMap.put(sub.getName(), AgreeTypeSystem.mkCustomType(sub.getClassifier()));
			}
		} else {
			error(recType, "Record type '" + rec.getName() + "' must be a feature group or a record type definition");
		}

		return typeMap;
	}

//	private List<Type> getArgTypes(NestedDotID recId){
//
//		NamedElement rec = getFinalNestId(recId);
//		List<Type> types = new ArrayList<Type>();
//
//		if(rec instanceof RecordDefExpr){
//			RecordDefExpr recDef = (RecordDefExpr)rec;
//			for(Arg arg : recDef.getArgs()){
//				types.add(Ooga.infer(arg.getType()));
//			}
//		}else if(rec instanceof FeatureGroupType){
//			FeatureGroupType featGroup = (FeatureGroupType)rec;
//			for(Feature feat : featGroup.getAllFeatures()){
//				types.add(Ooga.infer(feat));
//			}
//		}
//
//		return types;
//	}


//	private void dataImplCycleCheck(NestedDotID dataID) {
//		NamedElement finalId = getFinalNestId(dataID);
//		DataImplementation dataImpl = (DataImplementation) finalId;
//		dataImplCycleCheck(dataImpl, dataID);
//	}

	private void dataImplCycleCheck(DataImplementation dataImpl, EObject errorSource) {
		Set<DataImplementation> dataClosure = new HashSet<>();
		Set<DataImplementation> prevClosure = null;

		for (Subcomponent sub : dataImpl.getAllSubcomponents()) {
			ComponentImplementation subImpl = sub.getComponentImplementation();
			if (subImpl != null) {
				dataClosure.add((DataImplementation) subImpl);
			}
		}

		do {
			prevClosure = new HashSet<>(dataClosure);
			for (DataImplementation subImpl : prevClosure) {
				if (subImpl == dataImpl) {
					error(errorSource, "The component implementation '" + dataImpl.getName()
					+ "' has a cyclic definition.  This cannot be reasoned about by AGREE.");
					break;
				}
				for (Subcomponent subSub : subImpl.getAllSubcomponents()) {
					ComponentImplementation subSubImpl = subSub.getComponentImplementation();
					if (subSubImpl != null) {
						dataClosure.add((DataImplementation) subSubImpl);
					}
				}

			}

		} while (!prevClosure.equals(dataClosure));

	}

	@Check(CheckType.FAST)
	public void checkRecordDefExpr(RecordDef recordDef) {

		Set<RecordDef> recordClosure = new HashSet<>();
		Set<RecordDef> prevClosure = null;

		for (Arg arg : recordDef.getArgs()) {
			Type type = arg.getType();
			if (type instanceof CustomType) {
				NamedElement finalId = ((CustomType) type).getLeaf();

//				if (!(finalId instanceof DataImplementation) && !(finalId instanceof RecordDefExpr)) {
//					error(type, "types must be record definition or data implementation");
//					return;
//				}

				if (finalId instanceof RecordDef) {
					recordClosure.add((RecordDef) finalId);
				} else if (finalId instanceof DataImplementation) {
					// dataImplCycleCheck(subRec);
				}
			}
		}
		do {
			prevClosure = new HashSet<>(recordClosure);

			for (RecordDef subRecDef : prevClosure) {

				if (subRecDef == recordDef) {
					error(recordDef,
							"The definition of type '" + recordDef.getName() + "' is involved in a cyclic definition");
					break;
				}
				for (Arg arg : subRecDef.getArgs()) {
					Type type = arg.getType();
					if (type instanceof CustomType) {
						NamedElement subFinalEl = ((CustomType) type).getLeaf();
						if (subFinalEl instanceof RecordDef) {
							recordClosure.add((RecordDef) subFinalEl);
						}
					}
				}
			}
		} while (!prevClosure.equals(recordClosure));
	}

	@Check(CheckType.FAST)
	public void checkConstStatement(ConstStatement constStat) {
		Type expected = constStat.getType();
		Type actual = AgreeTypeSystem.infer(constStat.getExpr());

		if (!AgreeTypeSystem.typesEqual(expected, actual)) {
			error(constStat, "The assumed type of constant statement '" + constStat.getName() + "' is '" + expected
					+ "' but the actual type is '" + actual + "'");
		}

		// check for constant cycles
		Set<ConstStatement> constClosure = new HashSet<>();
		Set<ConstStatement> prevClosure;
		constClosure.add(constStat);

		// quick and dirty cycle check
		do {
			prevClosure = new HashSet<>(constClosure);
			for (ConstStatement constFrontElem : prevClosure) {
				List<ProjectionExpr> nestIds = EcoreUtil2.getAllContentsOfType(constFrontElem, ProjectionExpr.class);
				for (Expr nestId : nestIds) {
					while (nestId instanceof ProjectionExpr) {
						NamedElement base = ((ProjectionExpr) nestId).getField();
						if (base instanceof ConstStatement) {
							ConstStatement closConst = (ConstStatement) base;
							if (closConst.equals(constStat)) {
								error(constStat, "The expression for constant statment '" + constStat.getName()
								+ "' is part of a cyclic definition");
								break;
							}
							constClosure.add(closConst);
						}
						nestId = ((ProjectionExpr) nestId).getExpr();
					}

					NamedElement base = ((NamedElmExpr) nestId).getNamedElm();
					if (base instanceof ConstStatement) {
						ConstStatement closConst = (ConstStatement) base;
						if (closConst.equals(constStat)) {
							error(constStat, "The expression for constant statment '" + constStat.getName()
							+ "' is part of a cyclic definition");
							break;
						}
						constClosure.add(closConst);
					}

				}
			}
		} while (!prevClosure.equals(constClosure));

		for (Expr e : EcoreUtil2.getAllContentsOfType(constStat.getExpr(), Expr.class)) {
			if (!isPossibleConstant(e)) {
				error(e, "Non-constant expression in constant declaration");
				return;
			}
		}
	}

	private class PatternException extends RuntimeException {

		/**
		 *
		 */
		private static final long serialVersionUID = -8068283537085267186L;

	}

//	protected Type infer(Type type) {
//		String typeName = null;
//		if (type instanceof PrimType) {
//			typeName = ((PrimType) type).getName();
//			return new Type.Name(typeName);
//		} else if (type instanceof CustomType) {
//			return Ooga.inferFomrRecordType((CustomType) type);
//		} else if (type instanceof ArrayType) {
//			ArrayType arrType = (ArrayType) type;
//			Type stem = arrType.getStem();
//			Type stemType = Ooga.infer(stem);
//			int size = Integer.parseInt(arrType.getSize());
//			return new Type.Array(stemType, size);
//		}
//
//		throw new PatternException();
//	}

//	private Type inferFomrRecordType(CustomType recType) {
//		String typeName = "";
//		NamedElement recEl = recType.getLeaf();
//		EObject aadlPack = recEl.eContainer();
//
//		while (!(aadlPack instanceof AadlPackage)) {
//			aadlPack = aadlPack.eContainer();
//		}
//
//		String packName = ((AadlPackage) aadlPack).getName();
//
//		if (recEl instanceof RecordDef) {
//			EObject component = recEl.eContainer();
//			while (!(component instanceof ComponentClassifier) && !(component instanceof AadlPackage)) {
//				component = component.eContainer();
//			}
//
//			if (component == aadlPack) {
//				typeName = recEl.getName();
//			} else {
//				typeName = ((ComponentClassifier) component).getName() + "." + recEl.getName();
//			}
//
//		} else if (recEl instanceof DataImplementation) {
//			Type nativeType = getNativeType((DataImplementation) recEl);
//			if (nativeType != null) {
//				return nativeType;
//			}
//			typeName = recEl.getName();
//		} else if (recEl instanceof DataType) {
//			return Ooga.infer((ComponentClassifier) recEl);
//		} else if (recEl instanceof EnumStatement) {
//			typeName = recEl.getFullName();
//		}
//		typeName = packName + "::" + typeName;
//
//		return new Type.Name(typeName);
//	}

	public boolean isPossibleConstant(Expr e) {
		if (e instanceof PrevExpr || e instanceof PreExpr) {
			return false;
		}

		if (e instanceof BinaryExpr) {
			if (((BinaryExpr) e).getOp().equals("->")) {
				return false;
			}
		}

		if (e instanceof NamedElmExpr) {
			if (EcoreUtil2.getContainerOfType(e, GetPropertyExpr.class) != null) {
				return true;
			}

			NamedElement base = ((NamedElmExpr) e).getNamedElm();

			if (base instanceof DataImplementation || base instanceof ConstStatement || base instanceof RecordLitExpr
					|| base instanceof DataSubcomponent) {
				return true;
			}

			if (base instanceof DataType && e.eContainer() instanceof EnumLitExpr) {
				return true;
			}

			return false;
		}

		return true;
	}

	@Check(CheckType.FAST)
	public void checkNamedElement(NamedElement namedEl) {

		// check for namespace collision in component types of component
		// implementations
		// and for collisions between subcomponent and feature names

		EObject container = namedEl.eContainer();
		if (container == null) {
			return;
		}

		if (container instanceof RecordDef || container instanceof NodeDef) {
			// don't care about arguments to recDefs and nodeDefs
			// TODO: perhaps we can ignore all arguments?
			return;
		}

		while (!(container instanceof AadlPackage || container instanceof ComponentImplementation
				|| container instanceof ComponentType)) {
			container = container.eContainer();
		}

		ComponentImplementation compImpl = null;
		ComponentType type = null;
		if (container instanceof ComponentImplementation) {
			compImpl = (ComponentImplementation) container;
			type = compImpl.getType();
			checkDupNames(namedEl, type, compImpl);
		} else if (container instanceof ComponentType) {
			type = (ComponentType) container;
		}

		if (type != null) {
			for (Feature feat : type.getAllFeatures()) {
				if (namedEl.getName().equals(feat.getName())) {
					error(feat, "Element of the same name ('" + namedEl.getName() + "') in AGREE Annex in '"
							+ (compImpl == null ? type.getName() : compImpl.getName()) + "'");
					error(namedEl, "Feature of the same name ('" + namedEl.getName() + "') in component type");
				}
			}
		}

		// check name space collision with enumerated types

	}

	private void checkDupNames(NamedElement namedEl, ComponentType type, ComponentImplementation compImpl) {
		NamedElement match = matchedInAgreeAnnex(type, namedEl.getName());

		if (match != null) {
			error(match, "Element of the same name ('" + namedEl.getName() + "') in component implementation '"
					+ compImpl.getName() + "'");
			error(namedEl, "Element of the same name ('" + namedEl.getName() + "') in component type");
		}

		for (Subcomponent sub : compImpl.getAllSubcomponents()) {
			if (namedEl.getName().equals(sub.getName())) {
				error(sub, "Element of the same name ('" + namedEl.getName() + "') in AGREE Annex in '"
						+ compImpl.getName() + "'");
				error(namedEl,
						"Subcomponent of the same name ('" + namedEl.getName() + "') in component implementation");
			}
		}
	}

	private NamedElement matchedInAgreeAnnex(ComponentClassifier compClass, String name) {

		for (AnnexSubclause subClause : AnnexUtil.getAllAnnexSubclauses(compClass,
				AgreePackage.eINSTANCE.getAgreeSubclause())) {
			if (subClause instanceof AgreeSubclause) {
				AgreeContract contr = (AgreeContract) subClause.getChildren().get(0);
				for (EObject obj : contr.getChildren()) {
					if (obj instanceof NamedElement) {
						if (name.equals(((NamedElement) obj).getName())) {
							return (NamedElement) obj;
						}
					}
				}
			}
		}
		return null;
	}

	private boolean argsContainRangeValue(List<Arg> args) {
		for (Arg arg : args) {
			Type type = arg.getType();
			if (type instanceof PrimType) {
				PrimType primType = (PrimType) type;
				if (primType.getRangeHigh() != null || primType.getRangeLow() != null) {
					return true;
				}
			}
		}
		return false;
	}

	private void checkMultiAssignEq(EObject src, List<Arg> lhsArgs, Expr rhsExpr) {

		if (rhsExpr == null) {
			return;
		}

		if (lhsArgs.size() == 1) {
			// we should only need to check for cycles for single equations
			String name = lhsArgs.get(0).getName();
			ExprCycleVisitor cycleVisitor = new ExprCycleVisitor(name);
			Set<EObject> cycleObjects = cycleVisitor.doSwitch(rhsExpr);
			if (cycleObjects == null) {
				throw new IllegalArgumentException("something went wrong with the cycle checker");
			}
			for (EObject obj : cycleObjects) {
				error(obj, "Cyclic reference to variable '" + name + "'");
			}
		}

		if (argsContainRangeValue(lhsArgs)) {
			error(src, "Equation statements cannot contain a ranged value and a right hand side expression");
		}

		List<Type> agreeLhsTypes = new ArrayList<>();
		for (Arg arg : lhsArgs) {
			agreeLhsTypes.add(arg.getType());
		}
		List<Type> agreeRhsTypes = new ArrayList<>();

		if (rhsExpr instanceof CallExpr) {
			NamedElement namedEl = ((CallExpr) rhsExpr).getAbstractionRef().getLeaf();
			if (namedEl instanceof NodeDef) {
				NodeDef nodeDef = (NodeDef) namedEl;
				for (Arg var : nodeDef.getRets()) {
					agreeRhsTypes.add(var.getType());
				}
			} else if (namedEl instanceof FnDef) {
				FnDef fnDef = (FnDef) namedEl;
				agreeRhsTypes.add(fnDef.getType());
			} else {
				return; // parse error
			}
		} else {
			checkTypeExists(rhsExpr);
			Type rhsType = AgreeTypeSystem.infer(rhsExpr);
			agreeRhsTypes.add(rhsType);

		}

		if (agreeLhsTypes.size() != agreeRhsTypes.size()) {
			error(src, "Equation assigns " + agreeLhsTypes.size() + " variables, but right side returns "
					+ agreeRhsTypes.size() + " values");
			return;
		}

		for (int i = 0; i < agreeLhsTypes.size(); i++) {
			Type lhsType = agreeLhsTypes.get(i);
			Type rhsType = agreeRhsTypes.get(i);

			if (!AgreeTypeSystem.typesEqual(rhsType, lhsType)) {
				error(src, "The variable '" + lhsArgs.get(i).getName() + "' on the left side of equation is of type '"
						+ lhsType + "' but must be of type '" + rhsType + "'");
			}
		}

//        // check for constant cycles
//        Set<EObject> eqClosure = new HashSet<EObject>();
//        Set<EObject> prevClosure;
//        eqClosure.add(src);
//
//        // quick and dirty cycle check
//        do {
//            prevClosure = new HashSet<EObject>(eqClosure);
//            for (EObject constFrontElem : prevClosure) {
//                List<NestedDotID> nestIds = EcoreUtil2.getAllContentsOfType(constFrontElem,
//                        NestedDotID.class);
//                for (NestedDotID nestId : nestIds) {
//                    while(nestId != null){
//                        NamedElement base = nestId.getBase();
//                        if (base instanceof Arg) {
//                            EObject container = base;
//                            while(!(container instanceof EqStatement) &&
//                                  !(container instanceof NodeEq)){
//                                container = container.eContainer();
//                            }
//                            if (lhsArgs.contains(base)) {
//                                warning(src,
//                                        "The expression for eq statment '" + base.getName()
//                                        + "' may be part of a cyclic definition");
//                                break;
//                            }
//                            eqClosure.add(container);
//                        }
//                        nestId = nestId.getSub();
//                    }
//                }
//            }
//        } while (!prevClosure.equals(eqClosure));

	}

	@Check(CheckType.FAST)
	public void checkEqStatement(EqStatement eqStat) {
		AnnexLibrary library = EcoreUtil2.getContainerOfType(eqStat, AnnexLibrary.class);
		if (library != null) {
			error(eqStat, "Equation statments are allowed only in component annexes");
		}
		checkMultiAssignEq(eqStat, eqStat.getLhs(), eqStat.getExpr());
	}

	@Check(CheckType.FAST)
	public void checkNameOverlap(AgreeContract contract) {

		Set<SynchStatement> syncs = new HashSet<>();
		Set<InitialStatement> inits = new HashSet<>();
		List<ConnectionStatement> conns = new ArrayList<>();
		// check that there are zero or more synchrony statements
		for (SpecStatement spec : contract.getSpecs()) {
			if (spec instanceof SynchStatement) {
				syncs.add((SynchStatement) spec);
			} else if (spec instanceof CalenStatement) {
				syncs.add((CalenStatement) spec);
			} else if (spec instanceof InitialStatement) {
				inits.add((InitialStatement) spec);
			} else if (spec instanceof ConnectionStatement) {
				conns.add((ConnectionStatement) spec);
			}

		}

		if (syncs.size() > 1) {
			for (SynchStatement sync : syncs) {
				error(sync, "Multiple synchrony or calender statements in a single contract");
			}
		}

		if (inits.size() > 1) {
			for (InitialStatement init : inits) {
				error(init, "Multiple initially statements in a single contract");
			}
		}

		for (int i = 0; i < conns.size(); i++) {
			ConnectionStatement connStat0 = conns.get(i);
			NamedElement conn0 = connStat0.getConn();
			for (int j = i + 1; j < conns.size(); j++) {
				ConnectionStatement connStat1 = conns.get(j);
				NamedElement conn1 = connStat1.getConn();
				if (conn0 == null || conn1 == null) {
					break;
				}
				if (conn0.equals(conn1)) {
					error(connStat0, "Multiple connection overrides for connection: '" + conn0.getName() + "'");
					error(connStat1, "Multiple connection overrides for connection: '" + conn1.getName() + "'");
				}
			}
		}

		ComponentImplementation ci = EcoreUtil2.getContainerOfType(contract, ComponentImplementation.class);
		if (ci == null) {
			return;
		}

		Set<String> parentNames = getParentNames(ci);
		for (AgreeSubclause subclause : EcoreUtil2.getAllContentsOfType(ci, AgreeSubclause.class)) {
			List<NamedElement> es = EcoreUtil2.getAllContentsOfType(subclause, NamedElement.class);
			for (NamedElement e : es) {
				if (!(e.eContainer() instanceof NodeDef)) { // ignore elements in node defs
					if (parentNames.contains(e.getName())) {
						error(e, e.getName() + " already defined in component type contract");
					}
				}
			}
		}
	}

	private Set<String> getParentNames(ComponentImplementation ci) {
		Set<String> result = new HashSet<>();
		ComponentType ct = ci.getType();
		for (AgreeSubclause subclause : EcoreUtil2.getAllContentsOfType(ct, AgreeSubclause.class)) {
			List<NamedElement> es = EcoreUtil2.getAllContentsOfType(subclause, NamedElement.class);
			for (NamedElement e : es) {
				if (!(e.eContainer() instanceof NodeDef || e.eContainer() instanceof LinearizationDef
						|| e.eContainer() instanceof RecordDef)) {
					result.add(e.getName());
				}
			}
		}
		return result;
	}

	@Check(CheckType.FAST)
	public void checkNodeEq(NodeEq nodeEq) {
		EObject container = nodeEq.eContainer();
		NodeBodyExpr containingNodeBodyExpr;
		NodeDef containingNodeDef;

		if (container instanceof NodeBodyExpr) {
			containingNodeBodyExpr = (NodeBodyExpr) container;
		} else {
			error(nodeEq, "Node equation must be contained in a node body.");
			return;
		}

		if (container != null) {
			container = container.eContainer();
		}
		if (container instanceof NodeDef) {
			containingNodeDef = (NodeDef) container;
		} else {
			error(nodeEq, "Node equation must be contained in a node definition.");
			return;
		}

		List<Arg> locals = containingNodeBodyExpr.getLocs();
		List<Arg> returns = containingNodeDef.getRets();
		int lhsIndex = 0;
		for (Arg lhs : nodeEq.getLhs()) {
			if (!locals.contains(lhs) && !returns.contains(lhs)) {
				error("LHS '" + lhs.getName() + "' of node equation must be a node return variable or local variable.",
						nodeEq, AgreePackage.Literals.NODE_EQ__LHS, lhsIndex);
			}
			++lhsIndex;
		}

		checkMultiAssignEq(nodeEq, nodeEq.getLhs(), nodeEq.getExpr());
	}

	@Check(CheckType.FAST)
	public void checkNodeLemma(NodeLemma nodeLemma) {
		Type exprType = AgreeTypeSystem.infer(nodeLemma.getExpr());
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, exprType)) {
			error(nodeLemma, "Expression for lemma statement is of type '" + exprType + "' but must be of type 'bool'");
		}
	}

	@Check(CheckType.FAST)
	public void checkNodeStmt(NodeStmt nodeStmt) {
		List<NamedElmExpr> dotIds = EcoreUtil2.getAllContentsOfType(nodeStmt, NamedElmExpr.class);
		for (NamedElmExpr dotId : dotIds) {
			NamedElement id = dotId.getNamedElm();
			if (!(id instanceof Arg) && !(id instanceof ConstStatement) && !(id instanceof NodeDef)
					&& !(id instanceof FnDef) && !(id instanceof DataSubcomponent) && !(id instanceof CustomType)
					&& !(id instanceof DataImplementation) && !(id instanceof RecordDef)) {
				error(dotId, "Only arguments, constants, and node calls allowed within a node");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkNodeDef(NodeDef nodeDefExpr) {

		if (nodeDefExpr.getNodeBody() == null) {
			return; // this will throw a parse error anyway
		}

		Map<Arg, Integer> assignMap = new HashMap<>();
		for (Arg arg : nodeDefExpr.getRets()) {
			assignMap.put(arg, 0);
		}
		for (Arg arg : nodeDefExpr.getNodeBody().getLocs()) {
			assignMap.put(arg, 0);
		}

		for (NodeStmt stmt : nodeDefExpr.getNodeBody().getStmts()) {
			if (stmt instanceof NodeEq) {
				NodeEq eq = (NodeEq) stmt;
				for (Arg arg : eq.getLhs()) {
					Integer value = assignMap.get(arg);
					if (value == null) {
						error("Equation attempting to assign '" + arg.getName()
						+ "', which is not an assignable value within the node");
						return;
					} else {
						assignMap.put(arg, value + 1);
					}
				}
			}
		}
		for (Map.Entry<Arg, Integer> elem : assignMap.entrySet()) {
			if (elem.getValue() == 0) {
				error("Variable '" + elem.getKey().getName() + "' is never assigned by an equation in node '"
						+ nodeDefExpr.getName() + "'");
				return;
			} else if (elem.getValue() > 1) {
				error("Variable '" + elem.getKey().getName() + "' is assigned multiple times in node '"
						+ nodeDefExpr.getName() + "'");
			}
		}
	}

	public static boolean isInLinearizationBody(Expr expr) {
		boolean result = false;
		EObject current = expr;
		while (current != null && current instanceof Expr) {
			EObject container = current.eContainer();
			if (container instanceof LinearizationDef) {
				result = ((LinearizationDef) container).getExprBody().equals(current);
			}
			current = container;
		}
		return result;
	}

	@Check(CheckType.FAST)
	public void checkLinearizationDefExpr(LinearizationDef linDefExpr) {
		// Check that allowable number of formal args are defined
		if (linDefExpr.getArgs().size() != 1) {
			error(linDefExpr, "Linearization definitions are limited to functions of one variable.");
		}

		// Check that the formal args are all of real type
		for (Arg arg : linDefExpr.getArgs()) {
			Type argType = arg.getType();
			if (!AgreeTypeSystem.typesEqual(argType, AgreeTypeSystem.realType)) {
				error(arg, "Linearizations formal arguments must be of real type, but found type " + argType);
			}
		}

		// Check that the number of domain intervals matches the number of
		// formal arguments
		if (linDefExpr.getIntervals().size() != linDefExpr.getArgs().size()) {
			error(linDefExpr, "Number of formal variables and intervals does not match.");
		}

		// If a precision clause is present, it must be a constant expression
		// of real type
		Expr precisionExpr = linDefExpr.getPrecision();
		if (precisionExpr != null) {
			Type precisionExprType = AgreeTypeSystem.infer(precisionExpr);
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, precisionExprType)) {
				error(precisionExpr,
						"Linearization precision must be of real type, but found type " + precisionExprType);
			}
			if (!exprIsConst(precisionExpr)) {
				error(precisionExpr, "Linearization precision must be constant expression of real type"
						+ ", found non-constant expression.");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkLinearizationInterval(LinearizationInterval linInterval) {
		final String message = "Linearization interval endpoints must be constant expressions of real type";
		Expr startExpr = linInterval.getStart();
		Expr endExpr = linInterval.getEnd();
		Type startExprType = AgreeTypeSystem.infer(startExpr);
		Type endExprType = AgreeTypeSystem.infer(endExpr);

		// The type of the interval start and end must be of real type
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, startExprType)) {
			error(startExpr, message + ", found type " + startExprType + ".");
		}
		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, endExprType)) {
			error(endExpr, message + ", found type " + endExprType + ".");
		}

		// The interval start and end expressions must be constant
		if (!exprIsConst(startExpr)) {
			error(endExpr, message + ", found non-constant expression.");
		}
		if (!exprIsConst(startExpr)) {
			error(endExpr, message + ", found non-constant expression.");
		}
	}

	private static NamedElement namedElementFromIdExpr(ComponentRef componentRef) {
		if (componentRef instanceof SubcomponentRef) {
			return ((SubcomponentRef) componentRef).getNamedElm();
		} else if (componentRef instanceof ThisRef) {
			NamedElement component = EcoreUtil2.getContainerOfType(componentRef, ComponentClassifier.class);
			return component;
//---OLD CODE HERE FOR REFERENCE---
//			NestedDotID nestId = ((ThisExpr) component).getSubThis();
//			while (nestId != null) {
//				NamedElement base = nestId.getBase();
//
//				if (base instanceof Subcomponent) {
//					component = ((Subcomponent) base).getSubcomponentType();
//					nestId = nestId.getSub();
//				} else if (base instanceof FeatureGroup) {
//					while (nestId.getSub() != null) {
//						nestId = nestId.getSub();
//						assert (nestId.getBase() instanceof Feature);
//						Feature subFeat = (Feature) nestId.getBase();
//						component = subFeat;
//					}
//					return component;
//				} else {
//					assert (base instanceof DataPort);
//					component = base;
//					return component;
//				}
//
//			}
//			return component
		}

		return null;

	}

	@Check(CheckType.FAST)
	public void checkGetPropertyExpr(GetPropertyExpr getPropExpr) {
		ComponentRef componentRef = getPropExpr.getComponentRef();
		NamedElement prop = getPropExpr.getProp();

		if (!(prop instanceof Property || prop instanceof PropertyConstant)) {
			error(getPropExpr.getProp(), "Expected AADL property or property constant");
		}

		if (prop instanceof Property) {
			NamedElement element = namedElementFromIdExpr(componentRef);
			final boolean applies = element.acceptsProperty((Property) prop);
			if (!applies) {
				error("Property " + ((Property) prop).getQualifiedName() + " does not apply to "
						+ element.getQualifiedName() + ".", getPropExpr,
						AgreePackage.Literals.GET_PROPERTY_EXPR__PROP);
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkPrevExpr(PrevExpr prevExpr) {

		checkTypeExists(prevExpr.getDelay());
		Type delayType = AgreeTypeSystem.infer(prevExpr.getDelay());
		checkTypeExists(prevExpr.getInit());
		Type initType = AgreeTypeSystem.infer(prevExpr.getInit());

		if (!AgreeTypeSystem.typesEqual(initType, delayType)) {
			error(prevExpr, "The first and second arguments of the 'prev' function are of non-matching types '"
					+ delayType + "' and '" + initType + "'");
		}

		if (isInLinearizationBody(prevExpr)) {
			error(prevExpr, "'prev' expressions are not allowed in linearization body expressions.");
		}
	}

	public List<Type> typesFromArgs(List<Arg> args) {
		List<Type> types = new ArrayList<Type>();
		for (Arg arg : args) {
			types.add(arg.getType());
		}
		return types;
	}

	public void checkInputsVsActuals(CallExpr call) {
		AbstractionRef dotId = call.getAbstractionRef();
		NamedElement namedEl = dotId.getLeaf();

		if (!(namedEl instanceof Abstraction)) {
			// this error will be caught elsewhere
			return;
		}

		Abstraction callDef = (Abstraction) namedEl;

		List<Type> inDefTypes;
		String callName;

		// extract in/out arguments
		if (callDef instanceof FnDef) {
			FnDef fnDef = (FnDef) callDef;
			inDefTypes = typesFromArgs(fnDef.getArgs());
			callName = fnDef.getName();
		} else if (callDef instanceof NodeDef) {
			NodeDef nodeDef = (NodeDef) callDef;
			inDefTypes = typesFromArgs(nodeDef.getArgs());
			callName = nodeDef.getName();
		} else if (callDef instanceof LinearizationDef) {
			LinearizationDef linDef = (LinearizationDef) callDef;
			inDefTypes = typesFromArgs(linDef.getArgs());
			callName = linDef.getName();
		} else if (callDef instanceof LibraryFnDef) {
			LibraryFnDef nativeDef = (LibraryFnDef) callDef;
			inDefTypes = typesFromArgs(nativeDef.getArgs());
			callName = nativeDef.getName();
		} else {
			error(call, "Node, function or linearization definition name expected.");
			return;
		}

		// extract args

		List<Type> argCallTypes = new ArrayList<>();
		for (Expr expr : call.getArgs()) {
			checkTypeExists(expr);
			argCallTypes.add(AgreeTypeSystem.infer(expr));
		}

		if (inDefTypes.size() != argCallTypes.size()) {
			error(call, "Function definition '" + callName + "' requires " + inDefTypes.size()
			+ " arguments, but this function call provides " + argCallTypes.size() + " arguments");
			return;
		}

		for (int i = 0; i < inDefTypes.size(); i++) {
			Type callType = argCallTypes.get(i);
			Type defType = inDefTypes.get(i);

			if (!AgreeTypeSystem.typesEqual(defType, callType)) {
				error(call, "Argument " + i + " of function call '" + callName + "' is of type '" + callType
						+ "' but must be of type '" + defType + "'");
			}
		}
	}

	@Check(CheckType.FAST)
	public void checkCallExpr(CallExpr call) {
		NamedElement fn = call.getAbstractionRef().getLeaf();
		if (isInLinearizationBody(call)) {
			if (fn instanceof NodeDef) {
				error(call, "Node definitions cannot be applied in a linearization definition");
			}
		} else {
			if (fn instanceof LibraryFnDef) {
				if (fn.getElementRoot().getName().equalsIgnoreCase("dreal")) {
					warning(call, "dReal library functions require the use of the dReal solver");
				} else {
					error(call, "Library functions cannot be called from the logic");
				}
			}
		}
		checkInputsVsActuals(call);
	}

	@Check(CheckType.FAST)
	public void checkFnDefExpr(FnDef fnDef) {

		// verify typing
		Type fnType = fnDef.getType();
		if (fnType == null) {
			return; // this error will be caught in parsing
		}
		Type exprType = AgreeTypeSystem.infer(fnDef.getExpr());
		if (!AgreeTypeSystem.typesEqual(exprType, fnType)) {
			error(fnDef, "Function '" + fnDef.getName() + "' is of type '" + AgreeTypeSystem.typeToString(fnType)
			+ "' but its expression is of type '" + AgreeTypeSystem.typeToString(exprType) + "'");
		}

	}

	@Check(CheckType.FAST)
	public void checkAbstraction(Abstraction callDef) {

		// don't check recursive calls of functions that have
		// already been walked over
		if (checkedRecCalls.contains(callDef)) {
			return;
		}

		CallRecursionHelper recHelp = new CallRecursionHelper();
		recHelp.doSwitch(callDef);

		for (LinkedList<Abstraction> loop : recHelp.loops) {
			StringBuilder loopStr = new StringBuilder();
			String sep = "";
			for (Abstraction tempAbstraction : loop) {
				checkedRecCalls.add(tempAbstraction);
				String callName = tempAbstraction.getName();
				loopStr.append(sep);
				loopStr.append(callName);
				sep = " -> ";
			}

			error(callDef, "There exists a recursive dependency between the " + "following node or function calls : "
					+ loopStr);

		}
	}

	@Check(CheckType.FAST)
	public void checkIfThenElseExpr(IfThenElseExpr expr) {
		if (isInLinearizationBody(expr)) {
			error(expr, "If-then-else expressions not allowed in linearization body expressions");
			return;
		}

		checkTypeExists(expr.getA());
		Type condType = AgreeTypeSystem.infer(expr.getA());

		checkTypeExists(expr.getB());
		Type thenType = AgreeTypeSystem.infer(expr.getB());

		checkTypeExists(expr.getC());
		Type elseType = AgreeTypeSystem.infer(expr.getC());

		if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, condType)) {
			error(expr, "The condition of the if statement is of type '" + condType + "' but must be of type 'bool'");
		}

		if (!AgreeTypeSystem.typesEqual(elseType, thenType)) {
			error(expr, "The 'then' and 'else' expressions are of non-matching types '" + thenType + "' and '"
					+ elseType + "'");
		}
	}

	@Check(CheckType.FAST)
	public void checkPreExpr(PreExpr expr) {
		if (isInLinearizationBody(expr)) {
			error(expr, "'pre' expressions not allowed in linearization body expressions");
		}
	}

//	private infer(IfThenElseExpr expr) {
//		return AgreeTypeSystem.infer(expr.getB());
//	}

	/*
	 * @Check(CheckType.FAST)
	 * public void checkUnaryNonLinearExpr(UnaryNonLinearExpr expr) {
	 * Type typeSub = Ooga.infer(expr.getExpr());
	 * String op = expr.getOp();
	 * warning(expr, "Use of trigonometric function: '" + op
	 * + "'.  Trigonometric expressions are allowed only with dReal."
	 * + " Scalability is as yet unknown.");
	 * if (!matches(REAL, typeSub)) {
	 * error(expr, "argument to trigonometric function '" + op + "' is of type '" + typeSub.toString()
	 * + "' but must be of " + "type 'real'");
	 * }
	 * }
	 *
	 * @Check(CheckType.FAST)
	 * public void checkBinaryNonLinearExpr(BinaryNonLinearExpr expr) {
	 * Type typeLeft = Ooga.infer(expr.getLeft());
	 * Type typeRight = Ooga.infer(expr.getRight());
	 * String op = expr.getOp();
	 * warning(expr, "Use of trigonometric function: '" + op
	 * + "'.  Trigonometric expressions are allowed only with dReal."
	 * + " Scalability is as yet unknown.");
	 * if (!matches(REAL, typeLeft)) {
	 * error(expr, "argument to trigonometric function '" + op + "' is of type '" + typeLeft.toString()
	 * + "' but must be of " + "type 'real'");
	 * }
	 * if (!matches(REAL, typeRight)) {
	 * error(expr, "argument to trigonometric function '" + op + "' is of type '" + typeRight.toString()
	 * + "' but must be of " + "type 'real'");
	 * }
	 * }
	 */
	@Check(CheckType.FAST)
	public void checkBinaryExpr(BinaryExpr binExpr) {

		checkTypeExists(binExpr.getLeft());
		checkTypeExists(binExpr.getRight());

		Type typeLeft = AgreeTypeSystem.infer(binExpr.getLeft());
		Type typeRight = AgreeTypeSystem.infer(binExpr.getRight());
		String op = binExpr.getOp();
		Expr rightSide = binExpr.getRight();
		Expr leftSide = binExpr.getLeft();
		boolean isInLinearizationBodyExpr = isInLinearizationBody(binExpr);

		boolean rightSideConst = exprIsConst(rightSide);
		boolean leftSideConst = exprIsConst(leftSide);

		switch (op) {
		case "->":
			if (isInLinearizationBodyExpr) {
				error(binExpr, "Arrow '->' expressions are not allowed in linearization body expressions.");
			} else {
				if (!AgreeTypeSystem.typesEqual(typeRight, typeLeft)) {
					error(binExpr,
							"left and right sides of binary expression '" + op + "' are of type '"
									+ AgreeTypeSystem.typeToString(typeLeft) + "' and '"
									+ AgreeTypeSystem.typeToString(typeRight) + "', but must be of the same type");
				}
			}
			return;

		case "=>":
		case "<=>":
		case "and":
		case "or":
			if (isInLinearizationBodyExpr) {
				error(binExpr,
						"Logical expressions (like '" + op + "') are not allowed in linearization body expressions.");
			} else {
				if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, typeLeft)) {
					error(binExpr, "left side of binary expression '" + op + "' is of type '"
							+ AgreeTypeSystem.typeToString(typeLeft)
							+ "' but must be of " + "type 'bool'");
				}
				if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.boolType, typeRight)) {
					error(binExpr, "right side of binary expression '" + op + "' is of type '"
							+ AgreeTypeSystem.typeToString(typeRight)
							+ "' but must be of" + " type 'bool'");
				}
			}
			return;

		case "=":
		case "<>":
		case "!=":
			if (isInLinearizationBodyExpr) {
				error(binExpr, "Logical comparison expressions (like '" + op
						+ "') are not allowed in linearization body expressions.");
			} else {
				if (!AgreeTypeSystem.typesEqual(typeRight, typeLeft)) {
					error(binExpr,
							"left and right sides of binary expression '" + op + "' are of type '"
									+ AgreeTypeSystem.typeToString(typeLeft) + "' and '"
									+ AgreeTypeSystem.typeToString(typeRight) + "', but must be of the same type");
				}
			}
			return;

		case "<":
		case "<=":
		case ">":
		case ">=":
			if (isInLinearizationBodyExpr) {
				error(binExpr, "Comparison expressions (like '" + op
						+ "') are not allowed in linearization body expressions.");
			} else {
				if (!AgreeTypeSystem.typesEqual(typeRight, typeLeft)) {
					error(binExpr, "left and right sides of binary expression '" + op + "' are of type '" + typeLeft
							+ "' and '" + typeRight + "', but must be of the same type");
				}
				if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeLeft)
						&& !AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeLeft)) {
					error(binExpr, "left side of binary expression '" + op + "' is of type '" + typeLeft
							+ "' but must be of type" + "'int' or 'real'");
				}
				if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeRight)
						&& !AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeRight)) {
					error(binExpr, "right side of binary expression '" + op + "' is of type '" + typeRight
							+ "' but must be of type" + "'int' or 'real'");
				}
			}
			return;

		case "+":
		case "-":
		case "*":
			if (!AgreeTypeSystem.typesEqual(typeRight, typeLeft)) {
				error(binExpr, "left and right sides of binary expression '" + op + "' are of type '" + typeLeft
						+ "' and '" + typeRight + "', but must be of the same type");
			}
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeLeft)
					&& !AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeLeft)) {
				error(binExpr, "left side of binary expression '" + op + "' is of type '" + typeLeft
						+ "' but must be of type" + "'int' or 'real'");
			}
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeRight)
					&& !AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeRight)) {
				error(binExpr, "right side of binary expression '" + op + "' is of type '" + typeRight
						+ "' but must be of type" + "'int' or 'real'");
			}

			if (op.equals("*") && !isInLinearizationBodyExpr) {
				if (!rightSideConst && !leftSideConst) {
					warning(binExpr,
							"neither the right nor the left side of binary expression '" + op
							+ "' is constant'.  Non-linear expressions are allowed only with z3 and dReal."
							+ " With z3 they are not recomended.");
				}
			}
			return;

		case "mod":
		case "div":
			if (isInLinearizationBodyExpr) {
				error(binExpr, "Integer operation expressions (like '" + op
						+ "') are not allowed in linearization body expressions.");
			} else {
				if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeLeft)) {
					error(binExpr, "left side of binary expression '" + op + "' is of type '" + typeLeft
							+ "' but must be of type 'int'");
				}
				if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.intType, typeRight)) {
					error(binExpr, "right side of binary expression '" + op + "' is of type '" + typeRight
							+ "' but must be of type 'int'");
				}
				if (!rightSideConst) {
					warning(binExpr,
							"right side of binary expression '" + op + "' is not constant."
									+ " Non-linear expressions are allowed only with z3."
									+ " Even with z3 they are not recomended...");
				}
			}
			return;

		case "/":
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeLeft)) {
				error(binExpr, "left side of binary expression '" + op + "' is of type '" + typeLeft
						+ "' but must be of type 'real'");
			}
			if (!AgreeTypeSystem.typesEqual(AgreeTypeSystem.realType, typeRight)) {
				error(binExpr, "right side of binary expression '" + op + "' is of type '" + typeRight
						+ "' but must be of type 'real'");
			}

			if (!rightSideConst && !isInLinearizationBodyExpr) {
				warning(binExpr,
						"right side of binary expression '" + op + "' is not constant."
								+ " Non-linear expressions are allowed only with z3."
								+ " Even with z3 they are not recomended...");
			}

			return;

		default:
			assert (false);
		}
	}

	public static boolean exprIsConst(Expr expr) {
		if (expr instanceof NamedElmExpr) {
			NamedElement finalId = ((NamedElmExpr) expr).getNamedElm();
			if (finalId instanceof ConstStatement) {
				return true;
			}
		} else if (expr instanceof RealLitExpr || expr instanceof IntLitExpr || expr instanceof BoolLitExpr) {
			return true;
		} else if (expr instanceof BinaryExpr) {
			BinaryExpr binExpr = (BinaryExpr) expr;
			return exprIsConst(binExpr.getLeft()) && exprIsConst(binExpr.getRight());
		} else if (expr instanceof UnaryExpr) {
			UnaryExpr unExpr = (UnaryExpr) expr;
			return exprIsConst(unExpr.getExpr());
		}
		return false;
	}

//	// TODO: Don't we need more validation here? What if the Id of the IdExpr
//	private Boolean hasAbstractionParent(Element e) {
//		while (e != null) {
//			if (e instanceof Abstraction) {
//				return true;
//			}
//			e = e.getOwner();
//		}
//		return false;
//	}
//
//	private void checkScope(Expr expr, NamedElement id) {
//		if (hasAbstractionParent(expr)) {
//			if (!hasAbstractionParent(id) && !(id instanceof ConstStatement)) {
//				error("Unknown identifier Id: '" + id
//						+ "' (Note that nodes can refer only to inputs, outputs, and local variables and global constants).");
//			}
//		}
//	}




}
