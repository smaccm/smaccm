/*
 * generated by Xtext
 */
package com.rockwellcollins.atc.resolute.serializer;

import com.google.inject.Inject;
import com.rockwellcollins.atc.resolute.resolute.Arg;
import com.rockwellcollins.atc.resolute.resolute.BaseType;
import com.rockwellcollins.atc.resolute.resolute.BinaryExpr;
import com.rockwellcollins.atc.resolute.resolute.BoolExpr;
import com.rockwellcollins.atc.resolute.resolute.BuiltInFnCallExpr;
import com.rockwellcollins.atc.resolute.resolute.CastExpr;
import com.rockwellcollins.atc.resolute.resolute.ClaimArg;
import com.rockwellcollins.atc.resolute.resolute.ClaimBody;
import com.rockwellcollins.atc.resolute.resolute.ClaimString;
import com.rockwellcollins.atc.resolute.resolute.ConstantDefinition;
import com.rockwellcollins.atc.resolute.resolute.FailExpr;
import com.rockwellcollins.atc.resolute.resolute.FnCallExpr;
import com.rockwellcollins.atc.resolute.resolute.FunctionBody;
import com.rockwellcollins.atc.resolute.resolute.FunctionDefinition;
import com.rockwellcollins.atc.resolute.resolute.IdExpr;
import com.rockwellcollins.atc.resolute.resolute.IfThenElseExpr;
import com.rockwellcollins.atc.resolute.resolute.InstanceOfExpr;
import com.rockwellcollins.atc.resolute.resolute.IntExpr;
import com.rockwellcollins.atc.resolute.resolute.LetBinding;
import com.rockwellcollins.atc.resolute.resolute.LetExpr;
import com.rockwellcollins.atc.resolute.resolute.LibraryFnCallExpr;
import com.rockwellcollins.atc.resolute.resolute.LibraryFnType;
import com.rockwellcollins.atc.resolute.resolute.ListExpr;
import com.rockwellcollins.atc.resolute.resolute.ListFilterMapExpr;
import com.rockwellcollins.atc.resolute.resolute.ListType;
import com.rockwellcollins.atc.resolute.resolute.NestedDotID;
import com.rockwellcollins.atc.resolute.resolute.ProveStatement;
import com.rockwellcollins.atc.resolute.resolute.QuantArg;
import com.rockwellcollins.atc.resolute.resolute.QuantifiedExpr;
import com.rockwellcollins.atc.resolute.resolute.RealExpr;
import com.rockwellcollins.atc.resolute.resolute.ResoluteLibrary;
import com.rockwellcollins.atc.resolute.resolute.ResolutePackage;
import com.rockwellcollins.atc.resolute.resolute.ResoluteSubclause;
import com.rockwellcollins.atc.resolute.resolute.SetExpr;
import com.rockwellcollins.atc.resolute.resolute.SetFilterMapExpr;
import com.rockwellcollins.atc.resolute.resolute.SetType;
import com.rockwellcollins.atc.resolute.resolute.StringExpr;
import com.rockwellcollins.atc.resolute.resolute.ThisExpr;
import com.rockwellcollins.atc.resolute.resolute.UnaryExpr;
import com.rockwellcollins.atc.resolute.services.ResoluteGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.osate.aadl2.Aadl2Package;
import org.osate.aadl2.ArrayRange;
import org.osate.aadl2.BasicPropertyAssociation;
import org.osate.aadl2.BooleanLiteral;
import org.osate.aadl2.ClassifierValue;
import org.osate.aadl2.ComputedValue;
import org.osate.aadl2.ContainedNamedElement;
import org.osate.aadl2.ContainmentPathElement;
import org.osate.aadl2.IntegerLiteral;
import org.osate.aadl2.ListValue;
import org.osate.aadl2.ModalPropertyValue;
import org.osate.aadl2.NamedValue;
import org.osate.aadl2.Operation;
import org.osate.aadl2.PropertyAssociation;
import org.osate.aadl2.RangeValue;
import org.osate.aadl2.RealLiteral;
import org.osate.aadl2.RecordValue;
import org.osate.aadl2.ReferenceValue;
import org.osate.aadl2.StringLiteral;
import org.osate.xtext.aadl2.properties.serializer.PropertiesSemanticSequencer;

@SuppressWarnings("all")
public abstract class AbstractResoluteSemanticSequencer extends PropertiesSemanticSequencer {

	@Inject
	private ResoluteGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Aadl2Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Aadl2Package.ARRAY_RANGE:
				sequence_ArrayRange(context, (ArrayRange) semanticObject); 
				return; 
			case Aadl2Package.BASIC_PROPERTY_ASSOCIATION:
				sequence_FieldPropertyAssociation(context, (BasicPropertyAssociation) semanticObject); 
				return; 
			case Aadl2Package.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case Aadl2Package.CLASSIFIER_VALUE:
				sequence_ComponentClassifierTerm(context, (ClassifierValue) semanticObject); 
				return; 
			case Aadl2Package.COMPUTED_VALUE:
				sequence_ComputedTerm(context, (ComputedValue) semanticObject); 
				return; 
			case Aadl2Package.CONTAINED_NAMED_ELEMENT:
				sequence_ContainmentPath(context, (ContainedNamedElement) semanticObject); 
				return; 
			case Aadl2Package.CONTAINMENT_PATH_ELEMENT:
				sequence_ContainmentPathElement(context, (ContainmentPathElement) semanticObject); 
				return; 
			case Aadl2Package.INTEGER_LITERAL:
				sequence_IntegerTerm(context, (IntegerLiteral) semanticObject); 
				return; 
			case Aadl2Package.LIST_VALUE:
				sequence_ListTerm(context, (ListValue) semanticObject); 
				return; 
			case Aadl2Package.MODAL_PROPERTY_VALUE:
				if (rule == grammarAccess.getModalPropertyValueRule()) {
					sequence_ModalPropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOptionalModalPropertyValueRule()) {
					sequence_OptionalModalPropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyValueRule()) {
					sequence_PropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.NAMED_VALUE:
				if (rule == grammarAccess.getConstantValueRule()
						|| rule == grammarAccess.getNumAltRule()) {
					sequence_ConstantValue(context, (NamedValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()
						|| rule == grammarAccess.getLiteralorReferenceTermRule()) {
					sequence_LiteralorReferenceTerm(context, (NamedValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.OPERATION:
				sequence_SignedConstant(context, (Operation) semanticObject); 
				return; 
			case Aadl2Package.PROPERTY_ASSOCIATION:
				if (rule == grammarAccess.getBasicPropertyAssociationRule()) {
					sequence_BasicPropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPModelRule()
						|| rule == grammarAccess.getContainedPropertyAssociationRule()) {
					sequence_ContainedPropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyAssociationRule()) {
					sequence_PropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.RANGE_VALUE:
				sequence_NumericRangeTerm(context, (RangeValue) semanticObject); 
				return; 
			case Aadl2Package.REAL_LITERAL:
				sequence_RealTerm(context, (RealLiteral) semanticObject); 
				return; 
			case Aadl2Package.RECORD_VALUE:
				if (rule == grammarAccess.getOldRecordTermRule()) {
					sequence_OldRecordTerm(context, (RecordValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()
						|| rule == grammarAccess.getRecordTermRule()) {
					sequence_RecordTerm(context, (RecordValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.REFERENCE_VALUE:
				sequence_ReferenceTerm(context, (ReferenceValue) semanticObject); 
				return; 
			case Aadl2Package.STRING_LITERAL:
				sequence_StringTerm(context, (StringLiteral) semanticObject); 
				return; 
			}
		else if (epackage == ResolutePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ResolutePackage.ARG:
				sequence_Arg(context, (Arg) semanticObject); 
				return; 
			case ResolutePackage.BASE_TYPE:
				if (rule == grammarAccess.getBaseTypeRule()) {
					sequence_BaseType(context, (BaseType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()) {
					sequence_BaseType_Type(context, (BaseType) semanticObject); 
					return; 
				}
				else break;
			case ResolutePackage.BINARY_EXPR:
				sequence_AndExpr_ExpExpr_ImpliesExpr_OrExpr_PlusExpr_RelationalExpr_TimesExpr(context, (BinaryExpr) semanticObject); 
				return; 
			case ResolutePackage.BOOL_EXPR:
				sequence_AtomicExpr(context, (BoolExpr) semanticObject); 
				return; 
			case ResolutePackage.BUILT_IN_FN_CALL_EXPR:
				sequence_AtomicExpr(context, (BuiltInFnCallExpr) semanticObject); 
				return; 
			case ResolutePackage.CAST_EXPR:
				sequence_PrefixExpr(context, (CastExpr) semanticObject); 
				return; 
			case ResolutePackage.CLAIM_ARG:
				sequence_ClaimText(context, (ClaimArg) semanticObject); 
				return; 
			case ResolutePackage.CLAIM_BODY:
				sequence_DefinitionBody(context, (ClaimBody) semanticObject); 
				return; 
			case ResolutePackage.CLAIM_STRING:
				sequence_ClaimText(context, (ClaimString) semanticObject); 
				return; 
			case ResolutePackage.CONSTANT_DEFINITION:
				sequence_ConstantDefinition(context, (ConstantDefinition) semanticObject); 
				return; 
			case ResolutePackage.FAIL_EXPR:
				sequence_AtomicExpr(context, (FailExpr) semanticObject); 
				return; 
			case ResolutePackage.FN_CALL_EXPR:
				sequence_AtomicExpr(context, (FnCallExpr) semanticObject); 
				return; 
			case ResolutePackage.FUNCTION_BODY:
				sequence_DefinitionBody(context, (FunctionBody) semanticObject); 
				return; 
			case ResolutePackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
				return; 
			case ResolutePackage.ID_EXPR:
				sequence_AtomicExpr(context, (IdExpr) semanticObject); 
				return; 
			case ResolutePackage.IF_THEN_ELSE_EXPR:
				sequence_AtomicExpr(context, (IfThenElseExpr) semanticObject); 
				return; 
			case ResolutePackage.INSTANCE_OF_EXPR:
				sequence_InstanceOfExpr(context, (InstanceOfExpr) semanticObject); 
				return; 
			case ResolutePackage.INT_EXPR:
				sequence_AtomicExpr(context, (IntExpr) semanticObject); 
				return; 
			case ResolutePackage.LET_BINDING:
				sequence_LetBinding(context, (LetBinding) semanticObject); 
				return; 
			case ResolutePackage.LET_EXPR:
				sequence_AtomicExpr(context, (LetExpr) semanticObject); 
				return; 
			case ResolutePackage.LIBRARY_FN_CALL_EXPR:
				sequence_AtomicExpr(context, (LibraryFnCallExpr) semanticObject); 
				return; 
			case ResolutePackage.LIBRARY_FN_TYPE:
				sequence_Type(context, (LibraryFnType) semanticObject); 
				return; 
			case ResolutePackage.LIST_EXPR:
				sequence_AtomicExpr(context, (ListExpr) semanticObject); 
				return; 
			case ResolutePackage.LIST_FILTER_MAP_EXPR:
				sequence_AtomicExpr(context, (ListFilterMapExpr) semanticObject); 
				return; 
			case ResolutePackage.LIST_TYPE:
				sequence_Type(context, (ListType) semanticObject); 
				return; 
			case ResolutePackage.NESTED_DOT_ID:
				sequence_NestedDotID(context, (NestedDotID) semanticObject); 
				return; 
			case ResolutePackage.PROVE_STATEMENT:
				sequence_ProveStatement(context, (ProveStatement) semanticObject); 
				return; 
			case ResolutePackage.QUANT_ARG:
				sequence_Arg(context, (QuantArg) semanticObject); 
				return; 
			case ResolutePackage.QUANTIFIED_EXPR:
				sequence_AtomicExpr(context, (QuantifiedExpr) semanticObject); 
				return; 
			case ResolutePackage.REAL_EXPR:
				sequence_AtomicExpr(context, (RealExpr) semanticObject); 
				return; 
			case ResolutePackage.RESOLUTE_LIBRARY:
				sequence_ResoluteLibrary(context, (ResoluteLibrary) semanticObject); 
				return; 
			case ResolutePackage.RESOLUTE_SUBCLAUSE:
				sequence_ResoluteSubclause(context, (ResoluteSubclause) semanticObject); 
				return; 
			case ResolutePackage.SET_EXPR:
				sequence_AtomicExpr(context, (SetExpr) semanticObject); 
				return; 
			case ResolutePackage.SET_FILTER_MAP_EXPR:
				sequence_AtomicExpr(context, (SetFilterMapExpr) semanticObject); 
				return; 
			case ResolutePackage.SET_TYPE:
				sequence_Type(context, (SetType) semanticObject); 
				return; 
			case ResolutePackage.STRING_EXPR:
				sequence_AtomicExpr(context, (StringExpr) semanticObject); 
				return; 
			case ResolutePackage.THIS_EXPR:
				sequence_AtomicExpr(context, (ThisExpr) semanticObject); 
				return; 
			case ResolutePackage.UNARY_EXPR:
				sequence_PrefixExpr(context, (UnaryExpr) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Element returns BinaryExpr
	 *     Expr returns BinaryExpr
	 *     ImpliesExpr returns BinaryExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     OrExpr returns BinaryExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     AndExpr returns BinaryExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     InstanceOfExpr returns BinaryExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns BinaryExpr
	 *     RelationalExpr returns BinaryExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     PlusExpr returns BinaryExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     TimesExpr returns BinaryExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     ExpExpr returns BinaryExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     PrefixExpr returns BinaryExpr
	 *     AtomicExpr returns BinaryExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns BinaryExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns BinaryExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns BinaryExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns BinaryExpr
	 *
	 * Constraint:
	 *     (
	 *         (left=ImpliesExpr_BinaryExpr_1_0_0_0 op='=>' right=ImpliesExpr) | 
	 *         (left=OrExpr_BinaryExpr_1_0_0_0 (op='or' | op='orelse') right=AndExpr) | 
	 *         (left=AndExpr_BinaryExpr_1_0_0_0 (op='and' | op='andthen') right=InstanceOfExpr) | 
	 *         (left=RelationalExpr_BinaryExpr_1_0_0_0 op=RelationalOp right=PlusExpr) | 
	 *         (left=PlusExpr_BinaryExpr_1_0_0_0 (op='+' | op='-') right=TimesExpr) | 
	 *         (left=TimesExpr_BinaryExpr_1_0_0_0 (op='*' | op='/' | op='%') right=ExpExpr) | 
	 *         (left=ExpExpr_BinaryExpr_1_0_0_0 op='^' right=PrefixExpr)
	 *     )
	 */
	protected void sequence_AndExpr_ExpExpr_ImpliesExpr_OrExpr_PlusExpr_RelationalExpr_TimesExpr(ISerializationContext context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Arg
	 *     Arg returns Arg
	 *     ClaimTextVar returns Arg
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_Arg(ISerializationContext context, Arg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()));
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.ARG__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.ARG__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArgAccess().getNameIDTerminalRuleCall_0_0_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getArgAccess().getTypeTypeParserRuleCall_0_0_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns QuantArg
	 *     Arg returns QuantArg
	 *     ClaimTextVar returns QuantArg
	 *
	 * Constraint:
	 *     (name=ID expr=Expr)
	 */
	protected void sequence_Arg(ISerializationContext context, QuantArg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()));
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.QUANT_ARG__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.QUANT_ARG__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArgAccess().getNameIDTerminalRuleCall_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getArgAccess().getExprExprParserRuleCall_1_3_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns BoolExpr
	 *     Expr returns BoolExpr
	 *     ImpliesExpr returns BoolExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns BoolExpr
	 *     OrExpr returns BoolExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns BoolExpr
	 *     AndExpr returns BoolExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns BoolExpr
	 *     InstanceOfExpr returns BoolExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns BoolExpr
	 *     RelationalExpr returns BoolExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns BoolExpr
	 *     PlusExpr returns BoolExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns BoolExpr
	 *     TimesExpr returns BoolExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns BoolExpr
	 *     ExpExpr returns BoolExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns BoolExpr
	 *     PrefixExpr returns BoolExpr
	 *     AtomicExpr returns BoolExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns BoolExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns BoolExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns BoolExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns BoolExpr
	 *
	 * Constraint:
	 *     val=BooleanLiteral
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, BoolExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.BOOL_EXPR__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.BOOL_EXPR__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExprAccess().getValBooleanLiteralParserRuleCall_5_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns BuiltInFnCallExpr
	 *     Expr returns BuiltInFnCallExpr
	 *     ImpliesExpr returns BuiltInFnCallExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns BuiltInFnCallExpr
	 *     OrExpr returns BuiltInFnCallExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns BuiltInFnCallExpr
	 *     AndExpr returns BuiltInFnCallExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns BuiltInFnCallExpr
	 *     InstanceOfExpr returns BuiltInFnCallExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns BuiltInFnCallExpr
	 *     RelationalExpr returns BuiltInFnCallExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns BuiltInFnCallExpr
	 *     PlusExpr returns BuiltInFnCallExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns BuiltInFnCallExpr
	 *     TimesExpr returns BuiltInFnCallExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns BuiltInFnCallExpr
	 *     ExpExpr returns BuiltInFnCallExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns BuiltInFnCallExpr
	 *     PrefixExpr returns BuiltInFnCallExpr
	 *     AtomicExpr returns BuiltInFnCallExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns BuiltInFnCallExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns BuiltInFnCallExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns BuiltInFnCallExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns BuiltInFnCallExpr
	 *
	 * Constraint:
	 *     (fn=BuiltInFn (args+=Expr args+=Expr*)?)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, BuiltInFnCallExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns FailExpr
	 *     Expr returns FailExpr
	 *     ImpliesExpr returns FailExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns FailExpr
	 *     OrExpr returns FailExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns FailExpr
	 *     AndExpr returns FailExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns FailExpr
	 *     InstanceOfExpr returns FailExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns FailExpr
	 *     RelationalExpr returns FailExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns FailExpr
	 *     PlusExpr returns FailExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns FailExpr
	 *     TimesExpr returns FailExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns FailExpr
	 *     ExpExpr returns FailExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns FailExpr
	 *     PrefixExpr returns FailExpr
	 *     AtomicExpr returns FailExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns FailExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns FailExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns FailExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns FailExpr
	 *
	 * Constraint:
	 *     (val=Expr | failmsg+=ClaimText+)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, FailExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns FnCallExpr
	 *     Expr returns FnCallExpr
	 *     ImpliesExpr returns FnCallExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns FnCallExpr
	 *     OrExpr returns FnCallExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns FnCallExpr
	 *     AndExpr returns FnCallExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns FnCallExpr
	 *     InstanceOfExpr returns FnCallExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns FnCallExpr
	 *     RelationalExpr returns FnCallExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns FnCallExpr
	 *     PlusExpr returns FnCallExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns FnCallExpr
	 *     TimesExpr returns FnCallExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns FnCallExpr
	 *     ExpExpr returns FnCallExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns FnCallExpr
	 *     PrefixExpr returns FnCallExpr
	 *     AtomicExpr returns FnCallExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns FnCallExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns FnCallExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns FnCallExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns FnCallExpr
	 *
	 * Constraint:
	 *     (fn=[FunctionDefinition|ID] (args+=Expr args+=Expr*)?)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, FnCallExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns IdExpr
	 *     Expr returns IdExpr
	 *     ImpliesExpr returns IdExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     OrExpr returns IdExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     AndExpr returns IdExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     InstanceOfExpr returns IdExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns IdExpr
	 *     RelationalExpr returns IdExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     PlusExpr returns IdExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     TimesExpr returns IdExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     ExpExpr returns IdExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     PrefixExpr returns IdExpr
	 *     AtomicExpr returns IdExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns IdExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns IdExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns IdExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns IdExpr
	 *
	 * Constraint:
	 *     id=[NamedElement|QCREF]
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, IdExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.ID_EXPR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.ID_EXPR__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExprAccess().getIdNamedElementQCREFParserRuleCall_0_1_0_1(), semanticObject.eGet(ResolutePackage.Literals.ID_EXPR__ID, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns IfThenElseExpr
	 *     Expr returns IfThenElseExpr
	 *     ImpliesExpr returns IfThenElseExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     OrExpr returns IfThenElseExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     AndExpr returns IfThenElseExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     InstanceOfExpr returns IfThenElseExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns IfThenElseExpr
	 *     RelationalExpr returns IfThenElseExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     PlusExpr returns IfThenElseExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     TimesExpr returns IfThenElseExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     ExpExpr returns IfThenElseExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     PrefixExpr returns IfThenElseExpr
	 *     AtomicExpr returns IfThenElseExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns IfThenElseExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns IfThenElseExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns IfThenElseExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns IfThenElseExpr
	 *
	 * Constraint:
	 *     (cond=Expr then=Expr else=Expr)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, IfThenElseExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.IF_THEN_ELSE_EXPR__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.IF_THEN_ELSE_EXPR__COND));
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.IF_THEN_ELSE_EXPR__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.IF_THEN_ELSE_EXPR__THEN));
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.IF_THEN_ELSE_EXPR__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.IF_THEN_ELSE_EXPR__ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExprAccess().getCondExprParserRuleCall_7_2_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getAtomicExprAccess().getThenExprParserRuleCall_7_4_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getAtomicExprAccess().getElseExprParserRuleCall_7_6_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns IntExpr
	 *     Expr returns IntExpr
	 *     ImpliesExpr returns IntExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns IntExpr
	 *     OrExpr returns IntExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns IntExpr
	 *     AndExpr returns IntExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns IntExpr
	 *     InstanceOfExpr returns IntExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns IntExpr
	 *     RelationalExpr returns IntExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns IntExpr
	 *     PlusExpr returns IntExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns IntExpr
	 *     TimesExpr returns IntExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns IntExpr
	 *     ExpExpr returns IntExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns IntExpr
	 *     PrefixExpr returns IntExpr
	 *     AtomicExpr returns IntExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns IntExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns IntExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns IntExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns IntExpr
	 *
	 * Constraint:
	 *     val=IntegerTerm
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, IntExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.INT_EXPR__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.INT_EXPR__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExprAccess().getValIntegerTermParserRuleCall_3_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns LetExpr
	 *     Expr returns LetExpr
	 *     ImpliesExpr returns LetExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns LetExpr
	 *     OrExpr returns LetExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns LetExpr
	 *     AndExpr returns LetExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns LetExpr
	 *     InstanceOfExpr returns LetExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns LetExpr
	 *     RelationalExpr returns LetExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns LetExpr
	 *     PlusExpr returns LetExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns LetExpr
	 *     TimesExpr returns LetExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns LetExpr
	 *     ExpExpr returns LetExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns LetExpr
	 *     PrefixExpr returns LetExpr
	 *     AtomicExpr returns LetExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns LetExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns LetExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns LetExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns LetExpr
	 *
	 * Constraint:
	 *     (binding=LetBinding expr=Expr)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, LetExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.LET_EXPR__BINDING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.LET_EXPR__BINDING));
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.LET_EXPR__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.LET_EXPR__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExprAccess().getBindingLetBindingParserRuleCall_16_2_0(), semanticObject.getBinding());
		feeder.accept(grammarAccess.getAtomicExprAccess().getExprExprParserRuleCall_16_4_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns LibraryFnCallExpr
	 *     Expr returns LibraryFnCallExpr
	 *     ImpliesExpr returns LibraryFnCallExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns LibraryFnCallExpr
	 *     OrExpr returns LibraryFnCallExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns LibraryFnCallExpr
	 *     AndExpr returns LibraryFnCallExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns LibraryFnCallExpr
	 *     InstanceOfExpr returns LibraryFnCallExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns LibraryFnCallExpr
	 *     RelationalExpr returns LibraryFnCallExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns LibraryFnCallExpr
	 *     PlusExpr returns LibraryFnCallExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns LibraryFnCallExpr
	 *     TimesExpr returns LibraryFnCallExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns LibraryFnCallExpr
	 *     ExpExpr returns LibraryFnCallExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns LibraryFnCallExpr
	 *     PrefixExpr returns LibraryFnCallExpr
	 *     AtomicExpr returns LibraryFnCallExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns LibraryFnCallExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns LibraryFnCallExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns LibraryFnCallExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns LibraryFnCallExpr
	 *
	 * Constraint:
	 *     (libName=ID fnName=ID (args+=Expr args+=Expr*)?)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, LibraryFnCallExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns ListExpr
	 *     Expr returns ListExpr
	 *     ImpliesExpr returns ListExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns ListExpr
	 *     OrExpr returns ListExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns ListExpr
	 *     AndExpr returns ListExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns ListExpr
	 *     InstanceOfExpr returns ListExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns ListExpr
	 *     RelationalExpr returns ListExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns ListExpr
	 *     PlusExpr returns ListExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns ListExpr
	 *     TimesExpr returns ListExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns ListExpr
	 *     ExpExpr returns ListExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns ListExpr
	 *     PrefixExpr returns ListExpr
	 *     AtomicExpr returns ListExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns ListExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns ListExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns ListExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns ListExpr
	 *
	 * Constraint:
	 *     (exprs+=AtomicExpr_ListExpr_12_2_1_0 exprs+=Expr*)?
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, ListExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns ListFilterMapExpr
	 *     Expr returns ListFilterMapExpr
	 *     ImpliesExpr returns ListFilterMapExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns ListFilterMapExpr
	 *     OrExpr returns ListFilterMapExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns ListFilterMapExpr
	 *     AndExpr returns ListFilterMapExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns ListFilterMapExpr
	 *     InstanceOfExpr returns ListFilterMapExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns ListFilterMapExpr
	 *     RelationalExpr returns ListFilterMapExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns ListFilterMapExpr
	 *     PlusExpr returns ListFilterMapExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns ListFilterMapExpr
	 *     TimesExpr returns ListFilterMapExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns ListFilterMapExpr
	 *     ExpExpr returns ListFilterMapExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns ListFilterMapExpr
	 *     PrefixExpr returns ListFilterMapExpr
	 *     AtomicExpr returns ListFilterMapExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns ListFilterMapExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns ListFilterMapExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns ListFilterMapExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns ListFilterMapExpr
	 *
	 * Constraint:
	 *     (map=AtomicExpr_ListFilterMapExpr_12_2_0_0 args+=Arg+ filter=Expr?)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, ListFilterMapExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns QuantifiedExpr
	 *     Expr returns QuantifiedExpr
	 *     ImpliesExpr returns QuantifiedExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns QuantifiedExpr
	 *     OrExpr returns QuantifiedExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns QuantifiedExpr
	 *     AndExpr returns QuantifiedExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns QuantifiedExpr
	 *     InstanceOfExpr returns QuantifiedExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns QuantifiedExpr
	 *     RelationalExpr returns QuantifiedExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns QuantifiedExpr
	 *     PlusExpr returns QuantifiedExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns QuantifiedExpr
	 *     TimesExpr returns QuantifiedExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns QuantifiedExpr
	 *     ExpExpr returns QuantifiedExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns QuantifiedExpr
	 *     PrefixExpr returns QuantifiedExpr
	 *     AtomicExpr returns QuantifiedExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns QuantifiedExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns QuantifiedExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns QuantifiedExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns QuantifiedExpr
	 *
	 * Constraint:
	 *     ((quant='forall' | quant='exists') args+=Arg+ expr=Expr)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, QuantifiedExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns RealExpr
	 *     Expr returns RealExpr
	 *     ImpliesExpr returns RealExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns RealExpr
	 *     OrExpr returns RealExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns RealExpr
	 *     AndExpr returns RealExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns RealExpr
	 *     InstanceOfExpr returns RealExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns RealExpr
	 *     RelationalExpr returns RealExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns RealExpr
	 *     PlusExpr returns RealExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns RealExpr
	 *     TimesExpr returns RealExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns RealExpr
	 *     ExpExpr returns RealExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns RealExpr
	 *     PrefixExpr returns RealExpr
	 *     AtomicExpr returns RealExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns RealExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns RealExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns RealExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns RealExpr
	 *
	 * Constraint:
	 *     val=RealTerm
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, RealExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.REAL_EXPR__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.REAL_EXPR__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExprAccess().getValRealTermParserRuleCall_4_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns SetExpr
	 *     Expr returns SetExpr
	 *     ImpliesExpr returns SetExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns SetExpr
	 *     OrExpr returns SetExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns SetExpr
	 *     AndExpr returns SetExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns SetExpr
	 *     InstanceOfExpr returns SetExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns SetExpr
	 *     RelationalExpr returns SetExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns SetExpr
	 *     PlusExpr returns SetExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns SetExpr
	 *     TimesExpr returns SetExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns SetExpr
	 *     ExpExpr returns SetExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns SetExpr
	 *     PrefixExpr returns SetExpr
	 *     AtomicExpr returns SetExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns SetExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns SetExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns SetExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns SetExpr
	 *
	 * Constraint:
	 *     (exprs+=AtomicExpr_SetExpr_13_2_1_0 exprs+=Expr*)?
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, SetExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns SetFilterMapExpr
	 *     Expr returns SetFilterMapExpr
	 *     ImpliesExpr returns SetFilterMapExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns SetFilterMapExpr
	 *     OrExpr returns SetFilterMapExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns SetFilterMapExpr
	 *     AndExpr returns SetFilterMapExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns SetFilterMapExpr
	 *     InstanceOfExpr returns SetFilterMapExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns SetFilterMapExpr
	 *     RelationalExpr returns SetFilterMapExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns SetFilterMapExpr
	 *     PlusExpr returns SetFilterMapExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns SetFilterMapExpr
	 *     TimesExpr returns SetFilterMapExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns SetFilterMapExpr
	 *     ExpExpr returns SetFilterMapExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns SetFilterMapExpr
	 *     PrefixExpr returns SetFilterMapExpr
	 *     AtomicExpr returns SetFilterMapExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns SetFilterMapExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns SetFilterMapExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns SetFilterMapExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns SetFilterMapExpr
	 *
	 * Constraint:
	 *     (map=AtomicExpr_SetFilterMapExpr_13_2_0_0 args+=Arg+ filter=Expr?)
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, SetFilterMapExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns StringExpr
	 *     Expr returns StringExpr
	 *     ImpliesExpr returns StringExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns StringExpr
	 *     OrExpr returns StringExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns StringExpr
	 *     AndExpr returns StringExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns StringExpr
	 *     InstanceOfExpr returns StringExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns StringExpr
	 *     RelationalExpr returns StringExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns StringExpr
	 *     PlusExpr returns StringExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns StringExpr
	 *     TimesExpr returns StringExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns StringExpr
	 *     ExpExpr returns StringExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns StringExpr
	 *     PrefixExpr returns StringExpr
	 *     AtomicExpr returns StringExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns StringExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns StringExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns StringExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns StringExpr
	 *
	 * Constraint:
	 *     val=StringTerm
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, StringExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.STRING_EXPR__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.STRING_EXPR__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExprAccess().getValStringTermParserRuleCall_6_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns ThisExpr
	 *     Expr returns ThisExpr
	 *     ImpliesExpr returns ThisExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns ThisExpr
	 *     OrExpr returns ThisExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns ThisExpr
	 *     AndExpr returns ThisExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns ThisExpr
	 *     InstanceOfExpr returns ThisExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns ThisExpr
	 *     RelationalExpr returns ThisExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns ThisExpr
	 *     PlusExpr returns ThisExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns ThisExpr
	 *     TimesExpr returns ThisExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns ThisExpr
	 *     ExpExpr returns ThisExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns ThisExpr
	 *     PrefixExpr returns ThisExpr
	 *     AtomicExpr returns ThisExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns ThisExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns ThisExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns ThisExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns ThisExpr
	 *
	 * Constraint:
	 *     sub=NestedDotID?
	 */
	protected void sequence_AtomicExpr(ISerializationContext context, ThisExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BaseType returns BaseType
	 *
	 * Constraint:
	 *     (
	 *         type='int' | 
	 *         type='real' | 
	 *         type='string' | 
	 *         type='bool' | 
	 *         type='range' | 
	 *         type='aadl' | 
	 *         type='component' | 
	 *         type='abstract' | 
	 *         type='bus' | 
	 *         type='data' | 
	 *         type='device' | 
	 *         type='memory' | 
	 *         type='processor' | 
	 *         type='process' | 
	 *         type='subprogram_group' | 
	 *         type='subprogram' | 
	 *         type='system' | 
	 *         type='thread_group' | 
	 *         type='thread' | 
	 *         type='virtual_bus' | 
	 *         type='virtual_processor' | 
	 *         type='connection' | 
	 *         type='property' | 
	 *         type='feature' | 
	 *         type='port' | 
	 *         type='data_port' | 
	 *         type='event_port' | 
	 *         type='event_data_port' | 
	 *         type='feature_group' | 
	 *         type='access' | 
	 *         type='bus_access' | 
	 *         type='provides_bus_access' | 
	 *         type='requires_bus_access' | 
	 *         type='data_access' | 
	 *         type='provides_data_access' | 
	 *         type='requires_data_access' | 
	 *         type='subprogram_access' | 
	 *         type='provides_subprogram_access' | 
	 *         type='requires_subprogram_access' | 
	 *         type='subprogram_group_access' | 
	 *         type='provides_subprogram_group_access' | 
	 *         type='requires_subprogram_group_access' | 
	 *         type='flow_specification' | 
	 *         type='end_to_end_flow'
	 *     )
	 */
	protected void sequence_BaseType(ISerializationContext context, BaseType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns BaseType
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             type='int' | 
	 *             type='real' | 
	 *             type='string' | 
	 *             type='bool' | 
	 *             type='range' | 
	 *             type='aadl' | 
	 *             type='component' | 
	 *             type='abstract' | 
	 *             type='bus' | 
	 *             type='data' | 
	 *             type='device' | 
	 *             type='memory' | 
	 *             type='processor' | 
	 *             type='process' | 
	 *             type='subprogram_group' | 
	 *             type='subprogram' | 
	 *             type='system' | 
	 *             type='thread_group' | 
	 *             type='thread' | 
	 *             type='virtual_bus' | 
	 *             type='virtual_processor' | 
	 *             type='connection' | 
	 *             type='property' | 
	 *             type='feature' | 
	 *             type='port' | 
	 *             type='data_port' | 
	 *             type='event_port' | 
	 *             type='event_data_port' | 
	 *             type='feature_group' | 
	 *             type='access' | 
	 *             type='bus_access' | 
	 *             type='provides_bus_access' | 
	 *             type='requires_bus_access' | 
	 *             type='data_access' | 
	 *             type='provides_data_access' | 
	 *             type='requires_data_access' | 
	 *             type='subprogram_access' | 
	 *             type='provides_subprogram_access' | 
	 *             type='requires_subprogram_access' | 
	 *             type='subprogram_group_access' | 
	 *             type='provides_subprogram_group_access' | 
	 *             type='requires_subprogram_group_access' | 
	 *             type='flow_specification' | 
	 *             type='end_to_end_flow'
	 *         ) 
	 *         paramType=Type?
	 *     )
	 */
	protected void sequence_BaseType_Type(ISerializationContext context, BaseType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns ClaimArg
	 *     ClaimText returns ClaimArg
	 *
	 * Constraint:
	 *     (arg=[ClaimTextVar|ID] unit=[UnitLiteral|ID]?)
	 */
	protected void sequence_ClaimText(ISerializationContext context, ClaimArg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns ClaimString
	 *     ClaimText returns ClaimString
	 *
	 * Constraint:
	 *     str=STRING
	 */
	protected void sequence_ClaimText(ISerializationContext context, ClaimString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.CLAIM_STRING__STR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.CLAIM_STRING__STR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClaimTextAccess().getStrSTRINGTerminalRuleCall_0_1_0(), semanticObject.getStr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns ConstantDefinition
	 *     Definition returns ConstantDefinition
	 *     ConstantDefinition returns ConstantDefinition
	 *     ClaimTextVar returns ConstantDefinition
	 *
	 * Constraint:
	 *     (name=ID type=Type expr=Expr)
	 */
	protected void sequence_ConstantDefinition(ISerializationContext context, ConstantDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()));
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.CONSTANT_DEFINITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.CONSTANT_DEFINITION__TYPE));
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.CONSTANT_DEFINITION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.CONSTANT_DEFINITION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantDefinitionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstantDefinitionAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getConstantDefinitionAccess().getExprExprParserRuleCall_4_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns ClaimBody
	 *     DefinitionBody returns ClaimBody
	 *
	 * Constraint:
	 *     (claim+=ClaimText+ expr=Expr)
	 */
	protected void sequence_DefinitionBody(ISerializationContext context, ClaimBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns FunctionBody
	 *     DefinitionBody returns FunctionBody
	 *
	 * Constraint:
	 *     (type=Type expr=Expr)
	 */
	protected void sequence_DefinitionBody(ISerializationContext context, FunctionBody semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.FUNCTION_BODY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.FUNCTION_BODY__TYPE));
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.DEFINITION_BODY__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.DEFINITION_BODY__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefinitionBodyAccess().getTypeTypeParserRuleCall_0_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getDefinitionBodyAccess().getExprExprParserRuleCall_0_4_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Namespace returns FunctionDefinition
	 *     NamedElement returns FunctionDefinition
	 *     Definition returns FunctionDefinition
	 *     FunctionDefinition returns FunctionDefinition
	 *
	 * Constraint:
	 *     (name=ID (args+=Arg args+=Arg*)? body=DefinitionBody)
	 */
	protected void sequence_FunctionDefinition(ISerializationContext context, FunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns InstanceOfExpr
	 *     Expr returns InstanceOfExpr
	 *     ImpliesExpr returns InstanceOfExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns InstanceOfExpr
	 *     OrExpr returns InstanceOfExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns InstanceOfExpr
	 *     AndExpr returns InstanceOfExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns InstanceOfExpr
	 *     InstanceOfExpr returns InstanceOfExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns InstanceOfExpr
	 *     RelationalExpr returns InstanceOfExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns InstanceOfExpr
	 *     PlusExpr returns InstanceOfExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns InstanceOfExpr
	 *     TimesExpr returns InstanceOfExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns InstanceOfExpr
	 *     ExpExpr returns InstanceOfExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns InstanceOfExpr
	 *     PrefixExpr returns InstanceOfExpr
	 *     AtomicExpr returns InstanceOfExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns InstanceOfExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns InstanceOfExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns InstanceOfExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns InstanceOfExpr
	 *
	 * Constraint:
	 *     (expr=InstanceOfExpr_InstanceOfExpr_1_0_0_0 type=BaseType)
	 */
	protected void sequence_InstanceOfExpr(ISerializationContext context, InstanceOfExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.INSTANCE_OF_EXPR__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.INSTANCE_OF_EXPR__EXPR));
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.INSTANCE_OF_EXPR__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.INSTANCE_OF_EXPR__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInstanceOfExprAccess().getInstanceOfExprExprAction_1_0_0_0(), semanticObject.getExpr());
		feeder.accept(grammarAccess.getInstanceOfExprAccess().getTypeBaseTypeParserRuleCall_1_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntegerTerm returns IntegerLiteral
	 *     PropertyExpression returns IntegerLiteral
	 *     NumAlt returns IntegerLiteral
	 *
	 * Constraint:
	 *     (value=UnsignedInt unit=[UnitLiteral|ID]?)
	 */
	protected void sequence_IntegerTerm(ISerializationContext context, IntegerLiteral semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns LetBinding
	 *     ClaimTextVar returns LetBinding
	 *     LetBinding returns LetBinding
	 *
	 * Constraint:
	 *     (name=ID type=Type expr=Expr)
	 */
	protected void sequence_LetBinding(ISerializationContext context, LetBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Aadl2Package.eINSTANCE.getNamedElement_Name()));
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.LET_BINDING__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.LET_BINDING__TYPE));
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.LET_BINDING__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.LET_BINDING__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetBindingAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLetBindingAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getLetBindingAccess().getExprExprParserRuleCall_4_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NestedDotID returns NestedDotID
	 *
	 * Constraint:
	 *     (base=[NamedElement|ID] sub=NestedDotID?)
	 */
	protected void sequence_NestedDotID(ISerializationContext context, NestedDotID semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns CastExpr
	 *     Expr returns CastExpr
	 *     ImpliesExpr returns CastExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns CastExpr
	 *     OrExpr returns CastExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns CastExpr
	 *     AndExpr returns CastExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns CastExpr
	 *     InstanceOfExpr returns CastExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns CastExpr
	 *     RelationalExpr returns CastExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns CastExpr
	 *     PlusExpr returns CastExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns CastExpr
	 *     TimesExpr returns CastExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns CastExpr
	 *     ExpExpr returns CastExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns CastExpr
	 *     PrefixExpr returns CastExpr
	 *     AtomicExpr returns CastExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns CastExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns CastExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns CastExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns CastExpr
	 *
	 * Constraint:
	 *     (type=BaseType expr=PrefixExpr)
	 */
	protected void sequence_PrefixExpr(ISerializationContext context, CastExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.CAST_EXPR__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.CAST_EXPR__TYPE));
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.CAST_EXPR__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.CAST_EXPR__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrefixExprAccess().getTypeBaseTypeParserRuleCall_1_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPrefixExprAccess().getExprPrefixExprParserRuleCall_1_4_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns UnaryExpr
	 *     Expr returns UnaryExpr
	 *     ImpliesExpr returns UnaryExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     OrExpr returns UnaryExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     AndExpr returns UnaryExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     InstanceOfExpr returns UnaryExpr
	 *     InstanceOfExpr.InstanceOfExpr_1_0_0_0 returns UnaryExpr
	 *     RelationalExpr returns UnaryExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     PlusExpr returns UnaryExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     TimesExpr returns UnaryExpr
	 *     TimesExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     ExpExpr returns UnaryExpr
	 *     ExpExpr.BinaryExpr_1_0_0_0 returns UnaryExpr
	 *     PrefixExpr returns UnaryExpr
	 *     AtomicExpr returns UnaryExpr
	 *     AtomicExpr.ListFilterMapExpr_12_2_0_0 returns UnaryExpr
	 *     AtomicExpr.ListExpr_12_2_1_0 returns UnaryExpr
	 *     AtomicExpr.SetFilterMapExpr_13_2_0_0 returns UnaryExpr
	 *     AtomicExpr.SetExpr_13_2_1_0 returns UnaryExpr
	 *
	 * Constraint:
	 *     ((op='-' | op='not') expr=PrefixExpr)
	 */
	protected void sequence_PrefixExpr(ISerializationContext context, UnaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns ProveStatement
	 *     ProveStatement returns ProveStatement
	 *
	 * Constraint:
	 *     expr=Expr
	 */
	protected void sequence_ProveStatement(ISerializationContext context, ProveStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.PROVE_STATEMENT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.PROVE_STATEMENT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProveStatementAccess().getExprExprParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RealTerm returns RealLiteral
	 *     PropertyExpression returns RealLiteral
	 *     NumAlt returns RealLiteral
	 *
	 * Constraint:
	 *     (value=UnsignedReal unit=[UnitLiteral|ID]?)
	 */
	protected void sequence_RealTerm(ISerializationContext context, RealLiteral semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnexLibrary returns ResoluteLibrary
	 *     ResoluteLibrary returns ResoluteLibrary
	 *
	 * Constraint:
	 *     definitions+=Definition*
	 */
	protected void sequence_ResoluteLibrary(ISerializationContext context, ResoluteLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnexSubclause returns ResoluteSubclause
	 *     ResoluteSubclause returns ResoluteSubclause
	 *
	 * Constraint:
	 *     proves+=ProveStatement*
	 */
	protected void sequence_ResoluteSubclause(ISerializationContext context, ResoluteSubclause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns LibraryFnType
	 *
	 * Constraint:
	 *     (libName=ID fnType=ID)
	 */
	protected void sequence_Type(ISerializationContext context, LibraryFnType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.LIBRARY_FN_TYPE__LIB_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.LIBRARY_FN_TYPE__LIB_NAME));
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.LIBRARY_FN_TYPE__FN_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.LIBRARY_FN_TYPE__FN_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getLibNameIDTerminalRuleCall_3_1_0(), semanticObject.getLibName());
		feeder.accept(grammarAccess.getTypeAccess().getFnTypeIDTerminalRuleCall_3_3_0(), semanticObject.getFnType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ListType
	 *
	 * Constraint:
	 *     type=Type
	 */
	protected void sequence_Type(ISerializationContext context, ListType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.LIST_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.LIST_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getTypeTypeParserRuleCall_0_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns SetType
	 *
	 * Constraint:
	 *     type=Type
	 */
	protected void sequence_Type(ISerializationContext context, SetType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ResolutePackage.Literals.SET_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ResolutePackage.Literals.SET_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getTypeTypeParserRuleCall_1_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
}
