import "Common.stg"
import "CommonOSSpecificNames.stg"
import "CommonCPrototypes.stg"

/*********************************************************************
 * OS-specific naming functions required by this file:
 *   dispatcherMainInitializeLockStmt
 *   dispatcherMainLockWaitStmt
 *   dispatcherMainLockReleaseStmt
 *   osSpecificIncludeFiles
 *   osSpecificThreadInitializer
 *   osSpecificThreadEntrypoint
 *   osSpecificComponentLocalCallerFunction
 *   osSpecificAssert
 *   aadlInputToExternalInput  <== currently aadlInputToCamkesInput
 *
 * Dummy declarations are provided by CommonOSSpecificNames.
 * These must be overridden by redefinition (see CamkesComponentC.stg
 * for an example).  For more information on template overriding,
 * please see: www.stringtemplate.org.
 *
 * Removed (after refactoring for ports) 
 *   osSpecificIrqDispatcher
 *   portDispatcherLock
 *   portDispatcherUnlock
 *      portLockStmt
 *   portUnlockStmt
 *   incomingPortWriterName
 *   outgoingPortWriterName
 *   incomingActiveThreadDispatchName
 *   outgoingActiveThreadDispatchName
 *   incomingUserEntrypoingCallerName
 *   outgoingUserEntrypointCallerName
 *
 *********************************************************************/

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component gluecode C files for CAmkES/eChronos
//
//
////////////////////////////////////////////////////////////////////////////

componentGlueCodeCFilePurpose(name) ::= <<
This C file contains the implementations of the AADL primitives
used by user-level declarations for thread <name>.

The user code runs in terms of "dispatchers", which cause
dispatch user-level handlers to execute.  These handlers can
communicate using the standard AADL primitives, which are mapped
to C functions.

The send/receive handlers are not thread safe in CAmkES; it is
assumed that this is handled by the CAmkES sequentialized access
to the dispatch handler.  There is only one dispatch interface
for the component containing all of the dispatch points.

They are thread safe for eChronos.

The read/write handlers are thread safe because the writer comes
through a dispatch interface but the reader is "local" on a dispatch
interface and so contention may occur.
>>

filePrefix(name, date, path) ::=
    "<stdFilePrefix(date, path, componentGlueCodeCFilePurpose(name))>"

filePostfix(name, path) ::= <<
>>


/////////////////////////////////////////////////////////////////////
//
// UserEntrypointCaller functions
//
// These functions provide the "scaffolding" functions necessary to
// set up the output event ports prior to making a call to the user
// code.
//
// These are the implementations of the RPC functions for passive
// components that are called using CAmkES/eChronos.  They are also used
// in active components to set up local procedure calls to user code.
//
/////////////////////////////////////////////////////////////////////


userEntrypointCallerCall(externalHandler, dispatcher) ::= <<
<if(dispatcher.hasData)>
<externalHandler.handlerName>(<dispatcher.type.camkesInputToAadlInput> in_arg);
<else><externalHandler.handlerName>();
<endif>
>>

userEntrypointCallerAssignGlobals(dispatchContract, dispatcher) ::= <<
<dispatchContract.port.globalMaxDispatchSize> = <dispatchContract.maxDispatchSize>;
<if(dispatchContract.canDispatch)><\\>
<dispatchContract.port.globalIndex> = &(out_arg-><dispatchContract.port.index>);
<if(dispatchContract.port.hasData)><dispatchContract.port.globalData> = out_arg-><dispatchContract.port.data>;<endif>
*<dispatchContract.port.globalIndex> = 0;
<endif>
>>

userEntrypointCallerFn(dispatcher) ::= <<
/************************************************************************
 *  <incomingUserEntrypointCallerName(dispatcher)>:
 * Invoked by remote RPC (or, for active thread, local dispatcher).
 *
 * This is the function invoked by an active thread dispatcher to
 * call to a user-defined entrypoint function.  It sets up the dispatch
 * context for the user-defined entrypoint, then calls it.
 *
 ************************************************************************/
<userEntrypointCallerPrototype(dispatcher)> {
    <dispatcher.portDispatcherLock>
    <dispatcher.threadImplementation.portList:{port | port.writePortPreEntrypoint}>
    <dispatcher.maxDispatchContracts.passiveContracts:userEntrypointCallerAssignGlobals(dispatcher)>
    <dispatcher.externalHandlers:userEntrypointCallerCall(dispatcher)>
    <dispatcher.threadImplementation.portList:{port | port.writePortPostEntrypoint}>
    <dispatcher.portDispatcherUnlock>
}


>>




drainDispatcher(dispatcher) ::= <<
<if(dispatcher.isPeriodic)><\\>
<dispatcher:periodicDispatcher()>
<elseif(dispatcher.isIRQ)><\\>
<dispatcher:irqDispatcher()>
<elseif(dispatcher.isInputEvent)><\\>
<dispatcher:eventDispatcher()>
<elseif(dispatcher.isInputEventData)>
<dispatcher:eventDataDispatcher()>
<elseif(dispatcher.isInitializer)>
<else>
    ERROR: dispatcher is not of periodic, IRQ, Event, or EventData type.
<endif>
>>


dispatcherComponentEventDecls(dispatcher) ::=  <<

<if(dispatcher.isPeriodic)><dispatcherComponentPeriodicEventDecls(dispatcher)>
<elseif(dispatcher.isIRQ)><dispatcherComponentIRQEventDecls(dispatcher)>
<else> <endif>
>>

dispatcherComponentMainFunction(threadImpl) ::= <<
/************************************************************************
 * <osSpecificThreadEntrypoint(threadImpl)>
 * Main active thread function.
 *
 ************************************************************************/

<osSpecificThreadEntrypoint(threadImpl)> {
    <commentIf("Port initialization routines",
               (threadImpl.portList:{ port | port.writePortThreadInitializer}))><\\>

    <if(threadImpl.hasInitializeEntrypoint)>
    // thread initialization routines (if any)...
    int64_t dummy_time = 0;
    <activeThreadInternalDispatcherName(threadImpl.initializeEntrypointOpt)>(&dummy_time);
    <endif>

    <commentIf("Register interrupt handlers",
               (osSpecificThreadPostInitializer(threadImpl)))><\\>

    // Initial lock to await dispatch input.
    <dispatcherMainInitializeLockStmt(threadImpl)>
    for(;;) {
        <dispatcherMainLockWaitStmt(threadImpl)>

        // Drain the queues
        <threadImpl.portList:{ port | port.writePortEventResponder} >
    }

    // Won't ever get here, but form must be followed
    <osSpecificThreadReturnStmt(threadImpl)>
}
>>



///////////////////////////////////////////////////////////////////////////
//
// Putting it all together...
//
///////////////////////////////////////////////////////////////////////////

componentCFileDecls(threadImpl) ::= <<

#include <\u0022><threadImpl.componentGlueCodeHFileName><\u0022>
<osSpecificIncludeFiles(threadImpl)>

<threadImpl.portList: {port | port.writePortDeclarations }>

<if(threadImpl.isActive)><\\>
<threadImpl.localActiveThreadConnectionFrontier:osSpecificComponentLocalCallerFunction()>
<if(threadImpl.isExternal)><\\>
////////////////////////////////////////////////////////////////////////////
//
// NOTE: External thread, so we assume the run function is externally declared.
//
////////////////////////////////////////////////////////////////////////////
<else>
<dispatcherComponentMainFunction(threadImpl)>
<endif>
<endif>

>>
