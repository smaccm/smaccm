delimiters "$", "$"
import "xmlCommon.stg"

//imported from eChronosComponentC
incomingPortWriterName(port) ::= "smaccm_$port.qualifiedName$_$port.type.writerFn$"
incomingActiveThreadDispatchName(dispatcher) ::= "$incomingPortWriterName(dispatcher)$"


////////////////////////////////////////////////////////////////////////////
//
// Declarations related to eChronos .prx file
// 
////////////////////////////////////////////////////////////////////////////

prxPurpose(sysInstanceName) ::= <<
This file contains the main eChronos .prx assembly for the  
AADL system instance rooted at $sysInstanceName$.
>>

filePrefix(name, date, path, datatypesHeader) ::= <<
<?xml version="1.0" encoding="UTF-8" ?>
$xmlDARPALicenseComment()$

$xmlFilenameBlockComment(date, path, prxPurpose(name))$

>>

filePostfix(name, path) ::= <<

$xmlBlockComment(arg={End of autogenerated file: $path$})$

>>

writeTrampoline(name, flihName) ::= <<

	<trampoline>
		<name>$name$</name>
		<handler>$flihName$</handler>
	</trampoline>

>>

writeDispatcherTrampoline(dispatcher) ::= <<
$writeTrampoline(dispatcher.signalName, incomingActiveThreadDispatchName(dispatcher))$
>>

writeExternalIsrTrampoline(externalIsr) ::= <<
$writeTrampoline(externalIsr.name, externalIsr.handlerName)$
>>

writeTrampolines(model) ::= << 
$model.irqDispatchers:writeDispatcherTrampoline()$
$if(model.threadCalendar.hasDispatchers && 
	model.generateSystickIrq)$
$writeTrampoline("systick", "smaccm_tick_irq")$
$endif$
$model.externalISRs:writeExternalIsrTrampoline()$
>>

writeInternalInterruptHandler(signalName) ::= <<
<$signalName$>rtos_internal_exception_preempt_trampoline_$signalName$</$signalName$>
>>

writeExternalInterruptHandler(signalName, signalNumber) ::= <<
<external_irq>
	<number>$signalNumber$</number>
	<handler>rtos_internal_exception_preempt_trampoline_$signalName$</handler>
</external_irq>
>>

writeInternalDispatcherInterruptHandler(dispatcher) ::= << 
$writeInternalInterruptHandler(dispatcher.signalName)$
>>

writeExternalDispatcherInterruptHandler(dispatcher) ::= << 
$writeExternalInterruptHandler(dispatcher.signalName, dispatcher.signalNumber)$
>>

writeInterruptHandlers(model) ::= <<
$if(model.threadCalendar.hasDispatchers && 
	model.generateSystickIrq)$
$writeInternalInterruptHandler("systick")$
$endif$
$model.internalIrqDispatchers:writeInternalDispatcherInterruptHandler()$
<external_irqs>
	$model.externalIrqDispatchers:writeExternalDispatcherInterruptHandler()$
</external_irqs>
>>

writeSignalLabels(model) ::= << >>

writeTask(threadImpl) ::= <<
	<task>
		<name>$threadImpl.normalizedName$</name>
		<function>$threadImpl.threadImplMainFnName$</function>
		<priority>$threadImpl.priority$</priority>
		<stack_size>$threadImpl.stackSize$</stack_size>
	</task>
>>

writeTasks(model) ::= <<
$model.ActiveThreadImplementations:writeTask()$
>>

/*
 * $if(model.threadCalendar.hasDispatchers)$
	<!-- NOTE: the threadCalendar priority is currently hard-coded.  We should add a user property -->
	<task>
		<name>smaccm_periodic_dispatcher</name>
		<function>smaccm_periodic_dispatcher</function>
		<priority>$model.threadCalendar.priority$</priority>
		<stack_size>512</stack_size>
	</task>
$else$
	<!-- No periodic dispatcher thread -->
$endif$
 
 */
writeMutex(name) ::= <<
  <mutex>
	<name>$name$</name>
  </mutex>
>>

// Fill in more stuff HERE!
writeInputPortMutex(port) ::= << 
$writeMutex(port.mutex)$
>> 

writeActiveThreadMutexes(threadImpl) ::= <<
$writeMutex(threadImpl.eChronosThreadDispatcherMutex)$
$threadImpl.inputPortList:writeInputPortMutex()$
$threadImpl.externalMutexes:writeMutex()$
>>

writePassiveThreadMutexes(threadImpl) ::= <<
$writeMutex(threadImpl.eChronosThreadDispatcherMutex)$
$threadImpl.externalMutexes:writeMutex()$
>>

writeMutexes(model) ::= <<
$model.externalMutexList:writeMutex()$
$model.activeThreadImplementations:writeActiveThreadMutexes()$
$model.passiveThreadImplementations:writePassiveThreadMutexes()$
>>

writeSemaphore(name) ::= <<
  <semaphore>
    <name>$name$</name>
  </semaphore>
>>

writeThreadSemaphores(threadImpl) ::= <<
$threadImpl.externalSemaphores:writeSemaphore()$
>>

writeSemaphores(model) ::= <<
	$model.externalSemaphoreList:writeSemaphore()$
	$model.threadImplementations:writeThreadSemaphores()$
>>


writeInterruptEvent(name, taskName, signalSet) ::= <<
<interrupt_event>
	<name>$name$</name>
	<task>$taskName$</task>
	<sig_set>$signalSet$</sig_set>
</interrupt_event>
>>

writeExternalIrqEvent(externalIrqEvent) ::= <<
$writeInterruptEvent(
	externalIrqEvent.name, 
	externalIrqEvent.taskName,
	externalIrqEvent.signalSet)$
>>

/*
writeActiveThreadIrqDispatcher(dispatcher) ::= << 
$if(dispatcher.isIRQ)$
$writeInterruptEvent(dispatcher.name, dispatcher.threadImplementation.normalizedName, "smaccm_dispatcher")$
$elseif(dispatcher.isPeriodic)$
$writeInterruptEvent(dispatcher.threadImplementation.eChronosInterruptSignal, dispatcher.threadImplementation.normalizedName, "smaccm_dispatcher")$
$endif$
>>


 $threadImpl.dispatchers:writeActiveThreadIrqDispatcher()$
 * 
 */



writeActiveThreadIrqDispatchers(threadImpl) ::= <<
$writeInterruptEvent(threadImpl.eChronosInterruptSignal, threadImpl.normalizedName, threadImpl.eChronosDispatchSignal)$
>>

writeInterruptEvents(model) ::= <<
	$model.externalIRQEvents:writeExternalIrqEvent()$
	$model.activeThreadImplementations:writeActiveThreadIrqDispatchers()$
>>

writeCodeModule(moduleName, model) ::= << 
<module name="$model.eChronosCModulePath$.$moduleName$" />
>>

writeCodeModules(model) ::= <<
$model.cFileModules:writeCodeModule(model)$
>>